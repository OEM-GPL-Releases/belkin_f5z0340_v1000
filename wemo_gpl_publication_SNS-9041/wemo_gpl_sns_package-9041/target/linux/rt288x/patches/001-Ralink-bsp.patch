From 8e0a9b4fad897f88bb3789599aa8251c8c873912 Mon Sep 17 00:00:00 2001
From: Hugh Daschbach <hugh.daschbach-c@belkin.com>
Date: Fri, 15 Nov 2013 14:33:38 -0800
Subject: [PATCH 1/3] Initial Ralink patchset.

---
 MAINTAINERS                                        |   5 +
 Makefile                                           |  18 +-
 arch/mips/Kconfig                                  | 829 ++-------------------
 arch/mips/Kconfig.debug                            |   6 +
 arch/mips/Makefile                                 |  54 ++
 arch/mips/kernel/genex.S                           |  23 +
 arch/mips/kernel/irixelf.c                         |  11 +-
 arch/mips/kernel/kspd.c                            |   5 +-
 arch/mips/kernel/ptrace.c                          |  21 +-
 arch/mips/kernel/rtlx.c                            |   7 +-
 arch/mips/kernel/time.c                            |  61 ++
 arch/mips/lib/iomap.c                              |   2 +-
 arch/mips/mm/cache.c                               |   2 +-
 arch/mips/pci/pci.c                                |  12 +
 arch/mips/qemu/Makefile                            |   1 +
 arch/mips/qemu/q-setup.c                           |   5 +
 drivers/Kconfig                                    |   3 +
 drivers/Makefile                                   |   4 +
 drivers/block/Kconfig                              |   1 +
 drivers/char/Kconfig                               | 190 ++++-
 drivers/char/Makefile                              |  17 +-
 drivers/char/watchdog/Kconfig                      |  11 +
 drivers/char/watchdog/Makefile                     |   1 +
 drivers/char/watchdog/softdog.c                    |  46 +-
 drivers/ide/mips/Makefile                          |   2 +-
 drivers/media/video/Kconfig                        |   2 +
 drivers/media/video/Makefile                       |   1 +
 drivers/mtd/Makefile                               |   2 +-
 drivers/mtd/chips/Kconfig                          |   5 +
 drivers/mtd/chips/Makefile                         |   1 +
 drivers/mtd/chips/cfi_cmdset_0002.c                | 138 +++-
 drivers/mtd/chips/cfi_probe.c                      |  29 +-
 drivers/mtd/chips/cfi_util.c                       |  51 +-
 drivers/mtd/chips/gen_probe.c                      |   5 +
 drivers/mtd/devices/docprobe.c                     |   6 +-
 drivers/mtd/maps/Kconfig                           |   4 +
 drivers/mtd/maps/Makefile                          |   2 +
 drivers/mtd/maps/lasat.c                           |   2 +-
 drivers/mtd/mtdchar.c                              |   4 +-
 drivers/net/Kconfig                                | 228 +++++-
 drivers/net/Makefile                               |  16 +-
 drivers/net/ioc3-eth.c                             |  46 +-
 drivers/net/pppox.c                                |   7 +
 drivers/net/wireless/Makefile                      |  10 +
 drivers/scsi/NCR53C9x.h                            |   7 +-
 drivers/scsi/sgiwd93.c                             |   2 +
 drivers/serial/8250.c                              |  56 +-
 drivers/serial/8250_early.c                        |  11 +-
 drivers/serial/ip22zilog.c                         |   3 +
 drivers/serial/serial_core.c                       |   8 +
 drivers/usb/Kconfig                                |   6 +-
 drivers/usb/Makefile                               |   1 +
 drivers/usb/core/hcd.c                             |   3 +-
 drivers/usb/core/message.c                         |  29 +-
 drivers/usb/core/usb.c                             |   2 +-
 drivers/usb/gadget/Kconfig                         |   8 +
 drivers/usb/gadget/Makefile                        |   6 +-
 drivers/usb/gadget/ether.c                         |  21 +-
 drivers/usb/gadget/file_storage.c                  | 173 ++++-
 drivers/usb/gadget/gadget_chips.h                  |  21 +
 drivers/usb/host/Kconfig                           |  10 +
 drivers/usb/host/ehci-hcd.c                        |   5 +
 drivers/usb/host/ehci-q.c                          |  14 +
 drivers/usb/host/ehci-sched.c                      |  82 +-
 drivers/usb/host/ohci-hcd.c                        |   4 +
 drivers/usb/serial/Kconfig                         |   5 +
 drivers/usb/serial/Makefile                        |   1 +
 drivers/usb/serial/option.c                        | 243 +++++-
 drivers/usb/storage/scsiglue.c                     |   8 +-
 drivers/video/Kconfig                              |  31 +-
 drivers/video/Makefile                             |   1 +
 fs/Kconfig                                         |  68 +-
 fs/Makefile                                        |   8 +-
 fs/aio.c                                           |  53 ++
 fs/binfmt_elf.c                                    |  28 +
 fs/buffer.c                                        |   4 +
 fs/exec.c                                          |   4 +
 fs/namei.c                                         |  13 +
 fs/proc/proc_misc.c                                |   4 +
 fs/super.c                                         |   4 +
 fs/sync.c                                          |   2 +
 include/asm-mips/addrspace.h                       |   1 +
 include/asm-mips/bootinfo.h                        |   7 +
 include/asm-mips/mach-generic/ide.h                |  11 +-
 include/linux/Kbuild                               |   1 +
 include/linux/ethtool.h                            |  18 +
 include/linux/filter.h                             |   6 +
 include/linux/fs.h                                 |  57 +-
 include/linux/if_ppp.h                             |  16 +
 include/linux/if_pppox.h                           | 115 ++-
 include/linux/igmp.h                               |  20 +
 include/linux/irq.h                                |   6 +-
 include/linux/kernel.h                             |  17 +-
 include/linux/mempool.h                            |  19 +
 include/linux/mroute.h                             |   4 +
 include/linux/mtd/cfi.h                            |  23 +
 include/linux/netdevice.h                          |  12 +-
 include/linux/netfilter_ipv4.h                     |   3 +
 include/linux/netlink.h                            |   4 +-
 include/linux/pci_ids.h                            |   3 +
 include/linux/sched.h                              |   2 +-
 include/linux/serial.h                             |   3 +-
 include/linux/serialP.h                            |   1 +
 include/linux/serial_reg.h                         |  89 ++-
 include/linux/skbuff.h                             |   4 +
 include/linux/socket.h                             |   2 +
 include/linux/swap.h                               |   2 +-
 include/linux/swapops.h                            |  21 +
 include/linux/tty.h                                |   2 +-
 include/linux/usb_gadget.h                         |   1 +
 include/linux/xattr.h                              |   7 +
 include/net/af_unix.h                              |   4 +
 include/net/inetpeer.h                             |   9 +
 include/net/netfilter/nf_conntrack.h               |  16 +
 include/net/protocol.h                             |   4 +
 include/net/sock.h                                 |   8 +
 init/Kconfig                                       | 178 ++++-
 init/do_mounts.c                                   |  70 +-
 init/do_mounts_rd.c                                |  17 +
 init/main.c                                        |   1 +
 kernel/panic.c                                     |  29 +-
 kernel/printk.c                                    |  18 +-
 kernel/sys.c                                       |   2 +-
 kernel/sys_ni.c                                    |  18 +
 kernel/sysctl.c                                    |   8 +
 mm/Makefile                                        |   3 +-
 mm/mempool.c                                       |  50 ++
 mm/page-writeback.c                                |  18 +
 mm/page_alloc.c                                    |   2 +
 net/8021q/vlan_dev.c                               |  10 +
 net/Makefile                                       |  21 +
 net/bridge/Kconfig                                 |   7 +
 net/bridge/br_fdb.c                                |  14 +
 net/bridge/br_if.c                                 |   6 +-
 net/core/Makefile                                  |   7 +-
 net/core/dev.c                                     |  13 +-
 net/core/flow.c                                    |   4 +
 net/core/skbuff.c                                  |   8 +
 net/core/sock.c                                    |   5 +-
 net/ipv4/Kconfig                                   |   6 +
 net/ipv4/Makefile                                  |   6 +-
 net/ipv4/ip_forward.c                              |  11 +-
 net/ipv4/ip_input.c                                |  22 +-
 net/ipv4/ip_output.c                               |   5 +-
 net/ipv4/ip_sockglue.c                             |   4 +
 net/ipv4/ipmr.c                                    |  12 +-
 net/ipv4/netfilter/Kconfig                         |  65 ++
 net/ipv4/netfilter/Makefile                        |  10 +
 net/ipv4/netfilter/ip_conntrack_core.c             | 129 ++++
 net/ipv4/netfilter/ip_conntrack_proto_tcp.c        |   4 +
 net/ipv4/netfilter/ip_conntrack_standalone.c       |  21 +
 net/ipv4/netfilter/ip_tables.c                     |  23 +-
 net/ipv4/netfilter/nf_conntrack_l3proto_ipv4.c     |  36 +
 .../netfilter/nf_conntrack_l3proto_ipv4_compat.c   |   6 +
 net/ipv4/netfilter/nf_nat_sip.c                    |  41 +-
 net/ipv4/netfilter/nf_nat_standalone.c             |   9 +-
 net/ipv4/sysctl_net_ipv4.c                         |   4 +
 net/ipv4/udp.c                                     |  61 +-
 net/ipv6/ip6_input.c                               |  19 +
 net/ipv6/netfilter/Kconfig                         |  10 +
 net/ipv6/netfilter/Makefile                        |   1 +
 net/ipv6/netfilter/nf_conntrack_l3proto_ipv6.c     |  19 +
 net/netfilter/Kconfig                              |  60 +-
 net/netfilter/Makefile                             |  10 +
 net/netfilter/nf_conntrack_core.c                  | 235 +++++-
 net/netfilter/nf_conntrack_proto_tcp.c             |   4 +
 net/netfilter/nf_conntrack_sip.c                   |  40 +-
 net/netfilter/nf_conntrack_standalone.c            |   5 +
 net/sched/sch_generic.c                            |   6 +
 net/sched/sch_htb.c                                |  10 +
 net/sunrpc/cache.c                                 |   4 +
 scripts/gen_initramfs_list.sh                      |  11 +-
 scripts/kconfig/lxdialog/check-lxdialog.sh         |  10 +-
 scripts/mod/sumversion.c                           |   1 +
 sound/oss/Kconfig                                  |   7 +
 sound/oss/Makefile                                 |   1 +
 usr/Kconfig                                        |   2 +-
 usr/Makefile                                       |   3 +-
 179 files changed, 3786 insertions(+), 1136 deletions(-)

diff --git a/MAINTAINERS b/MAINTAINERS
index 277877a..7408dc9 100644
--- a/MAINTAINERS
+++ b/MAINTAINERS
@@ -2700,6 +2700,11 @@ P:	Michal Ostrowski
 M:	mostrows@speakeasy.net
 S:	Maintained
 
+PPP OVER L2TP
+P:	Martijn van Oosterhout
+M:	kleptog@svana.org
+S:	Maintained
+
 PREEMPTIBLE KERNEL
 P:	Robert Love
 M:	rml@tech9.net
diff --git a/Makefile b/Makefile
index d970cb1..47fca4f 100644
--- a/Makefile
+++ b/Makefile
@@ -158,10 +158,7 @@ export srctree objtree VPATH TOPDIR
 # then ARCH is assigned, getting whatever value it gets normally, and 
 # SUBARCH is subsequently ignored.
 
-SUBARCH := $(shell uname -m | sed -e s/i.86/i386/ -e s/sun4u/sparc64/ \
-				  -e s/arm.*/arm/ -e s/sa110/arm/ \
-				  -e s/s390x/s390/ -e s/parisc64/parisc/ \
-				  -e s/ppc.*/powerpc/ -e s/mips.*/mips/ )
+SUBARCH := mips
 
 # Cross compiling and selecting different set of gcc/bin-utils
 # ---------------------------------------------------------------------------
@@ -496,6 +493,7 @@ else
 CFLAGS		+= -fomit-frame-pointer
 endif
 
+CFLAGS		+= -gdwarf-2
 ifdef CONFIG_DEBUG_INFO
 CFLAGS		+= -g
 endif
@@ -507,6 +505,9 @@ CFLAGS          += $(call cc-option, -fno-stack-protector)
 NOSTDINC_FLAGS += -nostdinc -isystem $(shell $(CC) -print-file-name=include)
 CHECKFLAGS     += $(NOSTDINC_FLAGS)
 
+CFLAGS += $(call cc-option,-membedded-data,)
+CFLAGS += $(call cc-option,-muninit-const-in-rodata,)
+
 # warn about C99 declaration after statement
 CFLAGS += $(call cc-option,-Wdeclaration-after-statement,)
 
@@ -904,7 +905,6 @@ include/linux/utsrelease.h: include/config/kernel.release FORCE
 
 PHONY += depend dep
 depend dep:
-	@echo '*** Warning: make $@ is unnecessary now.'
 
 # ---------------------------------------------------------------------------
 # Kernel headers
@@ -988,11 +988,11 @@ _modinst_:
 ifeq "$(strip $(INSTALL_MOD_PATH))" ""
 depmod_opts	:=
 else
-depmod_opts	:= -b $(INSTALL_MOD_PATH) -r
+depmod_opts	:= -b $(MODLIB) 
 endif
 PHONY += _modinst_post
 _modinst_post: _modinst_
-	if [ -r System.map -a -x $(DEPMOD) ]; then $(DEPMOD) -ae -F System.map $(depmod_opts) $(KERNELRELEASE); fi
+	if [ -r System.map -a -x $(DEPMOD) ]; then $(DEPMOD) -F System.map $(depmod_opts); fi
 
 else # CONFIG_MODULES
 
@@ -1019,7 +1019,8 @@ endif # CONFIG_MODULES
 # Directories & files removed with 'make clean'
 CLEAN_DIRS  += $(MODVERDIR)
 CLEAN_FILES +=	vmlinux System.map \
-                .tmp_kallsyms* .tmp_version .tmp_vmlinux* .tmp_System.map
+                .tmp_kallsyms* .tmp_version .tmp_vmlinux* .tmp_System.map \
+		scripts/kconfig/mconf scripts/kconfig/conf
 
 # Directories & files removed with 'make mrproper'
 MRPROPER_DIRS  += include/config include2 usr/include
@@ -1046,6 +1047,7 @@ clean: archclean $(clean-dirs)
 		-o -name '.*.d' -o -name '.*.tmp' -o -name '*.mod.c' \
 		-o -name '*.symtypes' \) \
 		-type f -print | xargs rm -f
+	rm -f vmlinux .tmp_vmlinux1 .tmp_vmlinux2
 
 # mrproper - Delete all generated files, including .config
 #
diff --git a/arch/mips/Kconfig b/arch/mips/Kconfig
index c78b143..5d1103c 100644
--- a/arch/mips/Kconfig
+++ b/arch/mips/Kconfig
@@ -8,833 +8,103 @@ mainmenu "Linux/MIPS Kernel Configuration"
 
 menu "Machine selection"
 
+
 config ZONE_DMA
 	bool
 	default y
 
+config RALINK_RT2880_MP
+	bool
+config RALINK_RT2880_SHUTTLE
+	bool
+config RALINK_RT3052_MP2
+	bool
+config RALINK_RT3352_MP
+	bool
+config RALINK_RT5350_MP
+	bool
+config RALINK_RT3883_MP
+	bool
 choice
 	prompt "System type"
-	default SGI_IP22
-
-config MIPS_MTX1
-	bool "4G Systems MTX-1 board"
-	select DMA_NONCOHERENT
-	select HW_HAS_PCI
-	select RESOURCES_64BIT if PCI
-	select SOC_AU1500
-	select SYS_HAS_CPU_MIPS32_R1
-	select SYS_SUPPORTS_LITTLE_ENDIAN
-
-config MIPS_BOSPORUS
-	bool "AMD Alchemy Bosporus board"
-	select SOC_AU1500
-	select DMA_NONCOHERENT
-	select SYS_HAS_CPU_MIPS32_R1
-	select SYS_SUPPORTS_LITTLE_ENDIAN
-
-config MIPS_PB1000
-	bool "AMD Alchemy PB1000 board"
-	select SOC_AU1000
-	select DMA_NONCOHERENT
-	select HW_HAS_PCI
-	select RESOURCES_64BIT if PCI
-	select SWAP_IO_SPACE
-	select SYS_HAS_CPU_MIPS32_R1
-	select SYS_SUPPORTS_LITTLE_ENDIAN
 
-config MIPS_PB1100
-	bool "AMD Alchemy PB1100 board"
-	select SOC_AU1100
+config RALINK_RT2880
+        bool "Ralink RT2880 board"
 	select DMA_NONCOHERENT
+	select IRQ_CPU
 	select HW_HAS_PCI
-	select RESOURCES_64BIT if PCI
 	select SWAP_IO_SPACE
 	select SYS_HAS_CPU_MIPS32_R1
 	select SYS_SUPPORTS_LITTLE_ENDIAN
-
-config MIPS_PB1500
-	bool "AMD Alchemy PB1500 board"
-	select SOC_AU1500
-	select DMA_NONCOHERENT
-	select HW_HAS_PCI
-	select RESOURCES_64BIT if PCI
-	select SYS_HAS_CPU_MIPS32_R1
-	select SYS_SUPPORTS_LITTLE_ENDIAN
-
-config MIPS_PB1550
-	bool "AMD Alchemy PB1550 board"
-	select SOC_AU1550
-	select DMA_NONCOHERENT
-	select HW_HAS_PCI
-	select MIPS_DISABLE_OBSOLETE_IDE
-	select RESOURCES_64BIT if PCI
-	select SYS_HAS_CPU_MIPS32_R1
-	select SYS_SUPPORTS_LITTLE_ENDIAN
-
-config MIPS_PB1200
-	bool "AMD Alchemy PB1200 board"
-	select SOC_AU1200
-	select DMA_NONCOHERENT
-	select MIPS_DISABLE_OBSOLETE_IDE
-	select RESOURCES_64BIT if PCI
-	select SYS_HAS_CPU_MIPS32_R1
-	select SYS_SUPPORTS_LITTLE_ENDIAN
-
-config MIPS_DB1000
-	bool "AMD Alchemy DB1000 board"
-	select SOC_AU1000
-	select DMA_NONCOHERENT
-	select HW_HAS_PCI
-	select RESOURCES_64BIT if PCI
-	select SYS_HAS_CPU_MIPS32_R1
-	select SYS_SUPPORTS_LITTLE_ENDIAN
-
-config MIPS_DB1100
-	bool "AMD Alchemy DB1100 board"
-	select SOC_AU1100
-	select DMA_NONCOHERENT
-	select SYS_HAS_CPU_MIPS32_R1
-	select SYS_SUPPORTS_LITTLE_ENDIAN
-
-config MIPS_DB1500
-	bool "AMD Alchemy DB1500 board"
-	select SOC_AU1500
-	select DMA_NONCOHERENT
-	select HW_HAS_PCI
-	select MIPS_DISABLE_OBSOLETE_IDE
-	select RESOURCES_64BIT if PCI
-	select SYS_HAS_CPU_MIPS32_R1
-	select SYS_SUPPORTS_BIG_ENDIAN
-	select SYS_SUPPORTS_LITTLE_ENDIAN
-
-config MIPS_DB1550
-	bool "AMD Alchemy DB1550 board"
-	select SOC_AU1550
-	select HW_HAS_PCI
-	select DMA_NONCOHERENT
-	select MIPS_DISABLE_OBSOLETE_IDE
-	select RESOURCES_64BIT if PCI
-	select SYS_HAS_CPU_MIPS32_R1
-	select SYS_SUPPORTS_LITTLE_ENDIAN
-
-config MIPS_DB1200
-	bool "AMD Alchemy DB1200 board"
-	select SOC_AU1200
-	select DMA_COHERENT
-	select MIPS_DISABLE_OBSOLETE_IDE
-	select SYS_HAS_CPU_MIPS32_R1
-	select SYS_SUPPORTS_LITTLE_ENDIAN
-
-config MIPS_MIRAGE
-	bool "AMD Alchemy Mirage board"
-	select DMA_NONCOHERENT
-	select SOC_AU1500
-	select SYS_HAS_CPU_MIPS32_R1
-	select SYS_SUPPORTS_LITTLE_ENDIAN
-
-config BASLER_EXCITE
-	bool "Basler eXcite smart camera"
-	select DMA_COHERENT
-	select HW_HAS_PCI
-	select IRQ_CPU
-	select IRQ_CPU_RM7K
-	select IRQ_CPU_RM9K
-	select MIPS_RM9122
-	select SYS_HAS_CPU_RM9000
-	select SYS_SUPPORTS_32BIT_KERNEL
-	select SYS_SUPPORTS_64BIT_KERNEL
-	select SYS_SUPPORTS_BIG_ENDIAN
-	select SYS_SUPPORTS_KGDB
-	help
-	  The eXcite is a smart camera platform manufactured by
-	  Basler Vision Technologies AG.
-
-config BASLER_EXCITE_PROTOTYPE
-	bool "Support for pre-release units"
-	depends on BASLER_EXCITE
-	default n
-	help
-	  Pre-series (prototype) units are different from later ones in
-	  some ways. Select this option if you have one of these. Please
-	  note that a kernel built with this option selected will not be
-	  able to run on normal units.
-
-config MIPS_COBALT
-	bool "Cobalt Server"
-	select DMA_NONCOHERENT
-	select HW_HAS_PCI
-	select I8259
-	select IRQ_CPU
-	select MIPS_GT64111
-	select SYS_HAS_CPU_NEVADA
-	select SYS_HAS_EARLY_PRINTK
-	select SYS_SUPPORTS_32BIT_KERNEL
-	select SYS_SUPPORTS_64BIT_KERNEL if EXPERIMENTAL
-	select SYS_SUPPORTS_LITTLE_ENDIAN
-	select GENERIC_HARDIRQS_NO__DO_IRQ
-
-config MACH_DECSTATION
-	bool "DECstations"
 	select BOOT_ELF32
-	select DMA_NONCOHERENT
-	select SYS_HAS_EARLY_PRINTK
-	select IRQ_CPU
-	select SYS_HAS_CPU_R3000
-	select SYS_HAS_CPU_R4X00
 	select SYS_SUPPORTS_32BIT_KERNEL
-	select SYS_SUPPORTS_64BIT_KERNEL if EXPERIMENTAL
-	select SYS_SUPPORTS_LITTLE_ENDIAN
-	select SYS_SUPPORTS_128HZ
-	select SYS_SUPPORTS_256HZ
-	select SYS_SUPPORTS_1024HZ
-	help
-	  This enables support for DEC's MIPS based workstations.  For details
-	  see the Linux/MIPS FAQ on <http://www.linux-mips.org/> and the
-	  DECstation porting pages on <http://decstation.unix-ag.org/>.
+	select RALINK_RT2880_MP
+        help
+         Ralink evaluation board based on RT2880
 
-	  If you have one of the following DECstation Models you definitely
-	  want to choose R4xx0 for the CPU Type:
-
-	  	DECstation 5000/50
-	  	DECstation 5000/150
-	  	DECstation 5000/260
-	  	DECsystem 5900/260
-
-	  otherwise choose R3000.
-
-config MIPS_EV64120
-	bool "Galileo EV64120 Evaluation board (EXPERIMENTAL)"
-	depends on EXPERIMENTAL
-	select DMA_NONCOHERENT
-	select HW_HAS_PCI
-	select MIPS_GT64120
-	select SYS_HAS_CPU_R5000
-	select SYS_SUPPORTS_32BIT_KERNEL
-	select SYS_SUPPORTS_64BIT_KERNEL
-	select SYS_SUPPORTS_BIG_ENDIAN
-	select SYS_SUPPORTS_KGDB
-	help
-	  This is an evaluation board based on the Galileo GT-64120
-	  single-chip system controller that contains a MIPS R5000 compatible
-	  core running at 75/100MHz.  Their website is located at
-	  <http://www.marvell.com/>.  Say Y here if you wish to build a
-	  kernel for this platform.
-
-config MACH_JAZZ
-	bool "Jazz family of machines"
-	select ARC
-	select ARC32
-	select ARCH_MAY_HAVE_PC_FDC
-	select GENERIC_ISA_DMA
-	select I8253
-	select I8259
-	select ISA
-	select SYS_HAS_CPU_R4X00
-	select SYS_SUPPORTS_32BIT_KERNEL
-	select SYS_SUPPORTS_64BIT_KERNEL if EXPERIMENTAL
-	select SYS_SUPPORTS_100HZ
-	select GENERIC_HARDIRQS_NO__DO_IRQ
-	help
-	 This a family of machines based on the MIPS R4030 chipset which was
-	 used by several vendors to build RISC/os and Windows NT workstations.
-	 Members include the Acer PICA, MIPS Magnum 4000, MIPS Millenium and
-	 Olivetti M700-10 workstations.
-
-config LASAT
-	bool "LASAT Networks platforms"
+ config RALINK_RT3052
+        bool "Ralink RT305x/RT3350 board"
 	select DMA_NONCOHERENT
-	select SYS_HAS_EARLY_PRINTK
-	select HW_HAS_PCI
-	select MIPS_GT64120
-	select MIPS_NILE4
-	select R5000_CPU_SCACHE
-	select SYS_HAS_CPU_R5000
-	select SYS_SUPPORTS_32BIT_KERNEL
-	select SYS_SUPPORTS_64BIT_KERNEL if BROKEN
-	select SYS_SUPPORTS_LITTLE_ENDIAN
-	select GENERIC_HARDIRQS_NO__DO_IRQ
-
-config MIPS_ATLAS
-	bool "MIPS Atlas board"
-	select BOOT_ELF32
-	select DMA_NONCOHERENT
-	select SYS_HAS_EARLY_PRINTK
 	select IRQ_CPU
-	select HW_HAS_PCI
-	select MIPS_BOARDS_GEN
-	select MIPS_BONITO64
-	select MIPS_GT64120
-	select MIPS_MSC
-	select RM7000_CPU_SCACHE
 	select SWAP_IO_SPACE
 	select SYS_HAS_CPU_MIPS32_R1
-	select SYS_HAS_CPU_MIPS32_R2
-	select SYS_HAS_CPU_MIPS64_R1
-	select SYS_HAS_CPU_NEVADA
-	select SYS_HAS_CPU_RM7000
-	select SYS_SUPPORTS_32BIT_KERNEL
-	select SYS_SUPPORTS_64BIT_KERNEL
-	select SYS_SUPPORTS_BIG_ENDIAN
+        select SYS_HAS_CPU_MIPS32_R2
 	select SYS_SUPPORTS_LITTLE_ENDIAN
-	select SYS_SUPPORTS_MULTITHREADING if EXPERIMENTAL
-	select SYS_SUPPORTS_SMARTMIPS
-	select GENERIC_HARDIRQS_NO__DO_IRQ
-	help
-	  This enables support for the MIPS Technologies Atlas evaluation
-	  board.
-
-config MIPS_MALTA
-	bool "MIPS Malta board"
-	select ARCH_MAY_HAVE_PC_FDC
 	select BOOT_ELF32
-	select HAVE_STD_PC_SERIAL_PORT
-	select DMA_NONCOHERENT
-	select GENERIC_ISA_DMA
-	select IRQ_CPU
-	select HW_HAS_PCI
-	select I8259
-	select MIPS_BOARDS_GEN
-	select MIPS_BONITO64
-	select MIPS_CPU_SCACHE
-	select MIPS_GT64120
-	select MIPS_MSC
-	select SWAP_IO_SPACE
-	select SYS_HAS_CPU_MIPS32_R1
-	select SYS_HAS_CPU_MIPS32_R2
-	select SYS_HAS_CPU_MIPS64_R1
-	select SYS_HAS_CPU_NEVADA
-	select SYS_HAS_CPU_RM7000
-	select SYS_HAS_EARLY_PRINTK
 	select SYS_SUPPORTS_32BIT_KERNEL
-	select SYS_SUPPORTS_64BIT_KERNEL
-	select SYS_SUPPORTS_BIG_ENDIAN
-	select SYS_SUPPORTS_LITTLE_ENDIAN
-	select SYS_SUPPORTS_MULTITHREADING
-	select SYS_SUPPORTS_SMARTMIPS
-	help
-	  This enables support for the MIPS Technologies Malta evaluation
-	  board.
+	select RALINK_RT3052_MP2 if !RALINK_RT3350
+        help
+         Ralink evaluation board based on RT3052
 
-config MIPS_SEAD
-	bool "MIPS SEAD board (EXPERIMENTAL)"
-	depends on EXPERIMENTAL
-	select IRQ_CPU
+ config RALINK_RT3352
+        bool "Ralink RT3352 board"
 	select DMA_NONCOHERENT
-	select SYS_HAS_EARLY_PRINTK
-	select MIPS_BOARDS_GEN
-	select SYS_HAS_CPU_MIPS32_R1
-	select SYS_HAS_CPU_MIPS32_R2
-	select SYS_HAS_CPU_MIPS64_R1
-	select SYS_SUPPORTS_32BIT_KERNEL
-	select SYS_SUPPORTS_64BIT_KERNEL if EXPERIMENTAL
-	select SYS_SUPPORTS_BIG_ENDIAN
-	select SYS_SUPPORTS_LITTLE_ENDIAN
-	select SYS_SUPPORTS_SMARTMIPS
-	help
-	  This enables support for the MIPS Technologies SEAD evaluation
-	  board.
-
-config WR_PPMC
-	bool "Wind River PPMC board"
 	select IRQ_CPU
-	select BOOT_ELF32
-	select DMA_NONCOHERENT
-	select HW_HAS_PCI
-	select MIPS_GT64120
 	select SWAP_IO_SPACE
 	select SYS_HAS_CPU_MIPS32_R1
-	select SYS_HAS_CPU_MIPS32_R2
-	select SYS_HAS_CPU_MIPS64_R1
-	select SYS_HAS_CPU_NEVADA
-	select SYS_HAS_CPU_RM7000
-	select SYS_SUPPORTS_32BIT_KERNEL
-	select SYS_SUPPORTS_64BIT_KERNEL
-	select SYS_SUPPORTS_BIG_ENDIAN
-	select SYS_SUPPORTS_LITTLE_ENDIAN
-	help
-	  This enables support for the Wind River MIPS32 4KC PPMC evaluation
-	  board, which is based on GT64120 bridge chip.
-
-config MIPS_SIM
-	bool 'MIPS simulator (MIPSsim)'
-	select DMA_NONCOHERENT
-	select SYS_HAS_EARLY_PRINTK
-	select IRQ_CPU
-	select SYS_HAS_CPU_MIPS32_R1
-	select SYS_HAS_CPU_MIPS32_R2
-	select SYS_HAS_EARLY_PRINTK
-	select SYS_SUPPORTS_32BIT_KERNEL
-	select SYS_SUPPORTS_BIG_ENDIAN
+        select SYS_HAS_CPU_MIPS32_R2
 	select SYS_SUPPORTS_LITTLE_ENDIAN
-	help
-	  This option enables support for MIPS Technologies MIPSsim software
-	  emulator.
-
-config MOMENCO_JAGUAR_ATX
-	bool "Momentum Jaguar board"
 	select BOOT_ELF32
-	select DMA_NONCOHERENT
-	select HW_HAS_PCI
-	select IRQ_CPU
-	select IRQ_CPU_RM7K
-	select IRQ_MV64340
-	select LIMITED_DMA
-	select PCI_MARVELL
-	select RM7000_CPU_SCACHE
-	select SWAP_IO_SPACE
-	select SYS_HAS_CPU_RM9000
-	select SYS_HAS_EARLY_PRINTK
 	select SYS_SUPPORTS_32BIT_KERNEL
-	select SYS_SUPPORTS_64BIT_KERNEL
-	select SYS_SUPPORTS_BIG_ENDIAN
-	select SYS_SUPPORTS_KGDB
-	help
-	  The Jaguar ATX is a MIPS-based Single Board Computer (SBC) made by
-	  Momentum Computer <http://www.momenco.com/>.
+	select RALINK_RT3352_MP
+        help
+         Ralink evaluation board based on RT3352
 
-config MOMENCO_OCELOT
-	bool "Momentum Ocelot board"
+config RALINK_RT5350
+	bool "Ralink RT5350 board"
 	select DMA_NONCOHERENT
-	select HW_HAS_PCI
 	select IRQ_CPU
-	select IRQ_CPU_RM7K
-	select MIPS_GT64120
-	select RM7000_CPU_SCACHE
-	select SWAP_IO_SPACE
-	select SYS_HAS_CPU_RM7000
-	select SYS_SUPPORTS_32BIT_KERNEL
-	select SYS_SUPPORTS_64BIT_KERNEL
-	select SYS_SUPPORTS_BIG_ENDIAN
-	select SYS_SUPPORTS_KGDB
-	help
-	  The Ocelot is a MIPS-based Single Board Computer (SBC) made by
-	  Momentum Computer <http://www.momenco.com/>.
-
-config MOMENCO_OCELOT_3
-	bool "Momentum Ocelot-3 board"
-	select BOOT_ELF32
-	select DMA_NONCOHERENT
-	select HW_HAS_PCI
-	select IRQ_CPU
-	select IRQ_CPU_RM7K
-	select IRQ_MV64340
-	select PCI_MARVELL
-	select RM7000_CPU_SCACHE
-	select SWAP_IO_SPACE
-	select SYS_HAS_CPU_RM9000
-	select SYS_SUPPORTS_32BIT_KERNEL
-	select SYS_SUPPORTS_64BIT_KERNEL
-	select SYS_SUPPORTS_BIG_ENDIAN
-	help
-	  The Ocelot-3 is based off Discovery III System Controller and
-	  PMC-Sierra Rm79000 core.
-
-config MOMENCO_OCELOT_C
-	bool "Momentum Ocelot-C board"
-	select DMA_NONCOHERENT
-	select HW_HAS_PCI
-	select IRQ_CPU
-	select IRQ_MV64340
-	select PCI_MARVELL
-	select RM7000_CPU_SCACHE
-	select SWAP_IO_SPACE
-	select SYS_HAS_CPU_RM7000
-	select SYS_SUPPORTS_32BIT_KERNEL
-	select SYS_SUPPORTS_64BIT_KERNEL
-	select SYS_SUPPORTS_BIG_ENDIAN
-	select GENERIC_HARDIRQS_NO__DO_IRQ
-	help
-	  The Ocelot is a MIPS-based Single Board Computer (SBC) made by
-	  Momentum Computer <http://www.momenco.com/>.
-
-config MOMENCO_OCELOT_G
-	bool "Momentum Ocelot-G board"
-	select DMA_NONCOHERENT
-	select HW_HAS_PCI
-	select IRQ_CPU
-	select IRQ_CPU_RM7K
-	select PCI_MARVELL
-	select RM7000_CPU_SCACHE
-	select SWAP_IO_SPACE
-	select SYS_HAS_CPU_RM7000
-	select SYS_SUPPORTS_32BIT_KERNEL
-	select SYS_SUPPORTS_64BIT_KERNEL if BROKEN
-	select SYS_SUPPORTS_BIG_ENDIAN
-	help
-	  The Ocelot is a MIPS-based Single Board Computer (SBC) made by
-	  Momentum Computer <http://www.momenco.com/>.
-
-config MIPS_XXS1500
-	bool "MyCable XXS1500 board"
-	select DMA_NONCOHERENT
-	select SOC_AU1500
-	select SYS_SUPPORTS_LITTLE_ENDIAN
-
-config PNX8550_JBS
-	bool "Philips PNX8550 based JBS board"
-	select PNX8550
-	select SYS_SUPPORTS_LITTLE_ENDIAN
-
-config PNX8550_STB810
-	bool "Support for Philips PNX8550 based STB810 board"
-	select PNX8550
-	select SYS_SUPPORTS_LITTLE_ENDIAN
-
-config DDB5477
-	bool "NEC DDB Vrc-5477"
-	select DDB5XXX_COMMON
-	select DMA_NONCOHERENT
-	select HW_HAS_PCI
-	select I8259
-	select IRQ_CPU
-	select SYS_HAS_CPU_R5432
-	select SYS_SUPPORTS_32BIT_KERNEL
-	select SYS_SUPPORTS_64BIT_KERNEL if EXPERIMENTAL
-	select SYS_SUPPORTS_KGDB
-	select SYS_SUPPORTS_KGDB
-	select SYS_SUPPORTS_LITTLE_ENDIAN
-	help
-	  This enables support for the R5432-based NEC DDB Vrc-5477,
-	  or Rockhopper/SolutionGear boards with R5432/R5500 CPUs.
-
-	  Features : kernel debugging, serial terminal, NFS root fs, on-board
-	  ether port USB, AC97, PCI, etc.
-
-config MACH_VR41XX
-	bool "NEC VR41XX-based machines"
-	select SYS_HAS_CPU_VR41XX
-	select SYS_SUPPORTS_32BIT_KERNEL
-	select SYS_SUPPORTS_64BIT_KERNEL if EXPERIMENTAL
-	select GENERIC_HARDIRQS_NO__DO_IRQ
-
-config PMC_YOSEMITE
-	bool "PMC-Sierra Yosemite eval board"
-	select DMA_COHERENT
-	select HW_HAS_PCI
-	select IRQ_CPU
-	select IRQ_CPU_RM7K
-	select IRQ_CPU_RM9K
-	select SWAP_IO_SPACE
-	select SYS_HAS_CPU_RM9000
-	select SYS_HAS_EARLY_PRINTK
-	select SYS_SUPPORTS_32BIT_KERNEL
-	select SYS_SUPPORTS_64BIT_KERNEL
-	select SYS_SUPPORTS_BIG_ENDIAN
-	select SYS_SUPPORTS_HIGHMEM
-	select SYS_SUPPORTS_KGDB
-	select SYS_SUPPORTS_SMP
-	help
-	  Yosemite is an evaluation board for the RM9000x2 processor
-	  manufactured by PMC-Sierra.
-
-config QEMU
-	bool "Qemu"
-	select DMA_COHERENT
-	select GENERIC_ISA_DMA
-	select HAVE_STD_PC_SERIAL_PORT
-	select I8253
-	select I8259
-	select ISA
 	select SWAP_IO_SPACE
 	select SYS_HAS_CPU_MIPS32_R1
-	select SYS_SUPPORTS_32BIT_KERNEL
-	select SYS_SUPPORTS_BIG_ENDIAN
-	select SYS_SUPPORTS_LITTLE_ENDIAN
-	select ARCH_SPARSEMEM_ENABLE
-	select GENERIC_HARDIRQS_NO__DO_IRQ
-	select NR_CPUS_DEFAULT_1
-	select SYS_SUPPORTS_SMP
-	help
-	  Qemu is a software emulator which among other architectures also
-	  can simulate a MIPS32 4Kc system.  This patch adds support for the
-	  system architecture that currently is being simulated by Qemu.  It
-	  will eventually be removed again when Qemu has the capability to
-	  simulate actual MIPS hardware platforms.  More information on Qemu
-	  can be found at http://www.linux-mips.org/wiki/Qemu.
-
-config MARKEINS
-	bool "Support for NEC EMMA2RH Mark-eins"
-	select DMA_NONCOHERENT
-	select HW_HAS_PCI
-	select IRQ_CPU
-	select SWAP_IO_SPACE
-	select SYS_SUPPORTS_32BIT_KERNEL
-	select SYS_SUPPORTS_BIG_ENDIAN
+	select SYS_HAS_CPU_MIPS32_R2
 	select SYS_SUPPORTS_LITTLE_ENDIAN
-	select SYS_HAS_CPU_R5000
-	help
-	  This enables support for the R5432-based NEC Mark-eins
-	  boards with R5500 CPU.
-
-config SGI_IP22
-	bool "SGI IP22 (Indy/Indigo2)"
-	select ARC
-	select ARC32
 	select BOOT_ELF32
-	select DMA_NONCOHERENT
-	select HW_HAS_EISA
-	select IP22_CPU_SCACHE
-	select IRQ_CPU
-	select GENERIC_ISA_DMA_SUPPORT_BROKEN
-	select SWAP_IO_SPACE
-	select SYS_HAS_CPU_R4X00
-	select SYS_HAS_CPU_R5000
-	select SYS_HAS_EARLY_PRINTK
 	select SYS_SUPPORTS_32BIT_KERNEL
-	select SYS_SUPPORTS_64BIT_KERNEL
-	select SYS_SUPPORTS_BIG_ENDIAN
+	select RALINK_RT5350_MP
 	help
-	  This are the SGI Indy, Challenge S and Indigo2, as well as certain
-	  OEM variants like the Tandem CMN B006S. To compile a Linux kernel
-	  that runs on these, say Y here.
-
-config SGI_IP27
-	bool "SGI IP27 (Origin200/2000)"
-	select ARC
-	select ARC64
-	select BOOT_ELF64
-	select DMA_IP27
-	select SYS_HAS_EARLY_PRINTK
-	select HW_HAS_PCI
-	select NR_CPUS_DEFAULT_64
-	select PCI_DOMAINS
-	select SYS_HAS_CPU_R10000
-	select SYS_SUPPORTS_64BIT_KERNEL
-	select SYS_SUPPORTS_BIG_ENDIAN
-	select SYS_SUPPORTS_KGDB
-	select SYS_SUPPORTS_NUMA
-	select SYS_SUPPORTS_SMP
-	select GENERIC_HARDIRQS_NO__DO_IRQ
-	help
-	  This are the SGI Origin 200, Origin 2000 and Onyx 2 Graphics
-	  workstations.  To compile a Linux kernel that runs on these, say Y
-	  here.
-
-config SGI_IP32
-	bool "SGI IP32 (O2) (EXPERIMENTAL)"
-	depends on EXPERIMENTAL
-	select ARC
-	select ARC32
-	select BOOT_ELF32
-	select DMA_NONCOHERENT
-	select HW_HAS_PCI
-	select R5000_CPU_SCACHE
-	select RM7000_CPU_SCACHE
-	select SYS_HAS_CPU_R5000
-	select SYS_HAS_CPU_R10000 if BROKEN
-	select SYS_HAS_CPU_RM7000
-	select SYS_HAS_CPU_NEVADA
-	select SYS_SUPPORTS_64BIT_KERNEL
-	select SYS_SUPPORTS_BIG_ENDIAN
-	help
-	  If you want this kernel to run on SGI O2 workstation, say Y here.
-
-config SIBYTE_BIGSUR
-	bool "Sibyte BCM91480B-BigSur"
-	select BOOT_ELF32
-	select DMA_COHERENT
-	select NR_CPUS_DEFAULT_4
-	select PCI_DOMAINS
-	select SIBYTE_BCM1x80
-	select SWAP_IO_SPACE
-	select SYS_HAS_CPU_SB1
-	select SYS_SUPPORTS_BIG_ENDIAN
-	select SYS_SUPPORTS_LITTLE_ENDIAN
-
-config SIBYTE_SWARM
-	bool "Sibyte BCM91250A-SWARM"
-	select BOOT_ELF32
-	select DMA_COHERENT
-	select NR_CPUS_DEFAULT_2
-	select SIBYTE_SB1250
-	select SWAP_IO_SPACE
-	select SYS_HAS_CPU_SB1
-	select SYS_SUPPORTS_BIG_ENDIAN
-	select SYS_SUPPORTS_HIGHMEM
-	select SYS_SUPPORTS_KGDB
-	select SYS_SUPPORTS_LITTLE_ENDIAN
-
-config SIBYTE_SENTOSA
-	bool "Sibyte BCM91250E-Sentosa"
-	depends on EXPERIMENTAL
-	select BOOT_ELF32
-	select DMA_COHERENT
-	select NR_CPUS_DEFAULT_2
-	select SIBYTE_SB1250
-	select SWAP_IO_SPACE
-	select SYS_HAS_CPU_SB1
-	select SYS_SUPPORTS_BIG_ENDIAN
-	select SYS_SUPPORTS_LITTLE_ENDIAN
+	 Ralink evaluation board based on RT5350
 
-config SIBYTE_RHONE
-	bool "Sibyte BCM91125E-Rhone"
-	depends on EXPERIMENTAL
-	select BOOT_ELF32
-	select DMA_COHERENT
-	select SIBYTE_BCM1125H
-	select SWAP_IO_SPACE
-	select SYS_HAS_CPU_SB1
-	select SYS_SUPPORTS_BIG_ENDIAN
-	select SYS_SUPPORTS_LITTLE_ENDIAN
-
-config SIBYTE_CARMEL
-	bool "Sibyte BCM91120x-Carmel"
-	depends on EXPERIMENTAL
-	select BOOT_ELF32
-	select DMA_COHERENT
-	select SIBYTE_BCM1120
-	select SWAP_IO_SPACE
-	select SYS_HAS_CPU_SB1
-	select SYS_SUPPORTS_BIG_ENDIAN
-	select SYS_SUPPORTS_LITTLE_ENDIAN
-
-config SIBYTE_PTSWARM
-	bool "Sibyte BCM91250PT-PTSWARM"
-	depends on EXPERIMENTAL
-	select BOOT_ELF32
-	select DMA_COHERENT
-	select NR_CPUS_DEFAULT_2
-	select SIBYTE_SB1250
-	select SWAP_IO_SPACE
-	select SYS_HAS_CPU_SB1
-	select SYS_SUPPORTS_BIG_ENDIAN
-	select SYS_SUPPORTS_HIGHMEM
-	select SYS_SUPPORTS_LITTLE_ENDIAN
-
-config SIBYTE_LITTLESUR
-	bool "Sibyte BCM91250C2-LittleSur"
-	depends on EXPERIMENTAL
-	select BOOT_ELF32
-	select DMA_COHERENT
-	select NR_CPUS_DEFAULT_2
-	select SIBYTE_SB1250
-	select SWAP_IO_SPACE
-	select SYS_HAS_CPU_SB1
-	select SYS_SUPPORTS_BIG_ENDIAN
-	select SYS_SUPPORTS_HIGHMEM
-	select SYS_SUPPORTS_LITTLE_ENDIAN
-
-config SIBYTE_CRHINE
-	bool "Sibyte BCM91120C-CRhine"
-	depends on EXPERIMENTAL
-	select BOOT_ELF32
-	select DMA_COHERENT
-	select SIBYTE_BCM1120
-	select SWAP_IO_SPACE
-	select SYS_HAS_CPU_SB1
-	select SYS_SUPPORTS_BIG_ENDIAN
-	select SYS_SUPPORTS_LITTLE_ENDIAN
-
-config SIBYTE_CRHONE
-	bool "Sibyte BCM91125C-CRhone"
-	depends on EXPERIMENTAL
-	select BOOT_ELF32
-	select DMA_COHERENT
-	select SIBYTE_BCM1125
-	select SWAP_IO_SPACE
-	select SYS_HAS_CPU_SB1
-	select SYS_SUPPORTS_BIG_ENDIAN
-	select SYS_SUPPORTS_HIGHMEM
-	select SYS_SUPPORTS_LITTLE_ENDIAN
-
-config SNI_RM
-	bool "SNI RM200/300/400"
-	select ARC if CPU_LITTLE_ENDIAN
-	select ARC32 if CPU_LITTLE_ENDIAN
-	select ARCH_MAY_HAVE_PC_FDC
-	select BOOT_ELF32
+config RALINK_RT3883
+        bool "Ralink RT3883 board"
 	select DMA_NONCOHERENT
-	select GENERIC_ISA_DMA
-	select HW_HAS_EISA
-	select HW_HAS_PCI
 	select IRQ_CPU
-	select I8253
-	select I8259
-	select ISA
-	select SWAP_IO_SPACE if CPU_BIG_ENDIAN
-	select SYS_HAS_CPU_R4X00
-	select SYS_HAS_CPU_R5000
-	select SYS_HAS_CPU_R10000
-	select R5000_CPU_SCACHE
-	select SYS_HAS_EARLY_PRINTK
-	select SYS_SUPPORTS_32BIT_KERNEL
-	select SYS_SUPPORTS_64BIT_KERNEL if EXPERIMENTAL
-	select SYS_SUPPORTS_BIG_ENDIAN
-	select SYS_SUPPORTS_HIGHMEM
-	select SYS_SUPPORTS_LITTLE_ENDIAN
-	help
-	  The SNI RM200/300/400 are MIPS-based machines manufactured by
-	  Siemens Nixdorf Informationssysteme (SNI), parent company of Pyramid
-	  Technology and now in turn merged with Fujitsu.  Say Y here to
-	  support this machine type.
-
-config TOSHIBA_JMR3927
-	bool "Toshiba JMR-TX3927 board"
-	select DMA_NONCOHERENT
 	select HW_HAS_PCI
-	select MIPS_TX3927
 	select SWAP_IO_SPACE
-	select SYS_HAS_CPU_TX39XX
-	select SYS_SUPPORTS_32BIT_KERNEL
+	select SYS_HAS_CPU_MIPS32_R1
+        select SYS_HAS_CPU_MIPS32_R2
 	select SYS_SUPPORTS_LITTLE_ENDIAN
-	select SYS_SUPPORTS_BIG_ENDIAN
-	select TOSHIBA_BOARDS
-
-config TOSHIBA_RBTX4927
-	bool "Toshiba TBTX49[23]7 board"
-	select DMA_NONCOHERENT
-	select HAS_TXX9_SERIAL
-	select HW_HAS_PCI
-	select I8259
-	select ISA
-	select SWAP_IO_SPACE
-	select SYS_HAS_CPU_TX49XX
+	select BOOT_ELF32
 	select SYS_SUPPORTS_32BIT_KERNEL
-	select SYS_SUPPORTS_64BIT_KERNEL
-	select SYS_SUPPORTS_LITTLE_ENDIAN
-	select SYS_SUPPORTS_BIG_ENDIAN
-	select SYS_SUPPORTS_KGDB
-	select TOSHIBA_BOARDS
-	select GENERIC_HARDIRQS_NO__DO_IRQ
-	help
-	  This Toshiba board is based on the TX4927 processor. Say Y here to
-	  support this machine type
+	select RALINK_RT3883_MP
+        help
+         Ralink evaluation board based on RT3883
+endchoice
 
-config TOSHIBA_RBTX4938
-	bool "Toshiba RBTX4938 board"
-	select HAVE_STD_PC_SERIAL_PORT
-	select DMA_NONCOHERENT
-	select GENERIC_ISA_DMA
-	select HAS_TXX9_SERIAL
-	select HW_HAS_PCI
-	select I8259
-	select ISA
-	select SWAP_IO_SPACE
-	select SYS_HAS_CPU_TX49XX
-	select SYS_SUPPORTS_32BIT_KERNEL
-	select SYS_SUPPORTS_LITTLE_ENDIAN
-	select SYS_SUPPORTS_BIG_ENDIAN
-	select SYS_SUPPORTS_KGDB
-	select TOSHIBA_BOARDS
-	select GENERIC_HARDIRQS_NO__DO_IRQ
-	help
-	  This Toshiba board is based on the TX4938 processor. Say Y here to
-	  support this machine type
+source "arch/mips/rt2880/Kconfig"
 
-endchoice
 
-source "arch/mips/ddb5xxx/Kconfig"
-source "arch/mips/gt64120/ev64120/Kconfig"
-source "arch/mips/jazz/Kconfig"
-source "arch/mips/lasat/Kconfig"
-source "arch/mips/momentum/Kconfig"
-source "arch/mips/pmc-sierra/Kconfig"
-source "arch/mips/sgi-ip27/Kconfig"
-source "arch/mips/sibyte/Kconfig"
-source "arch/mips/tx4927/Kconfig"
-source "arch/mips/tx4938/Kconfig"
-source "arch/mips/vr41xx/Kconfig"
-source "arch/mips/philips/pnx8550/common/Kconfig"
+config SERIAL_CONSOLE 
+	bool
 
 endmenu
 
@@ -2010,6 +1280,7 @@ config PCI_DOMAINS
 	depends on PCI
 
 source "drivers/pci/Kconfig"
+source "drivers/pci/pcie/Kconfig" 
 
 #
 # ISA support is now enabled via select.  Too many systems still have the one
@@ -2157,3 +1428,5 @@ source "security/Kconfig"
 source "crypto/Kconfig"
 
 source "lib/Kconfig"
+
+source "ralink/Kconfig"
diff --git a/arch/mips/Kconfig.debug b/arch/mips/Kconfig.debug
index 72d5c19..5f61cff 100644
--- a/arch/mips/Kconfig.debug
+++ b/arch/mips/Kconfig.debug
@@ -28,6 +28,12 @@ config CMDLINE
 	  other cases you can specify kernel args so that you don't have
 	  to set them up in board prom initialization routines.
 
+config UBOOT_CMDLINE
+	bool "UBoot kernel command line"
+	default ""
+	help
+	  Say Y here if you want to use UBoot parameter "bootargs" as kernel command line.
+
 config DEBUG_STACK_USAGE
 	bool "Enable stack utilization instrumentation"
 	depends on DEBUG_KERNEL
diff --git a/arch/mips/Makefile b/arch/mips/Makefile
index 92bca6a..994cc6f 100644
--- a/arch/mips/Makefile
+++ b/arch/mips/Makefile
@@ -158,6 +158,48 @@ libs-$(CONFIG_SIBYTE_CFE)	+= arch/mips/sibyte/cfe/
 #
 
 #
+# Ralink RT2880 board
+#
+core-$(CONFIG_RALINK_RT2880)	+= arch/mips/rt2880/
+cflags-$(CONFIG_RALINK_RT2880)	+= -Iinclude/asm-mips/rt2880
+load-$(CONFIG_RALINK_RT2880)	+= 0x88000000
+
+#
+# Ralink RT2883 board
+#
+core-$(CONFIG_RALINK_RT2883)	+= arch/mips/rt2880/
+cflags-$(CONFIG_RALINK_RT2883)	+= -Iinclude/asm-mips/rt2880
+load-$(CONFIG_RALINK_RT2883)	+= 0x80000000
+
+#
+# Ralink RT3052 board
+#
+core-$(CONFIG_RALINK_RT3052)	+= arch/mips/rt2880/
+cflags-$(CONFIG_RALINK_RT3052)	+= -Iinclude/asm-mips/rt2880
+load-$(CONFIG_RALINK_RT3052)	+= 0x80000000
+
+#
+# Ralink RT3352 board
+#
+core-$(CONFIG_RALINK_RT3352)	+= arch/mips/rt2880/
+cflags-$(CONFIG_RALINK_RT3352)	+= -Iinclude/asm-mips/rt2880
+load-$(CONFIG_RALINK_RT3352)	+= 0x80000000
+
+#
+# Ralink RT5350 board
+#
+core-$(CONFIG_RALINK_RT5350)	+= arch/mips/rt2880/
+cflags-$(CONFIG_RALINK_RT5350)	+= -Iinclude/asm-mips/rt2880
+load-$(CONFIG_RALINK_RT5350)	+= 0x80000000
+
+#
+# Ralink RT3883 board
+#
+core-$(CONFIG_RALINK_RT3883)	+= arch/mips/rt2880/
+cflags-$(CONFIG_RALINK_RT3883)	+= -Iinclude/asm-mips/rt2880
+load-$(CONFIG_RALINK_RT3883)	+= 0x80000000
+
+#
 # Acer PICA 61, Mips Magnum 4000 and Olivetti M700.
 #
 core-$(CONFIG_MACH_JAZZ)	+= arch/mips/jazz/
@@ -669,6 +711,18 @@ endif
 vmlinux.32: vmlinux
 	$(OBJCOPY) -O $(32bit-bfd) $(OBJCOPYFLAGS) $< $@
 
+ifdef CONFIG_RALINK_RT2880
+#error zImage rImage
+zImage rImage: vmlinux $(TOPDIR)/.config
+	$(Q)$(MAKE) $(build)=arch/mips/rt2880/boot $@
+endif
+
+ifdef CONFIG_RALINK_RT3052
+#error zImage rImage
+zImage rImage: vmlinux $(TOPDIR)/.config
+	$(Q)$(MAKE) $(build)=arch/mips/rt2880/boot $@
+endif
+
 #
 # The 64-bit ELF tools are pretty broken so at this time we generate 64-bit
 # ELF files from 32-bit files by conversion.
diff --git a/arch/mips/kernel/genex.S b/arch/mips/kernel/genex.S
index 297bd56..96ff8ce 100644
--- a/arch/mips/kernel/genex.S
+++ b/arch/mips/kernel/genex.S
@@ -21,6 +21,16 @@
 #include <asm/war.h>
 #include <asm/page.h>
 
+#ifndef CONFIG_PANIC
+#define PANIC_PIC(msg)					\
+		.set push;				\
+		.set	reorder;			\
+		PTR_LA	a0,8f;				\
+9:		b	9b;				\
+		.set	pop;				\
+		TEXT(msg)
+#else /* CONFIG_PANIC=y */
+#ifdef CONFIG_FULL_PANIC
 #define PANIC_PIC(msg)					\
 		.set push;				\
 		.set	reorder;			\
@@ -31,6 +41,19 @@
 9:		b	9b;				\
 		.set	pop;				\
 		TEXT(msg)
+#else /* CONFIG_FULL_PANIC=n */
+#define PANIC_PIC(msg)					\
+		.set push;				\
+		.set	reorder;			\
+		PTR_LA	a0,8f;				\
+		.set	noat;				\
+		PTR_LA	AT, tiny_panic;			\
+		jr	AT;				\
+9:		b	9b;				\
+		.set	pop;				\
+		TEXT(msg)
+#endif /* CONFIG_FULL_PANIC=n */
+#endif /* CONFIG_PANIC=y */
 
 	__INIT
 
diff --git a/arch/mips/kernel/irixelf.c b/arch/mips/kernel/irixelf.c
index 3cc25c0..9aa84ce 100644
--- a/arch/mips/kernel/irixelf.c
+++ b/arch/mips/kernel/irixelf.c
@@ -43,12 +43,19 @@
 #include <linux/elf.h>
 
 static int load_irix_binary(struct linux_binprm * bprm, struct pt_regs * regs);
+#ifdef CONFIG_BINFMT_ELF_AOUT
 static int load_irix_library(struct file *);
+#endif
 static int irix_core_dump(long signr, struct pt_regs * regs,
                           struct file *file);
 
 static struct linux_binfmt irix_format = {
-	NULL, THIS_MODULE, load_irix_binary, load_irix_library,
+	NULL, THIS_MODULE, load_irix_binary,
+#ifdef CONFIG_BINFMT_ELF_AOUT
+	load_irix_library,
+#else
+	NULL,
+#endif
 	irix_core_dump, PAGE_SIZE
 };
 
@@ -820,6 +827,7 @@ out_free_ph:
 	goto out;
 }
 
+#ifdef CONFIG_BINFMT_ELF_AOUT
 /* This is really simpleminded and specialized - we are loading an
  * a.out library that is given an ELF header.
  */
@@ -898,6 +906,7 @@ static int load_irix_library(struct file *file)
 	kfree(elf_phdata);
 	return 0;
 }
+#endif
 
 /* Called through irix_syssgi() to map an elf image given an FD,
  * a phdr ptr USER_PHDRP in userspace, and a count CNT telling how many
diff --git a/arch/mips/kernel/kspd.c b/arch/mips/kernel/kspd.c
index 29eadd4..c658001 100644
--- a/arch/mips/kernel/kspd.c
+++ b/arch/mips/kernel/kspd.c
@@ -17,6 +17,7 @@
  */
 #include <linux/kernel.h>
 #include <linux/module.h>
+#include <linux/sched.h>
 #include <linux/unistd.h>
 #include <linux/file.h>
 #include <linux/fs.h>
@@ -198,7 +199,6 @@ void sp_work_handle_request(void)
 	int cmd;
 
 	char *vcwd;
-	mm_segment_t old_fs;
 	int size;
 
 	ret.retval = -1;
@@ -241,8 +241,6 @@ void sp_work_handle_request(void)
  		if ((ret.retval = sp_syscall(__NR_gettimeofday, (int)&tv,
  		                             (int)&tz, 0,0)) == 0)
 		ret.retval = tv.tv_sec;
-
-		ret.errno = errno;
 		break;
 
  	case MTSP_SYSCALL_EXIT:
@@ -279,7 +277,6 @@ void sp_work_handle_request(void)
 		if (cmd >= 0) {
 			ret.retval = sp_syscall(cmd, generic.arg0, generic.arg1,
 			                        generic.arg2, generic.arg3);
-			ret.errno = errno;
 		} else
  			printk(KERN_WARNING
 			       "KSPD: Unknown SP syscall number %d\n", sc.cmd);
diff --git a/arch/mips/kernel/ptrace.c b/arch/mips/kernel/ptrace.c
index 201ae19..478355a 100644
--- a/arch/mips/kernel/ptrace.c
+++ b/arch/mips/kernel/ptrace.c
@@ -20,12 +20,12 @@
 #include <linux/mm.h>
 #include <linux/errno.h>
 #include <linux/ptrace.h>
-#include <linux/audit.h>
 #include <linux/smp.h>
 #include <linux/smp_lock.h>
 #include <linux/user.h>
 #include <linux/security.h>
-#include <linux/signal.h>
+#include <linux/audit.h>
+#include <linux/seccomp.h>
 
 #include <asm/byteorder.h>
 #include <asm/cpu.h>
@@ -483,12 +483,16 @@ static inline int audit_arch(void)
  */
 asmlinkage void do_syscall_trace(struct pt_regs *regs, int entryexit)
 {
+	/* do the secure computing check first */
+	secure_computing(regs->orig_eax);
+
 	if (unlikely(current->audit_context) && entryexit)
 		audit_syscall_exit(AUDITSC_RESULT(regs->regs[2]),
 		                   regs->regs[2]);
 
 	if (!(current->ptrace & PT_PTRACED))
 		goto out;
+
 	if (!test_thread_flag(TIF_SYSCALL_TRACE))
 		goto out;
 
@@ -506,9 +510,14 @@ asmlinkage void do_syscall_trace(struct pt_regs *regs, int entryexit)
 		send_sig(current->exit_code, current, 1);
 		current->exit_code = 0;
 	}
- out:
+
+out:
+	/* There is no ->orig_eax and that's quite intensional for now making
+	   this work will require some work in various other place before it's
+	   more than a placebo.  */
+
 	if (unlikely(current->audit_context) && !entryexit)
-		audit_syscall_entry(audit_arch(), regs->regs[2],
-				    regs->regs[4], regs->regs[5],
-				    regs->regs[6], regs->regs[7]);
+		audit_syscall_entry(audit_arch(), regs->orig_eax,
+		                    regs->regs[4], regs->regs[5],
+		                    regs->regs[6], regs->regs[7]);
 }
diff --git a/arch/mips/kernel/rtlx.c b/arch/mips/kernel/rtlx.c
index e6e3047..bfc8ca1 100644
--- a/arch/mips/kernel/rtlx.c
+++ b/arch/mips/kernel/rtlx.c
@@ -289,7 +289,7 @@ unsigned int rtlx_write_poll(int index)
 	return write_spacefree(chan->rt_read, chan->rt_write, chan->buffer_size);
 }
 
-ssize_t rtlx_read(int index, void __user *buff, size_t count, int user)
+ssize_t rtlx_read(int index, void __user *buff, size_t count)
 {
 	size_t lx_write, fl = 0L;
 	struct rtlx_channel *lx;
@@ -331,9 +331,10 @@ out:
 	return count;
 }
 
-ssize_t rtlx_write(int index, const void __user *buffer, size_t count, int user)
+ssize_t rtlx_write(int index, const void __user *buffer, size_t count)
 {
 	struct rtlx_channel *rt;
+	unsigned long failed;
 	size_t rt_read;
 	size_t fl;
 
@@ -363,7 +364,7 @@ ssize_t rtlx_write(int index, const void __user *buffer, size_t count, int user)
 	}
 
 out:
-	count -= cailed;
+	count -= failed;
 
 	smp_wmb();
 	rt->rt_write = (rt->rt_write + count) % rt->buffer_size;
diff --git a/arch/mips/kernel/time.c b/arch/mips/kernel/time.c
index e5e56bd..f1e0f91 100644
--- a/arch/mips/kernel/time.c
+++ b/arch/mips/kernel/time.c
@@ -33,6 +33,11 @@
 #include <asm/sections.h>
 #include <asm/time.h>
 
+#ifdef CONFIG_RALINK_EXTERNAL_TIMER
+#include <asm/rt2880/rt_mmap.h>
+#define RALINK_16BIT_COUNT_CMP
+#endif
+
 /*
  * The integer part of the number of usecs per jiffy is taken from tick,
  * but the fractional part is not recorded, so we calculate it using the
@@ -71,7 +76,11 @@ int (*rtc_mips_set_mmss)(unsigned long);
 static unsigned long cycles_per_jiffy __read_mostly;
 
 /* expirelo is the count value for next CPU timer interrupt */
+#ifdef RALINK_16BIT_COUNT_CMP
+static unsigned short expirelo;
+#else
 static unsigned int expirelo;
+#endif
 
 
 /*
@@ -92,8 +101,13 @@ static cycle_t null_hpt_read(void)
  */
 static void c0_timer_ack(void)
 {
+#ifdef RALINK_16BIT_COUNT_CMP
+	unsigned short count;
+#else
 	unsigned int count;
+#endif
 
+#ifndef CONFIG_RALINK_EXTERNAL_TIMER
 	/* Ack this timer interrupt and set the next one.  */
 	expirelo += cycles_per_jiffy;
 	write_c0_compare(expirelo);
@@ -104,6 +118,30 @@ static void c0_timer_ack(void)
 		expirelo = count + cycles_per_jiffy;
 		write_c0_compare(expirelo);
 	}
+#else
+	expirelo += cycles_per_jiffy;
+#ifdef RALINK_16BIT_COUNT_CMP
+	(*((volatile u32 *)(RALINK_COMPARE))) &= 0xffff0000;
+	(*((volatile u32 *)(RALINK_COMPARE))) |= expirelo;
+#else
+	(*((volatile u32 *)(RALINK_COMPARE))) = expirelo;
+#endif
+
+#ifdef RALINK_16BIT_COUNT_CMP
+	while ((((count = (*((volatile u32 *)(RALINK_COUNT)))) - expirelo) & 0xffff) < 0x7fff) {
+#else
+	while (((count = (*((volatile u32 *)(RALINK_COUNT)))) - expirelo) < 0x7fffffff) {
+#endif
+		/* missed_timer_count++; */
+		expirelo = count + cycles_per_jiffy;
+#ifdef RALINK_16BIT_COUNT_CMP
+		(*((volatile u32 *)(RALINK_COMPARE))) &= 0xfff;
+		(*((volatile u32 *)(RALINK_COMPARE))) |= expirelo;
+#else
+		(*((volatile u32 *)(RALINK_COMPARE))) = expirelo;
+#endif
+	}
+#endif
 }
 
 /*
@@ -111,14 +149,33 @@ static void c0_timer_ack(void)
  */
 static cycle_t c0_hpt_read(void)
 {
+#ifndef CONFIG_RALINK_EXTERNAL_TIMER
 	return read_c0_count();
+#else
+#ifdef RALINK_16BIT_COUNT_CMP
+	return ((*((volatile u32 *)(RALINK_COUNT))) & 0xffff);
+#else
+	return (*((volatile u32 *)(RALINK_COUNT)));
+#endif
+#endif
 }
 
 /* For use both as a high precision timer and an interrupt source.  */
 static void __init c0_hpt_timer_init(void)
 {
+#ifndef CONFIG_RALINK_EXTERNAL_TIMER
 	expirelo = read_c0_count() + cycles_per_jiffy;
 	write_c0_compare(expirelo);
+#else
+#ifdef RALINK_16BIT_COUNT_CMP
+	expirelo = ((*((volatile u32 *)(RALINK_COUNT))) & 0xffff) + cycles_per_jiffy;
+	(*((volatile u32 *)(RALINK_COMPARE))) &= 0xffff0000;
+	(*((volatile u32 *)(RALINK_COMPARE))) |= expirelo;
+#else
+	expirelo = (*((volatile u32 *)(RALINK_COUNT))) + cycles_per_jiffy;
+	(*((volatile u32 *)(RALINK_COMPARE))) = expirelo;
+#endif
+#endif
 }
 
 int (*mips_timer_state)(void);
@@ -306,7 +363,11 @@ static unsigned int __init calibrate_hpt(void)
 
 struct clocksource clocksource_mips = {
 	.name		= "MIPS",
+#ifdef RALINK_16BIT_COUNT_CMP
+	.mask		= 0xffff,
+#else
 	.mask		= 0xffffffff,
+#endif
 	.flags		= CLOCK_SOURCE_IS_CONTINUOUS,
 };
 
diff --git a/arch/mips/lib/iomap.c b/arch/mips/lib/iomap.c
index d51d5cb..0deff28 100644
--- a/arch/mips/lib/iomap.c
+++ b/arch/mips/lib/iomap.c
@@ -24,7 +24,7 @@
  * implementation and should do their own copy.
  */
 
-#define PIO_MASK	0x0ffffUL
+#define PIO_MASK	0xffffffffUL
 
 unsigned int ioread8(void __iomem *addr)
 {
diff --git a/arch/mips/mm/cache.c b/arch/mips/mm/cache.c
index 4e8f1b6..70ccc5d 100644
--- a/arch/mips/mm/cache.c
+++ b/arch/mips/mm/cache.c
@@ -96,7 +96,7 @@ void __flush_anon_page(struct page *page, unsigned long vmaddr)
 
 		kaddr = kmap_coherent(page, vmaddr);
 		flush_data_cache_page((unsigned long)kaddr);
-		kunmap_coherent(kaddr);
+		kunmap_coherent(page);
 	}
 }
 
diff --git a/arch/mips/pci/pci.c b/arch/mips/pci/pci.c
index de7cfc5..f901140 100644
--- a/arch/mips/pci/pci.c
+++ b/arch/mips/pci/pci.c
@@ -111,10 +111,15 @@ static u8 __init common_swizzle(struct pci_dev *dev, u8 *pinp)
 	return PCI_SLOT(dev->devfn);
 }
 
+int mips_system_has_legacy_ide;
+
+EXPORT_SYMBOL_GPL(mips_system_has_legacy_ide);
+
 static int __init pcibios_init(void)
 {
 	struct pci_controller *hose;
 	struct pci_bus *bus;
+	struct pci_dev *dev;
 	int next_busno;
 	int need_domain_info = 0;
 
@@ -158,6 +163,13 @@ out:
 		pci_assign_unassigned_resources();
 	pci_fixup_irqs(common_swizzle, pcibios_map_irq);
 
+	if ((dev = pci_get_class(PCI_CLASS_BRIDGE_EISA << 8, NULL)) != NULL ||
+	    (dev = pci_get_class(PCI_CLASS_BRIDGE_ISA << 8, NULL)) != NULL) {
+		pci_dev_put(dev);
+
+		mips_system_has_legacy_ide = 1;
+	}
+
 	return 0;
 }
 
diff --git a/arch/mips/qemu/Makefile b/arch/mips/qemu/Makefile
index 078cd30..493259c 100644
--- a/arch/mips/qemu/Makefile
+++ b/arch/mips/qemu/Makefile
@@ -4,4 +4,5 @@
 
 obj-y		= q-firmware.o q-irq.o q-mem.o q-setup.o q-reset.o
 
+obj-$(CONFIG_VT) += q-vga.o
 obj-$(CONFIG_SMP) += q-smp.o
diff --git a/arch/mips/qemu/q-setup.c b/arch/mips/qemu/q-setup.c
index 8413943..37c2f73 100644
--- a/arch/mips/qemu/q-setup.c
+++ b/arch/mips/qemu/q-setup.c
@@ -2,6 +2,7 @@
 #include <asm/io.h>
 #include <asm/time.h>
 
+extern void qvga_init(void);
 extern void qemu_reboot_setup(void);
 
 #define QEMU_PORT_BASE 0xb4000000
@@ -23,5 +24,9 @@ void __init plat_timer_setup(struct irqaction *irq)
 void __init plat_mem_setup(void)
 {
 	set_io_port_base(QEMU_PORT_BASE);
+#ifdef CONFIG_VT
+	qvga_init();
+#endif
+
 	qemu_reboot_setup();
 }
diff --git a/drivers/Kconfig b/drivers/Kconfig
index 050323f..cd28055 100644
--- a/drivers/Kconfig
+++ b/drivers/Kconfig
@@ -2,6 +2,9 @@
 
 menu "Device Drivers"
 
+#use MTD instead
+#source "drivers/flash/Kconfig"
+
 source "drivers/base/Kconfig"
 
 source "drivers/connector/Kconfig"
diff --git a/drivers/Makefile b/drivers/Makefile
index 3a718f5..1687839 100644
--- a/drivers/Makefile
+++ b/drivers/Makefile
@@ -5,6 +5,10 @@
 # Rewritten to use lists instead of if-statements.
 #
 
+#added by Steven Liu
+obj-$(CONFIG_RALINK_FLASH_API) += flash/
+#--
+
 obj-$(CONFIG_PCI)		+= pci/
 obj-$(CONFIG_PARISC)		+= parisc/
 obj-$(CONFIG_RAPIDIO)		+= rapidio/
diff --git a/drivers/block/Kconfig b/drivers/block/Kconfig
index 17ee97f..cd32888 100644
--- a/drivers/block/Kconfig
+++ b/drivers/block/Kconfig
@@ -361,6 +361,7 @@ config BLK_DEV_UB
 
 config BLK_DEV_RAM
 	tristate "RAM disk support"
+	depends on RT2880_ROOTFS_IN_RAM
 	---help---
 	  Saying Y here will allow you to use a portion of your RAM memory as
 	  a block device, so that you can make file systems on it, read and
diff --git a/drivers/char/Kconfig b/drivers/char/Kconfig
index d0c978f..c337750 100644
--- a/drivers/char/Kconfig
+++ b/drivers/char/Kconfig
@@ -4,6 +4,173 @@
 
 menu "Character devices"
 
+config RALINK_GPIO
+	bool "Ralink GPIO Support"
+	default y
+
+config RALINK_GPIO_LED
+	bool "Ralink GPIO LED Support"
+	depends on RALINK_GPIO
+	default y
+
+config RALINK_GDMA
+	tristate "Ralink GDMA Support"
+	default n
+choice
+        prompt "GDMA Channel Allocation Mode"
+	depends on RALINK_GDMA
+	default GDMA_EVERYBODY
+
+	config GDMA_PCM_ONLY
+	        bool "PCM/Others"
+		---help---
+		   RT305x/RT3350/RT2883=>Ch0-Ch7:PCM0/PCM1
+		   RT3352/RT5350/RT3883=>Ch0-Ch7:PCM0/PCM1, Ch8-Ch15:others
+
+	config GDMA_PCM_I2S_OTHERS
+	        bool "PCM/I2S/Others"
+		---help---
+		   RT305x/RT3350/RT2883=>4Ch:PCM0 / 2Ch:I2S / 2Ch:Others
+		   RT3352/RT5350/RT3883=>4Ch:PCM0 / 2Ch:I2S_Tx / 2Ch:I2S_Rx / 8Ch:Others
+
+	config GDMA_EVERYBODY
+	        bool "All for Everybody"
+
+	config GDMA_DEBUG
+	        bool "Debug Mode 0->1..7->0->1..7.."
+endchoice
+
+config RALINK_SPI
+	tristate "Ralink RT2880 SPI Support"
+	default n
+
+config RALINK_SPI0_POL_HI
+	depends on RALINK_SPI
+	bool "SPI0 CS(Chip Select) is high active"
+	default n
+
+config RALINK_SPI1_POL_HI
+	depends on RALINK_SPI
+	depends on RALINK_RT3352 || RALINK_RT5350
+	bool "SPI1 CS(Chip Select) is high active"
+	default n
+
+config RALINK_I2C
+	tristate "Ralink RT2880 I2C Support"
+	default n
+
+config RALINK_PCM
+	tristate "Ralink PCM Support"
+	default n
+
+config RALINK_PCM_SPICH
+	int "PCM use SPI CH"
+	depends on RALINK_PCM
+	range 0 1
+	default "0"
+	---help---
+	PCM use SPI channel number.
+config RALINK_PCMRST_GPIO
+        int "PCM SLIC Reset pin map to GPIO Number"
+        depends on RALINK_PCM
+        range 0 95
+        default "0"
+        ---help---
+        Apply a gpio pin for SLIC RST.
+
+config RALINK_PCMCHNUM
+	int "PCM Total Channel Number Supported"
+	depends on RALINK_PCM
+	range 1 2
+	default "1"
+	---help---
+	Input PCM total channel number that we want to support.
+
+
+config RALINK_PCMEXTCLK
+        bool "PCM Clock Dividor Source From external OSC"
+	depends on RALINK_PCM
+	depends on RALINK_RT3052
+	default n
+	---help---
+	Select PCM clock dividor source from SoC internal or external OSC.
+
+config RALINK_PCMDIV
+	int "PCM Clock Dividor Value"
+	depends on RALINK_PCM
+	depends on RALINK_RT3052
+	range 0 63
+	default "60"
+	---help---
+	Set PCM clock dividor value based on SoC internal clock (15.625Mhz) or external OSC (eg. 12.288Mhz).
+
+config RALINK_PCMINTDIV
+        int "PCM Clock Dividor Interger Part Value"
+        depends on RALINK_PCM
+        depends on RALINK_RT3352 || RALINK_RT5350 || RALINK_RT3883
+	range 0 1024
+	default "78"
+	---help---
+	Set PCM clock dividor interger part value based on SoC internal clock (40Mhz).
+
+
+config RALINK_PCMCOMPDIV
+        int "PCM Clock Dividor Fraction Part Value"
+	depends on RALINK_PCM
+	depends on RALINK_RT3352 || RALINK_RT5350 || RALINK_RT3883
+	range 0 512
+	default "16"
+	---help---
+	Set PCM clock dividor fraction part value based on SoC internal clock (40Mhz).
+
+config RALINK_PCMSLOTMODE
+	int "PCM slot mode"
+	depends on RALINK_PCM
+	range 0 5
+	default "0"
+	---help---
+	PCM slot mode : 0 for 4 slots, 1 for 8 slots, 2 for 16 slots, 3 for 32 slots, 4 for 64 slots, and 5 for 128 slots.
+
+choice
+	prompt "UARTF_SHARE_MODE Setting"
+	depends on RALINK_PCM
+	default RALINK_PCMGPIO
+
+	config RALINK_PCMGPIO
+		bool "PCM+GPIO mode"
+	config RALINK_PCMUARTF
+		bool "PCM+UARTF mode"
+	config RALINK_PCMI2S
+		bool "PCM+I2S mode"
+endchoice
+config RALINK_I2S
+	tristate "Ralink I2S Support"
+	select RALINK_I2C
+	select RALINK_GDMA
+	default n
+
+config I2S_IN_CLK
+        bool "Use Internal Reference Clock"
+	depends on RALINK_I2S
+	depends on RALINK_RT3052
+	default n
+config I2S_MS_MODE
+        bool "Ralink SoC as I2S Master Device"
+	depends on RALINK_I2S
+        depends on RALINK_RT3352 || RALINK_RT5350
+	default n
+choice
+        prompt "Audio Codec MCLK Setting"
+        depends on RALINK_I2S
+        default I2S_MCLK_12MHZ
+
+	config I2S_MCLK_12MHZ
+	        bool "MCLK is 12Mhz"
+
+	config I2S_MCLK_12P288MHZ
+	        bool "MCLK is 12.288Mhz"
+endchoice
+
 config VT
 	bool "Virtual terminal" if EMBEDDED
 	select INPUT
@@ -372,19 +539,17 @@ config ISTALLION
 	  To compile this driver as a module, choose M here: the
 	  module will be called istallion.
 
-config AU1000_UART
-	bool "Enable Au1000 UART Support"
-	depends on SERIAL_NONSTANDARD && MIPS
-	help
-	  If you have an Alchemy AU1000 processor (MIPS based) and you want
-	  to use serial ports, say Y.  Otherwise, say N.
+config AU1X00_GPIO
+	tristate "Alchemy Au1000 GPIO device support"
+	depends on MIPS && SOC_AU1X00
 
-config AU1000_SERIAL_CONSOLE
-	bool "Enable Au1000 serial console"
-	depends on AU1000_UART
-	help
-	  If you have an Alchemy AU1000 processor (MIPS based) and you want
-	  to use a console on a serial port, say Y.  Otherwise, say N.
+config SIBYTE_SB1250_DUART
+	bool "Support for BCM1xxx onchip DUART"
+	depends on MIPS && SIBYTE_SB1xxx_SOC=y
+
+config SIBYTE_SB1250_DUART_CONSOLE
+	bool "Console on BCM1xxx DUART"
+	depends on SIBYTE_SB1250_DUART
 
 config SERIAL_DEC
 	bool "DECstation serial support"
@@ -1072,4 +1237,3 @@ config TELCLOCK
 	  controlling the behavior of this hardware.
 
 endmenu
-
diff --git a/drivers/char/Makefile b/drivers/char/Makefile
index ae8567c..7730bb3 100644
--- a/drivers/char/Makefile
+++ b/drivers/char/Makefile
@@ -7,7 +7,16 @@
 #
 FONTMAPFILE = cp437.uni
 
-obj-y	 += mem.o random.o tty_io.o n_tty.o tty_ioctl.o
+ifeq ($(PLUGIN_BOARD),NEW)
+CFLAGS          += -DPLUGIN_BOARD_NEW
+endif
+
+obj-y	 += mem.o random.o tty_io.o n_tty.o tty_ioctl.o led_ioctrl.o
+
+obj-$(CONFIG_RALINK_GPIO)	+= ralink_gpio.o
+obj-$(CONFIG_RALINK_GDMA)	+= ralink_gdma.o
+obj-$(CONFIG_RALINK_SPI) 	+= spi_drv.o
+obj-$(CONFIG_RALINK_I2C) 	+= i2c_drv.o
 
 obj-$(CONFIG_LEGACY_PTYS)	+= pty.o
 obj-$(CONFIG_UNIX98_PTYS)	+= pty.o
@@ -32,6 +41,7 @@ obj-$(CONFIG_A2232)		+= ser_a2232.o generic_serial.o
 obj-$(CONFIG_ATARI_DSP56K)	+= dsp56k.o
 obj-$(CONFIG_MOXA_SMARTIO)	+= mxser.o
 obj-$(CONFIG_MOXA_SMARTIO_NEW)	+= mxser_new.o
+obj-$(CONFIG_SIBYTE_SB1250_DUART) += sb1250_duart.o
 obj-$(CONFIG_COMPUTONE)		+= ip2/
 obj-$(CONFIG_RISCOM8)		+= riscom8.o
 obj-$(CONFIG_ISI)		+= isicom.o
@@ -55,6 +65,7 @@ obj-$(CONFIG_VIOCONS)		+= viocons.o
 obj-$(CONFIG_VIOTAPE)		+= viotape.o
 obj-$(CONFIG_HVCS)		+= hvcs.o
 obj-$(CONFIG_SGI_MBCS)		+= mbcs.o
+obj-$(CONFIG_SERIAL_DEC)	+= decserial.o
 obj-$(CONFIG_BRIQ_PANEL)	+= briq_panel.o
 
 obj-$(CONFIG_PRINTER)		+= lp.o
@@ -83,6 +94,7 @@ obj-$(CONFIG_I8K)		+= i8k.o
 obj-$(CONFIG_DS1620)		+= ds1620.o
 obj-$(CONFIG_HW_RANDOM)		+= hw_random/
 obj-$(CONFIG_COBALT_LCD)	+= lcd.o
+obj-$(CONFIG_AU1000_GPIO)	+= au1000_gpio.o
 obj-$(CONFIG_PPDEV)		+= ppdev.o
 obj-$(CONFIG_NWBUTTON)		+= nwbutton.o
 obj-$(CONFIG_NWFLASH)		+= nwflash.o
@@ -104,6 +116,9 @@ obj-$(CONFIG_IPMI_HANDLER)	+= ipmi/
 obj-$(CONFIG_HANGCHECK_TIMER)	+= hangcheck-timer.o
 obj-$(CONFIG_TCG_TPM)		+= tpm/
 
+obj-$(CONFIG_RALINK_PCM)	+= pcm/
+obj-$(CONFIG_RALINK_I2S)	+= i2s/
+
 # Files generated that shall be removed upon make clean
 clean-files := consolemap_deftbl.c defkeymap.c
 
diff --git a/drivers/char/watchdog/Kconfig b/drivers/char/watchdog/Kconfig
index e812aa1..98c4772 100644
--- a/drivers/char/watchdog/Kconfig
+++ b/drivers/char/watchdog/Kconfig
@@ -586,6 +586,17 @@ config WDT_RM9K_GPI
 	  To compile this driver as a module, choose M here: the
 	  module will be called rm9k_wdt.
 
+config RALINK_WATCHDOG
+	tristate "Ralink APSoC Hardware Watchdog"
+	depends on WATCHDOG
+	help
+	  timer expired and no process has written to /dev/watchdog during
+	  that time.
+
+config  RALINK_TIMER_WDG_RESET_OUTPUT
+        bool "Ralink WatchDog Reset Output"
+        depends on RALINK_WATCHDOG
+
 # S390 Architecture
 
 config ZVM_WATCHDOG
diff --git a/drivers/char/watchdog/Makefile b/drivers/char/watchdog/Makefile
index 2cd8ff8..a20817c 100644
--- a/drivers/char/watchdog/Makefile
+++ b/drivers/char/watchdog/Makefile
@@ -74,6 +74,7 @@ obj-$(CONFIG_WATCHDOG_RTAS) += wdrtas.o
 # MIPS Architecture
 obj-$(CONFIG_INDYDOG) += indydog.o
 obj-$(CONFIG_WDT_RM9K_GPI) += rm9k_wdt.o
+obj-$(CONFIG_RALINK_WATCHDOG) += ralink_wdt.o
 
 # S390 Architecture
 
diff --git a/drivers/char/watchdog/softdog.c b/drivers/char/watchdog/softdog.c
index 9c36949..6ac3746 100644
--- a/drivers/char/watchdog/softdog.c
+++ b/drivers/char/watchdog/softdog.c
@@ -67,6 +67,9 @@ static int soft_noboot = 1;
 static int soft_noboot = 0;
 #endif  /* ONLY_TESTING */
 
+#include <linux/proc_fs.h>
+char softdog_action[12]="";
+
 module_param(soft_noboot, int, 0);
 MODULE_PARM_DESC(soft_noboot, "Softdog action, set to 1 to ignore reboots, 0 to reboot (default depends on ONLY_TESTING)");
 
@@ -88,16 +91,26 @@ static char expect_close;
 
 static void watchdog_fire(unsigned long data)
 {
-	if (test_and_clear_bit(0, &orphan_timer))
-		module_put(THIS_MODULE);
-
-	if (soft_noboot)
-		printk(KERN_CRIT PFX "Triggered - Reboot ignored.\n");
+	if( !strcmp(softdog_action, "") )
+	{
+		printk(KERN_EMERG "Softdog timeout, wait 5 seconds...\n");
+		mod_timer(&watchdog_ticktock, jiffies+(5*HZ)); // Extend 5 seconds
+		strcpy(softdog_action, "reboot");
+	}
 	else
 	{
-		printk(KERN_CRIT PFX "Initiating system reboot.\n");
-		emergency_restart();
-		printk(KERN_CRIT PFX "Reboot didn't ?????\n");
+
+		if (test_and_clear_bit(0, &orphan_timer))
+			module_put(THIS_MODULE);
+
+		if (soft_noboot)
+			printk(KERN_CRIT PFX "Triggered - Reboot ignored.\n");
+		else
+		{
+			printk(KERN_CRIT PFX "Initiating system reboot.\n");
+			emergency_restart();
+			printk(KERN_CRIT PFX "Reboot didn't ?????\n");
+		}
 	}
 }
 
@@ -107,6 +120,8 @@ static void watchdog_fire(unsigned long data)
 
 static int softdog_keepalive(void)
 {
+
+//printk(KERN_EMERG "softdog: softdog_keepalive soft_margin=[%d]\n", soft_margin);
 	mod_timer(&watchdog_ticktock, jiffies+(soft_margin*HZ));
 	return 0;
 }
@@ -214,6 +229,7 @@ static int softdog_ioctl(struct inode *inode, struct file *file,
 			softdog_keepalive();
 			return 0;
 		case WDIOC_SETTIMEOUT:
+//printk(KERN_EMERG "softdog: WDIOC_SETTIMEOUT\n");
 			if (get_user(new_margin, p))
 				return -EFAULT;
 			if (softdog_set_heartbeat(new_margin))
@@ -264,6 +280,17 @@ static struct notifier_block softdog_notifier = {
 
 static char banner[] __initdata = KERN_INFO "Software Watchdog Timer: 0.07 initialized. soft_noboot=%d soft_margin=%d sec (nowayout= %d)\n";
 
+
+
+static int softdog_read_proc(char *buf, char **start, off_t off, int count, int *eof, void *data)
+{
+        int len = 0;
+
+        len = sprintf(buf, softdog_action);
+
+        return len;
+}
+
 static int __init watchdog_init(void)
 {
 	int ret;
@@ -290,6 +317,8 @@ static int __init watchdog_init(void)
 		return ret;
 	}
 
+	create_proc_read_entry("softdog",0,NULL,softdog_read_proc,NULL);
+
 	printk(banner, soft_noboot, soft_margin, nowayout);
 
 	return 0;
@@ -299,6 +328,7 @@ static void __exit watchdog_exit(void)
 {
 	misc_deregister(&softdog_miscdev);
 	unregister_reboot_notifier(&softdog_notifier);
+	remove_proc_entry("softdog", NULL);
 }
 
 module_init(watchdog_init);
diff --git a/drivers/ide/mips/Makefile b/drivers/ide/mips/Makefile
index 677c7b2..93eee13 100644
--- a/drivers/ide/mips/Makefile
+++ b/drivers/ide/mips/Makefile
@@ -1,4 +1,4 @@
 obj-$(CONFIG_BLK_DEV_IDE_SWARM)		+= swarm.o
 obj-$(CONFIG_BLK_DEV_IDE_AU1XXX)	+= au1xxx-ide.o
 
-EXTRA_CFLAGS    := -Idrivers/ide
+CFLAGS_au1xxx-ide.o := -Idrivers/ide
diff --git a/drivers/media/video/Kconfig b/drivers/media/video/Kconfig
index 7a61051..8d478a4 100644
--- a/drivers/media/video/Kconfig
+++ b/drivers/media/video/Kconfig
@@ -7,6 +7,8 @@ menu "Video Capture Adapters"
 
 comment "Video Capture Adapters"
 
+source "drivers/media/video/uvc/Kconfig"
+
 config VIDEO_ADV_DEBUG
 	bool "Enable advanced debug functionality"
 	depends on VIDEO_DEV
diff --git a/drivers/media/video/Makefile b/drivers/media/video/Makefile
index 44ccaed..7e0ad13 100644
--- a/drivers/media/video/Makefile
+++ b/drivers/media/video/Makefile
@@ -111,5 +111,6 @@ obj-$(CONFIG_USB_VICAM)         += usbvideo/
 obj-$(CONFIG_USB_QUICKCAM_MESSENGER)	+= usbvideo/
 
 obj-$(CONFIG_VIDEO_VIVI) += vivi.o
+obj-$(CONFIG_USB_VIDEO_CLASS)       += uvc/
 
 EXTRA_CFLAGS += -Idrivers/media/dvb/dvb-core
diff --git a/drivers/mtd/Makefile b/drivers/mtd/Makefile
index c130e62..5b1355e 100644
--- a/drivers/mtd/Makefile
+++ b/drivers/mtd/Makefile
@@ -27,4 +27,4 @@ obj-$(CONFIG_SSFDC)		+= ssfdc.o
 nftl-objs		:= nftlcore.o nftlmount.o
 inftl-objs		:= inftlcore.o inftlmount.o
 
-obj-y		+= chips/ maps/ devices/ nand/ onenand/
+obj-y		+= chips/ maps/ devices/ nand/ onenand/ ralink/
diff --git a/drivers/mtd/chips/Kconfig b/drivers/mtd/chips/Kconfig
index 72e6d73..31731b4 100644
--- a/drivers/mtd/chips/Kconfig
+++ b/drivers/mtd/chips/Kconfig
@@ -208,6 +208,11 @@ config MTD_CFI_STAA
 	  sets which a CFI-compliant chip may claim to implement. This code
 	  provides support for one of those command sets.
 
+config MTD_CFI_SSTSTD
+	tristate "Support for SST flash chips"
+	depends on MTD_GEN_PROBE
+	select MTD_CFI_UTIL
+
 config MTD_CFI_UTIL
 	tristate
 
diff --git a/drivers/mtd/chips/Makefile b/drivers/mtd/chips/Makefile
index 75bc1c2..721152c 100644
--- a/drivers/mtd/chips/Makefile
+++ b/drivers/mtd/chips/Makefile
@@ -10,6 +10,7 @@ obj-$(CONFIG_MTD_CFI_UTIL)	+= cfi_util.o
 obj-$(CONFIG_MTD_CFI_STAA)	+= cfi_cmdset_0020.o
 obj-$(CONFIG_MTD_CFI_AMDSTD)	+= cfi_cmdset_0002.o
 obj-$(CONFIG_MTD_CFI_INTELEXT)	+= cfi_cmdset_0001.o
+obj-$(CONFIG_MTD_CFI_SSTSTD)    += cfi_cmdset_0701.o
 obj-$(CONFIG_MTD_GEN_PROBE)	+= gen_probe.o
 obj-$(CONFIG_MTD_JEDEC)		+= jedec.o
 obj-$(CONFIG_MTD_JEDECPROBE)	+= jedec_probe.o
diff --git a/drivers/mtd/chips/cfi_cmdset_0002.c b/drivers/mtd/chips/cfi_cmdset_0002.c
index 1f64458..b8be82d 100644
--- a/drivers/mtd/chips/cfi_cmdset_0002.c
+++ b/drivers/mtd/chips/cfi_cmdset_0002.c
@@ -13,6 +13,8 @@
  * XIP support hooks by Vitaly Wool (based on code for Intel flash
  * by Nicolas Pitre)
  *
+ * 25/09/2008 Christopher Moore: TopBottom fixup for many Macronix with CFI V1.0
+ *
  * Occasionally maintained by Thayne Harbaugh tharbaugh at lnxi dot com
  *
  * This code is GPL
@@ -46,6 +48,7 @@
 
 #define MANUFACTURER_AMD	0x0001
 #define MANUFACTURER_ATMEL	0x001F
+#define MANUFACTURER_MACRONIX	0x00C2
 #define MANUFACTURER_SST	0x00BF
 #define SST49LF004B	        0x0060
 #define SST49LF040B	        0x0050
@@ -147,12 +150,44 @@ static void fixup_amd_bootblock(struct mtd_info *mtd, void* param)
 
 	if (((major << 8) | minor) < 0x3131) {
 		/* CFI version 1.0 => don't trust bootloc */
+
+		DEBUG(MTD_DEBUG_LEVEL1,
+			"%s: JEDEC Vendor ID is 0x%02X Device ID is 0x%02X\n",
+			map->name, cfi->mfr, cfi->id);
+
+		/* AFAICS all 29LV400 with a bottom boot block have a device ID
+		 * of 0x22BA in 16-bit mode and 0xBA in 8-bit mode.
+		 * These were badly detected as they have the 0x80 bit set
+		 * so treat them as a special case.
+		 */
+		if (((cfi->id == 0xBA) || (cfi->id == 0x22BA)) &&
+
+			/* Macronix added CFI to their 2nd generation
+			 * MX29LV400C B/T but AFAICS no other 29LV400 (AMD,
+			 * Fujitsu, Spansion, EON, ESI and older Macronix)
+			 * has CFI.
+			 *
+			 * Therefore also check the manufacturer.
+			 * This reduces the risk of false detection due to
+			 * the 8-bit device ID.
+			 */
+			(cfi->mfr == MANUFACTURER_MACRONIX)) {
+			DEBUG(MTD_DEBUG_LEVEL1,
+				"%s: Macronix MX29LV400C with bottom boot block"
+				" detected\n", map->name);
+			extp->TopBottom = 2;	/* bottom boot */
+		} else
 		if (cfi->id & 0x80) {
 			printk(KERN_WARNING "%s: JEDEC Device ID is 0x%02X. Assuming broken CFI table.\n", map->name, cfi->id);
 			extp->TopBottom = 3;	/* top boot */
 		} else {
 			extp->TopBottom = 2;	/* bottom boot */
 		}
+
+		DEBUG(MTD_DEBUG_LEVEL1,
+			"%s: AMD CFI PRI V%c.%c has no boot block field;"
+			" deduced %s from Device ID\n", map->name, major, minor,
+			extp->TopBottom == 2 ? "bottom" : "top");
 	}
 }
 #endif
@@ -181,10 +216,22 @@ static void fixup_convert_atmel_pri(struct mtd_info *mtd, void *param)
 	if (atmel_pri.Features & 0x02)
 		extp->EraseSuspend = 2;
 
-	if (atmel_pri.BottomBoot)
-		extp->TopBottom = 2;
-	else
-		extp->TopBottom = 3;
+	/* Some chips got it backwards... */
+	if (cfi->id == AT49BV6416) {
+		if (atmel_pri.BottomBoot)
+			extp->TopBottom = 3;
+		else
+			extp->TopBottom = 2;
+	} else {
+		if (atmel_pri.BottomBoot)
+			extp->TopBottom = 2;
+		else
+			extp->TopBottom = 3;
+	}
+
+	/* burst write mode not supported */
+	cfi->cfiq->BufWriteTimeoutTyp = 0;
+	cfi->cfiq->BufWriteTimeoutMax = 0;
 }
 
 static void fixup_use_secsi(struct mtd_info *mtd, void *param)
@@ -216,9 +263,33 @@ static void fixup_use_atmel_lock(struct mtd_info *mtd, void *param)
 	mtd->flags |= MTD_STUPID_LOCK;
 }
 
+static void fixup_s29gl064n_sectors(struct mtd_info *mtd, void *param)
+{
+	struct map_info *map = mtd->priv;
+	struct cfi_private *cfi = map->fldrv_priv;
+
+	if ((cfi->cfiq->EraseRegionInfo[0] & 0xffff) == 0x003f) {
+		cfi->cfiq->EraseRegionInfo[0] |= 0x0040;
+		printk(KERN_WARNING "%s: Bad S29GL064N CFI data, adjust from 64 to 128 sectors\n", mtd->name);
+	}
+}
+
+static void fixup_s29gl032n_sectors(struct mtd_info *mtd, void *param)
+{
+	struct map_info *map = mtd->priv;
+	struct cfi_private *cfi = map->fldrv_priv;
+
+	if ((cfi->cfiq->EraseRegionInfo[1] & 0xffff) == 0x007e) {
+		cfi->cfiq->EraseRegionInfo[1] &= ~0x0040;
+		printk(KERN_WARNING "%s: Bad S29GL032N CFI data, adjust from 127 to 63 sectors\n", mtd->name);
+	}
+}
+
 static struct cfi_fixup cfi_fixup_table[] = {
+	{ CFI_MFR_ATMEL, CFI_ID_ANY, fixup_convert_atmel_pri, NULL },
 #ifdef AMD_BOOTLOC_BUG
 	{ CFI_MFR_AMD, CFI_ID_ANY, fixup_amd_bootblock, NULL },
+	{ MANUFACTURER_MACRONIX, CFI_ID_ANY, fixup_amd_bootblock, NULL },
 #endif
 	{ CFI_MFR_AMD, 0x0050, fixup_use_secsi, NULL, },
 	{ CFI_MFR_AMD, 0x0053, fixup_use_secsi, NULL, },
@@ -226,6 +297,10 @@ static struct cfi_fixup cfi_fixup_table[] = {
 	{ CFI_MFR_AMD, 0x0056, fixup_use_secsi, NULL, },
 	{ CFI_MFR_AMD, 0x005C, fixup_use_secsi, NULL, },
 	{ CFI_MFR_AMD, 0x005F, fixup_use_secsi, NULL, },
+	{ CFI_MFR_AMD, 0x0c01, fixup_s29gl064n_sectors, NULL, },
+	{ CFI_MFR_AMD, 0x1301, fixup_s29gl064n_sectors, NULL, },
+	{ CFI_MFR_AMD, 0x1a00, fixup_s29gl032n_sectors, NULL, },
+	{ CFI_MFR_AMD, 0x1a01, fixup_s29gl032n_sectors, NULL, },
 #if !FORCE_WORD_WRITE
 	{ CFI_MFR_ANY, CFI_ID_ANY, fixup_use_write_buffers, NULL, },
 #endif
@@ -251,6 +326,15 @@ static struct cfi_fixup fixup_table[] = {
 };
 
 
+static void cfi_fixup_major_minor(struct cfi_private *cfi, 
+				  struct cfi_pri_amdstd *extp)
+{
+   if (cfi->mfr == CFI_MFR_SAMSUNG && cfi->id == 0x257e &&
+	    extp->MajorVersion == '0')
+	extp->MajorVersion = '1';
+}
+
+
 struct mtd_info *cfi_cmdset_0002(struct map_info *map, int primary)
 {
 	struct cfi_private *cfi = map->fldrv_priv;
@@ -292,6 +376,8 @@ struct mtd_info *cfi_cmdset_0002(struct map_info *map, int primary)
 			return NULL;
 		}
 
+		cfi_fixup_major_minor(cfi, extp);
+
 		if (extp->MajorVersion != '1' ||
 		    (extp->MinorVersion < '0' || extp->MinorVersion > '4')) {
 			printk(KERN_ERR "  Unknown Amd/Fujitsu Extended Query "
@@ -373,6 +459,7 @@ static struct mtd_info *cfi_amdstd_setup(struct mtd_info *mtd)
 {
 	struct map_info *map = mtd->priv;
 	struct cfi_private *cfi = map->fldrv_priv;
+	struct flchip *chip;
 	unsigned long devsize = (1<<cfi->cfiq->DevSize) * cfi->interleave;
 	unsigned long offset = 0;
 	int i,j;
@@ -399,6 +486,14 @@ static struct mtd_info *cfi_amdstd_setup(struct mtd_info *mtd)
 			mtd->erasesize = ersize;
 		}
 		for (j=0; j<cfi->numchips; j++) {
+
+		       /*
+			*  we should write the reset command twice then device can return to read state
+			*  if enter CFI query in Autoselect mode.
+			*/
+			chip=&cfi->chips[j];
+			map_write( map, CMD(0xF0), chip->start);
+
 			mtd->eraseregions[(j*cfi->cfiq->NumEraseRegions)+i].offset = (j*devsize)+offset;
 			mtd->eraseregions[(j*cfi->cfiq->NumEraseRegions)+i].erasesize = ersize;
 			mtd->eraseregions[(j*cfi->cfiq->NumEraseRegions)+i].numblocks = ernum;
@@ -459,6 +554,22 @@ static int __xipram chip_ready(struct map_info *map, unsigned long addr)
 }
 
 /*
+ * Ralink Soc flash controller issue two CE and OE for single read action.
+ * In order to get correct status bit, we need to use rt_chip_ready instead.
+ * by Steven
+ */
+static int __xipram rt_chip_ready(struct map_info *map, unsigned long addr)
+{
+	map_word o, d, t;
+
+        o.x[0] = __raw_readl(map->virt + addr);
+	d.x[0]=o.x[0] & 0xFFFF; //get low 16bits
+	t.x[0]= (o.x[0] >> 16); //get high 16bits
+
+	return map_word_equal(map, d, t);
+}
+
+/*
  * Return true if the chip is ready and has the correct value.
  *
  * Ready is one of: read mode, query mode, erase-suspend-read mode (in any
@@ -1298,7 +1409,7 @@ static int __xipram do_write_buffer(struct map_info *map, struct flchip *chip,
 
 	INVALIDATE_CACHE_UDELAY(map, chip,
 				adr, map_bankwidth(map),
-				chip->word_write_time);
+				chip->buffer_write_time*5);
 
 	timeo = jiffies + uWriteTimeout;
 
@@ -1468,7 +1579,7 @@ static int __xipram do_erase_chip(struct map_info *map, struct flchip *chip)
 
 	INVALIDATE_CACHE_UDELAY(map, chip,
 				adr, map->size,
-				chip->erase_time*500);
+				chip->erase_time);
 
 	timeo = jiffies + (HZ*20);
 
@@ -1490,8 +1601,10 @@ static int __xipram do_erase_chip(struct map_info *map, struct flchip *chip)
 			chip->erase_suspended = 0;
 		}
 
-		if (chip_ready(map, adr))
-			break;
+		if (rt_chip_ready(map, adr)) {
+		    xip_enable(map, chip, adr);
+		    break;
+		}
 
 		if (time_after(jiffies, timeo)) {
 			printk(KERN_WARNING "MTD %s(): software timeout\n",
@@ -1556,7 +1669,7 @@ static int __xipram do_erase_oneblock(struct map_info *map, struct flchip *chip,
 
 	INVALIDATE_CACHE_UDELAY(map, chip,
 				adr, len,
-				chip->erase_time*500);
+				chip->erase_time);
 
 	timeo = jiffies + (HZ*20);
 
@@ -1578,9 +1691,9 @@ static int __xipram do_erase_oneblock(struct map_info *map, struct flchip *chip,
 			chip->erase_suspended = 0;
 		}
 
-		if (chip_ready(map, adr)) {
-			xip_enable(map, chip, adr);
-			break;
+		if (rt_chip_ready(map, adr)) {
+		    xip_enable(map, chip, adr);
+		    break;
 		}
 
 		if (time_after(jiffies, timeo)) {
@@ -1757,6 +1870,7 @@ static void cfi_amdstd_sync (struct mtd_info *mtd)
 
 		default:
 			/* Not an idle state */
+			set_current_state(TASK_UNINTERRUPTIBLE);
 			add_wait_queue(&chip->wq, &wait);
 
 			spin_unlock(chip->mutex);
diff --git a/drivers/mtd/chips/cfi_probe.c b/drivers/mtd/chips/cfi_probe.c
index 60e11a0..3bdc459 100644
--- a/drivers/mtd/chips/cfi_probe.c
+++ b/drivers/mtd/chips/cfi_probe.c
@@ -31,6 +31,9 @@ static int cfi_chip_setup(struct map_info *map, struct cfi_private *cfi);
 
 struct mtd_info *cfi_probe(struct map_info *map);
 
+int cfi_isSST(struct map_info *map,struct cfi_private *cfi, __u32 base);
+static int isSST;
+
 #ifdef CONFIG_MTD_XIP
 
 /* only needed for short periods, so this is rather simple */
@@ -67,6 +70,8 @@ do { \
 
 #endif
 
+
+
 /* check for QRY.
    in: interleave,type,mode
    ret: table index, <0 for error
@@ -119,7 +124,21 @@ static int __xipram cfi_probe_chip(struct map_info *map, __u32 base,
 	xip_disable();
 	cfi_send_gen_cmd(0xF0, 0, base, map, cfi, cfi->device_type, NULL);
 	cfi_send_gen_cmd(0xFF, 0, base, map, cfi, cfi->device_type, NULL);
-	cfi_send_gen_cmd(0x98, 0x55, base, map, cfi, cfi->device_type, NULL);
+
+
+	/* SST Flash on board ? */
+	isSST=cfi_isSST(map,cfi,base);
+
+	if(isSST)
+        {
+                cfi_send_gen_cmd(0xAA, 0x5555, base, map, cfi, cfi->device_type, NULL);
+                cfi_send_gen_cmd(0x55, 0x2AAA, base, map, cfi, cfi->device_type, NULL);
+                cfi_send_gen_cmd(0x98, 0x5555, base, map, cfi, cfi->device_type, NULL);
+        }
+	else
+	{
+		cfi_send_gen_cmd(0x98, 0x55, base, map, cfi, cfi->device_type, NULL);
+	}
 
 	if (!qry_present(map,base,cfi)) {
 		xip_enable(base, map, cfi);
@@ -247,6 +266,12 @@ static int __xipram cfi_chip_setup(struct map_info *map,
 	cfi->cfiq->InterfaceDesc = le16_to_cpu(cfi->cfiq->InterfaceDesc);
 	cfi->cfiq->MaxBufWriteSize = le16_to_cpu(cfi->cfiq->MaxBufWriteSize);
 
+	// for SST,the NumEraseRegion 2 explain to Block Information,
+        // NumEraseRegion 1 explain to sector
+        if(isSST){
+                cfi->cfiq->NumEraseRegions = 1;
+        }
+
 #ifdef DEBUG_CFI
 	/* Dump the information therein */
 	print_cfi_ident(cfi->cfiq);
@@ -436,7 +461,7 @@ static void __exit cfi_probe_exit(void)
 	unregister_mtd_chip_driver(&cfi_chipdrv);
 }
 
-module_init(cfi_probe_init);
+fs_initcall(cfi_probe_init);
 module_exit(cfi_probe_exit);
 
 MODULE_LICENSE("GPL");
diff --git a/drivers/mtd/chips/cfi_util.c b/drivers/mtd/chips/cfi_util.c
index 2e51496..790cb07 100644
--- a/drivers/mtd/chips/cfi_util.c
+++ b/drivers/mtd/chips/cfi_util.c
@@ -27,13 +27,33 @@
 #include <linux/mtd/cfi.h>
 #include <linux/mtd/compatmac.h>
 
+
+int cfi_isSST(struct map_info *map,struct cfi_private *cfi, __u32 base)
+{
+	int man_id;
+
+        cfi_send_gen_cmd(0xAA, 0x5555, base, map, cfi, cfi->device_type, NULL);
+        cfi_send_gen_cmd(0x55, 0x2AAA, base, map, cfi, cfi->device_type, NULL);
+        cfi_send_gen_cmd(0x90, 0x5555, base, map, cfi, cfi->device_type, NULL);
+        man_id = cfi_read_query(map, base);
+
+        /* SST manufacture id = 0xBF */
+        if(man_id==CFI_MFR_SST){
+                return 1;
+        }else{
+                return 0;
+        }
+
+}
+
+
 struct cfi_extquery *
 __xipram cfi_read_pri(struct map_info *map, __u16 adr, __u16 size, const char* name)
 {
 	struct cfi_private *cfi = map->fldrv_priv;
 	__u32 base = 0; // cfi->chips[0].start;
 	int ofs_factor = cfi->interleave * cfi->device_type;
-	int i;
+	int i, isSST;
 	struct cfi_extquery *extp = NULL;
 
 	printk(" %s Extended Query Table at 0x%4.4X\n", name, adr);
@@ -50,8 +70,18 @@ __xipram cfi_read_pri(struct map_info *map, __u16 adr, __u16 size, const char* n
 	local_irq_disable();
 #endif
 
-	/* Switch it into Query Mode */
-	cfi_send_gen_cmd(0x98, 0x55, base, map, cfi, cfi->device_type, NULL);
+	isSST=cfi_isSST(map,cfi,base);
+
+        if(isSST)
+        {
+                cfi_send_gen_cmd(0xAA, 0x5555, base, map, cfi, cfi->device_type, NULL);
+                cfi_send_gen_cmd(0x55, 0x2AAA, base, map, cfi, cfi->device_type, NULL);
+                cfi_send_gen_cmd(0x98, 0x5555, base, map, cfi, cfi->device_type, NULL);
+        }
+	else 
+	{
+		cfi_send_gen_cmd(0x98, 0x55, base, map, cfi, cfi->device_type, NULL);
+	}
 
 	/* Read in the Extended Query Table */
 	for (i=0; i<size; i++) {
@@ -100,11 +130,13 @@ int cfi_varsize_frob(struct mtd_info *mtd, varsize_frob_t frob,
 	int i, first;
 	struct mtd_erase_region_info *regions = mtd->eraseregions;
 
-	if (ofs > mtd->size)
+	if (ofs > mtd->size){
 		return -EINVAL;
+	}
 
-	if ((len + ofs) > mtd->size)
+	if ((len + ofs) > mtd->size){
 		return -EINVAL;
+	}
 
 	/* Check that both start and end of the requested erase are
 	 * aligned with the erasesize at the appropriate addresses.
@@ -128,8 +160,9 @@ int cfi_varsize_frob(struct mtd_info *mtd, varsize_frob_t frob,
 	   effect here.
 	*/
 
-	if (ofs & (regions[i].erasesize-1))
+	if (ofs & (regions[i].erasesize-1)){
 		return -EINVAL;
+	}
 
 	/* Remember the erase region we start on */
 	first = i;
@@ -146,8 +179,9 @@ int cfi_varsize_frob(struct mtd_info *mtd, varsize_frob_t frob,
 	*/
 	i--;
 
-	if ((ofs + len) & (regions[i].erasesize-1))
+	if ((ofs + len) & (regions[i].erasesize-1)){
 		return -EINVAL;
+	}
 
 	chipnum = ofs >> cfi->chipshift;
 	adr = ofs - (chipnum << cfi->chipshift);
@@ -159,8 +193,9 @@ int cfi_varsize_frob(struct mtd_info *mtd, varsize_frob_t frob,
 
 		ret = (*frob)(map, &cfi->chips[chipnum], adr, size, thunk);
 
-		if (ret)
+		if (ret){
 			return ret;
+		}
 
 		adr += size;
 		ofs += size;
diff --git a/drivers/mtd/chips/gen_probe.c b/drivers/mtd/chips/gen_probe.c
index 2eb696d..19b855f 100644
--- a/drivers/mtd/chips/gen_probe.c
+++ b/drivers/mtd/chips/gen_probe.c
@@ -199,6 +199,7 @@ typedef struct mtd_info *cfi_cmdset_fn_t(struct map_info *, int);
 extern cfi_cmdset_fn_t cfi_cmdset_0001;
 extern cfi_cmdset_fn_t cfi_cmdset_0002;
 extern cfi_cmdset_fn_t cfi_cmdset_0020;
+extern cfi_cmdset_fn_t cfi_cmdset_0701;
 
 static inline struct mtd_info *cfi_cmdset_unknown(struct map_info *map,
 						  int primary)
@@ -256,6 +257,10 @@ static struct mtd_info *check_cmd_set(struct map_info *map, int primary)
         case 0x0020:
 		return cfi_cmdset_0020(map, primary);
 #endif
+#ifdef CONFIG_MTD_CFI_SSTSTD
+	case 0x0701:
+		return cfi_cmdset_0701(map, primary);
+#endif
 	default:
 		return cfi_cmdset_unknown(map, primary);
 	}
diff --git a/drivers/mtd/devices/docprobe.c b/drivers/mtd/devices/docprobe.c
index 78872c3..216d2d3 100644
--- a/drivers/mtd/devices/docprobe.c
+++ b/drivers/mtd/devices/docprobe.c
@@ -83,10 +83,10 @@ static unsigned long __initdata doc_locations[] = {
 	0xe4000000,
 #elif defined(CONFIG_MOMENCO_OCELOT)
 	0x2f000000,
-        0xff000000,
+	0xff000000,
 #elif defined(CONFIG_MOMENCO_OCELOT_G) || defined (CONFIG_MOMENCO_OCELOT_C)
-        0xff000000,
-##else
+	0xff000000,
+#else
 #warning Unknown architecture for DiskOnChip. No default probe locations defined
 #endif
 	0xffffffff };
diff --git a/drivers/mtd/maps/Kconfig b/drivers/mtd/maps/Kconfig
index bbf0553..bd1bde9 100644
--- a/drivers/mtd/maps/Kconfig
+++ b/drivers/mtd/maps/Kconfig
@@ -4,6 +4,10 @@
 menu "Mapping drivers for chip access"
 	depends on MTD!=n
 
+config MTD_RALINK
+       bool "Ralink MTD support"
+       depends on MTD
+
 config MTD_COMPLEX_MAPPINGS
 	bool "Support non-linear mappings of flash chips"
 	depends on MTD
diff --git a/drivers/mtd/maps/Makefile b/drivers/mtd/maps/Makefile
index 071d0bf..027be19 100644
--- a/drivers/mtd/maps/Makefile
+++ b/drivers/mtd/maps/Makefile
@@ -72,3 +72,5 @@ obj-$(CONFIG_MTD_PLATRAM)	+= plat-ram.o
 obj-$(CONFIG_MTD_OMAP_NOR)	+= omap_nor.o
 obj-$(CONFIG_MTD_MTX1)		+= mtx-1_flash.o
 obj-$(CONFIG_MTD_TQM834x)	+= tqm834x.o
+obj-$(CONFIG_MTD_RALINK)        += ralink-flash.o
+
diff --git a/drivers/mtd/maps/lasat.c b/drivers/mtd/maps/lasat.c
index e343763..3e6ddb0 100644
--- a/drivers/mtd/maps/lasat.c
+++ b/drivers/mtd/maps/lasat.c
@@ -49,7 +49,7 @@ static int __init init_lasat(void)
 	ENABLE_VPP((&lasat_map));
 
 	lasat_map.phys = lasat_flash_partition_start(LASAT_MTD_BOOTLOADER);
-	lasat_map.virt = ioremap_nocache(
+	lasat_map.virt = (unsigned long)ioremap_nocache(
 		        lasat_map.phys, lasat_board_info.li_flash_size);
 	lasat_map.size = lasat_board_info.li_flash_size;
 
diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index 1592eac..96a18da 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -253,7 +253,7 @@ static ssize_t mtd_write(struct file *file, const char __user *buf, size_t count
 	int ret=0;
 	int len;
 
-	DEBUG(MTD_DEBUG_LEVEL0,"MTD_write\n");
+	//DEBUG(MTD_DEBUG_LEVEL0,"MTD_write\n");
 
 	if (*ppos == mtd->size)
 		return -ENOSPC;
@@ -284,6 +284,8 @@ static ssize_t mtd_write(struct file *file, const char __user *buf, size_t count
 			return -EFAULT;
 		}
 
+		DEBUG(MTD_DEBUG_LEVEL0, "MTD_write: \"%s\" at 0x%lx\n", mtd->name, *ppos);
+
 		switch (mfi->mode) {
 		case MTD_MODE_OTP_FACTORY:
 			ret = -EROFS;
diff --git a/drivers/net/Kconfig b/drivers/net/Kconfig
index a3d46ea..89ec624 100644
--- a/drivers/net/Kconfig
+++ b/drivers/net/Kconfig
@@ -96,6 +96,129 @@ config EQUALIZER
 	  To compile this driver as a module, choose M here: the module
 	  will be called eql.  If unsure, say N.
 
+config IMQ
+	tristate "IMQ (intermediate queueing device) support"
+	depends on NETDEVICES && NETFILTER
+	---help---
+	  The IMQ device(s) is used as placeholder for QoS queueing
+	  disciplines. Every packet entering/leaving the IP stack can be
+	  directed through the IMQ device where it's enqueued/dequeued to the
+	  attached qdisc. This allows you to treat network devices as classes
+	  and distribute bandwidth among them. Iptables is used to specify
+	  through which IMQ device, if any, packets travel.
+
+	  More information at: http://www.linuximq.net/
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called imq.  If unsure, say N.
+
+choice
+	prompt "IMQ behavior (PRE/POSTROUTING)"
+	depends on IMQ
+	default IMQ_BEHAVIOR_BA
+	help
+
+		This settings defines how IMQ behaves in respect to its
+		hooking in PREROUTING and POSTROUTING.
+
+		IMQ can work in any of the following ways:
+
+		    PREROUTING   |      POSTROUTING
+		-----------------|-------------------
+		#1  After NAT    |      After NAT
+		#2  After NAT    |      Before NAT
+		#3  Before NAT   |      After NAT
+		#4  Before NAT   |      Before NAT
+
+		The default behavior is to hook before NAT on PREROUTING
+		and after NAT on POSTROUTING (#3).
+
+		This settings are specially usefull when trying to use IMQ
+		to shape NATed clients.
+
+		More information can be found at: www.linuximq.net
+
+		If not sure leave the default settings alone.
+
+config IMQ_BEHAVIOR_AA
+	bool "IMQ AA"
+	help
+		This settings defines how IMQ behaves in respect to its
+		hooking in PREROUTING and POSTROUTING.
+
+		Choosing this option will make IMQ hook like this:
+
+		PREROUTING:   After NAT
+		POSTROUTING:  After NAT
+
+		More information can be found at: www.linuximq.net
+
+		If not sure leave the default settings alone.
+
+config IMQ_BEHAVIOR_AB
+	bool "IMQ AB"
+	help
+		This settings defines how IMQ behaves in respect to its
+		hooking in PREROUTING and POSTROUTING.
+
+		Choosing this option will make IMQ hook like this:
+
+		PREROUTING:   After NAT
+		POSTROUTING:  Before NAT
+
+		More information can be found at: www.linuximq.net
+
+		If not sure leave the default settings alone.
+
+config IMQ_BEHAVIOR_BA
+	bool "IMQ BA"
+	help
+		This settings defines how IMQ behaves in respect to its
+		hooking in PREROUTING and POSTROUTING.
+
+		Choosing this option will make IMQ hook like this:
+
+		PREROUTING:   Before NAT
+		POSTROUTING:  After NAT
+
+		More information can be found at: www.linuximq.net
+
+		If not sure leave the default settings alone.
+
+config IMQ_BEHAVIOR_BB
+	bool "IMQ BB"
+	help
+		This settings defines how IMQ behaves in respect to its
+		hooking in PREROUTING and POSTROUTING.
+
+		Choosing this option will make IMQ hook like this:
+
+		PREROUTING:   Before NAT
+		POSTROUTING:  Before NAT
+
+		More information can be found at: www.linuximq.net
+
+		If not sure leave the default settings alone.
+
+endchoice
+
+config IMQ_NUM_DEVS
+
+	int "Number of IMQ devices"
+	range 2 8
+	depends on IMQ
+	default "2"
+	help
+
+		This settings defines how many IMQ devices will be
+		created.
+
+		The default value is 2.
+
+		More information can be found at: www.linuximq.net
+
+		If not sure leave the default settings alone.
+
 config TUN
 	tristate "Universal TUN/TAP device driver support"
 	select CRC32
@@ -442,6 +565,14 @@ config MIPS_JAZZ_SONIC
 	  This is the driver for the onboard card of MIPS Magnum 4000,
 	  Acer PICA, Olivetti M700-10 and a few other identical OEM systems.
 
+config GALILEO_64240_ETH
+	tristate "Galileo GT64240 Ethernet support"
+	depends on NET_ETHERNET && MOMENCO_OCELOT_G
+	select MII
+	help
+	  This is the driver for the ethernet interfaces integrated into
+	  the Galileo (now Marvell) GT64240 chipset.
+
 config MIPS_AU1X00_ENET
 	bool "MIPS AU1000 Ethernet support"
 	depends on NET_ETHERNET && SOC_AU1X00
@@ -451,10 +582,6 @@ config MIPS_AU1X00_ENET
 	  If you have an Alchemy Semi AU1X00 based system
 	  say Y.  Otherwise, say N.
 
-config NET_SB1250_MAC
-	tristate "SB1250 Ethernet support"
-	depends on NET_ETHERNET && SIBYTE_SB1xxx_SOC
-
 config SGI_IOC3_ETH
 	bool "SGI IOC3 Ethernet"
 	depends on NET_ETHERNET && PCI && SGI_IP27
@@ -465,29 +592,9 @@ config SGI_IOC3_ETH
 	  the Ethernet-HOWTO, available from
 	  <http://www.tldp.org/docs.html#howto>.
 
-config SGI_IOC3_ETH_HW_RX_CSUM
-	bool "Receive hardware checksums"
-	depends on SGI_IOC3_ETH && INET
-	default y
-	help
-	  The SGI IOC3 network adapter supports TCP and UDP checksums in
-	  hardware to offload processing of these checksums from the CPU.  At
-	  the moment only acceleration of IPv4 is supported.  This option
-	  enables offloading for checksums on receive.  If unsure, say Y.
-
-config SGI_IOC3_ETH_HW_TX_CSUM
-	bool "Transmit hardware checksums"
-	depends on SGI_IOC3_ETH && INET
-	default y
-	help
-	  The SGI IOC3 network adapter supports TCP and UDP checksums in
-	  hardware to offload processing of these checksums from the CPU.  At
-	  the moment only acceleration of IPv4 is supported.  This option
-	  enables offloading for checksums on transmit.  If unsure, say Y.
-
 config MIPS_SIM_NET
 	tristate "MIPS simulator Network device (EXPERIMENTAL)"
-	depends on MIPS_SIM && EXPERIMENTAL
+	depends on NET_ETHERNET && MIPS_SIM && EXPERIMENTAL
 	help
 	  The MIPSNET device is a simple Ethernet network device which is
 	  emulated by the MIPS Simulator.
@@ -887,8 +994,8 @@ config SMC911X
 	  and read the Ethernet-HOWTO, available from
 	  <http://www.linuxdoc.org/docs.html#howto>.
 
-	  This driver is also available as a module. The module will be 
-	  called smc911x.  If you want to compile it as a module, say M 
+	  This driver is also available as a module. The module will be
+	  called smc911x.  If you want to compile it as a module, say M
 	  here and read <file:Documentation/modules.txt>
 
 config NET_VENDOR_RACAL
@@ -1988,6 +2095,11 @@ config E1000_DISABLE_PACKET_SPLIT
 
 	  If in doubt, say N.
 
+config E1000E
+	tristate "Intel(R) PRO/1000 PT Gigabit Ethernet support"
+	depends on PCI
+	depends on PCIEPORTBUS
+
 source "drivers/net/ixp2000/Kconfig"
 
 config MYRI_SBUS
@@ -2036,6 +2148,24 @@ config YELLOWFIN
 	  To compile this driver as a module, choose M here: the module
 	  will be called yellowfin.  This is recommended.
 
+config R1000
+        tristate "Realtek R1000 gigabit ethernet support"
+        depends on PCI
+        select CRC32
+        ---help---
+          Say Y here if you have a Realtek R1000 PCI Gigabit Ethernet adapter.
+
+
+config R8168
+        tristate "Realtek 8168 gigabit ethernet support"
+        depends on PCI
+        select CRC32
+        ---help---
+          Say Y here if you have a Realtek 8168 PCI Gigabit Ethernet adapter.
+
+          To compile this driver as a module, choose M here: the module
+          will be called r8168.  This is recommended.
+
 config R8169
 	tristate "Realtek 8169 gigabit ethernet support"
 	depends on PCI
@@ -2063,6 +2193,10 @@ config R8169_NAPI
 
 	  If in doubt, say N.
 
+config NET_SB1250_MAC
+	tristate "SB1250 Ethernet support"
+	depends on SIBYTE_SB1xxx_SOC
+
 config R8169_VLAN
 	bool "VLAN support"
 	depends on R8169 && VLAN_8021Q
@@ -2305,8 +2439,22 @@ config MV643XX_ETH
 	select MII
 	help
 	  This driver supports the gigabit Ethernet on the Marvell MV643XX
-	  chipset which is used in the Momenco Ocelot C and Jaguar ATX and
-	  Pegasos II, amongst other PPC and MIPS boards.
+	  chipset which is used in the Momenco Ocelot C Ocelot, Jaguar ATX
+	  and Pegasos II, amongst other PPC and MIPS boards.
+
+config BIG_SUR_FE
+	bool "PMC-Sierra TITAN Fast Ethernet Support"
+	depends on NET_ETHERNET && PMC_BIG_SUR
+	help
+	  This enables support for the the integrated ethernet of
+	  PMC-Sierra's Big Sur SoC.
+
+config TITAN_GE
+	bool "PMC-Sierra TITAN Gigabit Ethernet Support"
+	depends on PMC_YOSEMITE
+	help
+	  This enables support for the the integrated ethernet of
+	  PMC-Sierra's Titan SoC.
 
 config QLA3XXX
 	tristate "QLogic QLA3XXX Network Driver Support"
@@ -2814,6 +2962,28 @@ config PPPOATM
 	  which can lead to bad results if the ATM peer loses state and
 	  changes its encapsulation unilaterally.
 
+config PPPOL2TP
+	tristate "PPP over L2TP (EXPERIMENTAL)"
+	depends on EXPERIMENTAL && PPP
+	help
+	  Support for PPP-over-L2TP socket family. L2TP is a protocol
+	  used by ISPs and enterprises to tunnel PPP traffic over UDP
+	  tunnels. L2TP is replacing PPTP for VPN uses.
+
+	  This kernel component handles only L2TP data packets: a
+	  userland daemon handles L2TP the control protocol (tunnel
+	  and session setup). One such daemon is OpenL2TP
+	  (http://openl2tp.sourceforge.net/).
+
+config PPPOPPTP
+        tristate "PPTP (Point-to-Point Tunneling Protocol) (EXPERIMENTAL)"
+        depends on EXPERIMENTAL && PPP
+        help
+        Support for Microsoft Point-to-Point Tunneling Protocol.
+
+        See http://accel-pptp.sourceforge.net/ for information on
+        configuring PPTP clients and servers to utilize this driver.
+
 config SLIP
 	tristate "SLIP (serial line) support"
 	---help---
diff --git a/drivers/net/Makefile b/drivers/net/Makefile
index 33af833..20472b9 100644
--- a/drivers/net/Makefile
+++ b/drivers/net/Makefile
@@ -3,6 +3,11 @@
 #
 
 obj-$(CONFIG_E1000) += e1000/
+obj-$(CONFIG_E1000E) += e1000e/
+obj-$(CONFIG_RALINK_RDM) += rt_rdm/
+obj-$(CONFIG_RAETH) += raeth/
+obj-$(CONFIG_R1000) += r1000/
+obj-$(CONFIG_R8168) += r8168/
 obj-$(CONFIG_IBM_EMAC) += ibm_emac/
 obj-$(CONFIG_IXGB) += ixgb/
 obj-$(CONFIG_CHELSIO_T1) += chelsio/
@@ -73,7 +78,10 @@ obj-$(CONFIG_RIONET) += rionet.o
 #
 # end link order section
 #
-
+ifeq ($(CONFIG_RAETH_ROUTER),y)
+obj-$(CONFIG_RT2880_GMAC) += mii.o
+endif
+obj-$(CONFIG_IMQ) += imq.o
 obj-$(CONFIG_MII) += mii.o
 obj-$(CONFIG_PHYLIB) += phy/
 
@@ -112,6 +120,10 @@ obj-$(CONFIG_TSI108_ETH) += tsi108_eth.o
 obj-$(CONFIG_MV643XX_ETH) += mv643xx_eth.o
 obj-$(CONFIG_QLA3XXX) += qla3xxx.o
 
+obj-$(CONFIG_GALILEO_64240_ETH) += gt64240eth.o
+obj-$(CONFIG_BIG_SUR_FE) += big_sur_ge.o
+obj-$(CONFIG_TITAN_GE) += titan_mdio.o titan_ge.o
+
 obj-$(CONFIG_PPP) += ppp_generic.o
 obj-$(CONFIG_PPP_ASYNC) += ppp_async.o
 obj-$(CONFIG_PPP_SYNC_TTY) += ppp_synctty.o
@@ -119,6 +131,8 @@ obj-$(CONFIG_PPP_DEFLATE) += ppp_deflate.o
 obj-$(CONFIG_PPP_BSDCOMP) += bsd_comp.o
 obj-$(CONFIG_PPP_MPPE) += ppp_mppe.o
 obj-$(CONFIG_PPPOE) += pppox.o pppoe.o
+obj-$(CONFIG_PPPOL2TP) += pppox.o pppol2tp.o
+obj-$(CONFIG_PPPOPPTP) += pppox.o pppopptp.o
 
 obj-$(CONFIG_SLIP) += slip.o
 obj-$(CONFIG_SLHC) += slhc.o
diff --git a/drivers/net/ioc3-eth.c b/drivers/net/ioc3-eth.c
index 4ad7807..35aa355 100644
--- a/drivers/net/ioc3-eth.c
+++ b/drivers/net/ioc3-eth.c
@@ -61,12 +61,7 @@
 #include <asm/pgtable.h>
 #include <asm/uaccess.h>
 #include <asm/sn/types.h>
-#include <asm/sn/sn0/addrs.h>
-#include <asm/sn/sn0/hubni.h>
-#include <asm/sn/sn0/hubio.h>
-#include <asm/sn/klconfig.h>
 #include <asm/sn/ioc3.h>
-#include <asm/sn/sn0/ip27.h>
 #include <asm/pci/bridge.h>
 
 /*
@@ -94,6 +89,9 @@ struct ioc3_private {
 	u32 emcr, ehar_h, ehar_l;
 	spinlock_t ioc3_lock;
 	struct mii_if_info mii;
+	unsigned long flags;
+#define IOC3_FLAG_RX_CHECKSUMS	1
+
 	struct pci_dev *pdev;
 
 	/* Members used by autonegotiation  */
@@ -521,8 +519,6 @@ static struct net_device_stats *ioc3_get_stats(struct net_device *dev)
 	return &ip->stats;
 }
 
-#ifdef CONFIG_SGI_IOC3_ETH_HW_RX_CSUM
-
 static void ioc3_tcpudp_checksum(struct sk_buff *skb, uint32_t hwsum, int len)
 {
 	struct ethhdr *eh = eth_hdr(skb);
@@ -590,7 +586,6 @@ static void ioc3_tcpudp_checksum(struct sk_buff *skb, uint32_t hwsum, int len)
 	if (csum == 0xffff)
 		skb->ip_summed = CHECKSUM_UNNECESSARY;
 }
-#endif /* CONFIG_SGI_IOC3_ETH_HW_RX_CSUM */
 
 static inline void ioc3_rx(struct ioc3_private *ip)
 {
@@ -625,9 +620,9 @@ static inline void ioc3_rx(struct ioc3_private *ip)
 				goto next;
 			}
 
-#ifdef CONFIG_SGI_IOC3_ETH_HW_RX_CSUM
-			ioc3_tcpudp_checksum(skb, w0 & ERXBUF_IPCKSUM_MASK,len);
-#endif
+			if (likely(ip->flags & IOC3_FLAG_RX_CHECKSUMS))
+				ioc3_tcpudp_checksum(skb,
+					w0 & ERXBUF_IPCKSUM_MASK, len);
 
 			netif_rx(skb);
 
@@ -1294,9 +1289,7 @@ static int ioc3_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 	dev->set_multicast_list	= ioc3_set_multicast_list;
 	dev->set_mac_address	= ioc3_set_mac_address;
 	dev->ethtool_ops	= &ioc3_ethtool_ops;
-#ifdef CONFIG_SGI_IOC3_ETH_HW_TX_CSUM
 	dev->features		= NETIF_F_IP_CSUM;
-#endif
 
 	sw_physid1 = ioc3_mdio_read(dev, ip->mii.phy_id, MII_PHYSID1);
 	sw_physid2 = ioc3_mdio_read(dev, ip->mii.phy_id, MII_PHYSID2);
@@ -1386,7 +1379,6 @@ static int ioc3_start_xmit(struct sk_buff *skb, struct net_device *dev)
 	uint32_t w0 = 0;
 	int produce;
 
-#ifdef CONFIG_SGI_IOC3_ETH_HW_TX_CSUM
 	/*
 	 * IOC3 has a fairly simple minded checksumming hardware which simply
 	 * adds up the 1's complement checksum for the entire packet and
@@ -1434,7 +1426,6 @@ static int ioc3_start_xmit(struct sk_buff *skb, struct net_device *dev)
 
 		w0 = ETXD_DOCHECKSUM | (csoff << ETXD_CHKOFF_SHIFT);
 	}
-#endif /* CONFIG_SGI_IOC3_ETH_HW_TX_CSUM */
 
 	spin_lock_irq(&ip->ioc3_lock);
 
@@ -1589,12 +1580,37 @@ static u32 ioc3_get_link(struct net_device *dev)
 	return rc;
 }
 
+static u32 ioc3_get_rx_csum(struct net_device *dev)
+{
+	struct ioc3_private *ip = netdev_priv(dev);
+
+	return ip->flags & IOC3_FLAG_RX_CHECKSUMS;
+}
+
+static int ioc3_set_rx_csum(struct net_device *dev, u32 data)
+{
+	struct ioc3_private *ip = netdev_priv(dev);
+
+	spin_lock_bh(&ip->ioc3_lock);
+	if (data)
+		ip->flags |= IOC3_FLAG_RX_CHECKSUMS;
+	else
+		ip->flags &= ~IOC3_FLAG_RX_CHECKSUMS;
+	spin_unlock_bh(&ip->ioc3_lock);
+
+	return 0;
+}
+
 static const struct ethtool_ops ioc3_ethtool_ops = {
 	.get_drvinfo		= ioc3_get_drvinfo,
 	.get_settings		= ioc3_get_settings,
 	.set_settings		= ioc3_set_settings,
 	.nway_reset		= ioc3_nway_reset,
 	.get_link		= ioc3_get_link,
+	.get_rx_csum		= ioc3_get_rx_csum,
+	.set_rx_csum		= ioc3_set_rx_csum,
+	.get_tx_csum		= ethtool_op_get_tx_csum,
+	.set_tx_csum		= ethtool_op_set_tx_csum
 };
 
 static int ioc3_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
diff --git a/drivers/net/pppox.c b/drivers/net/pppox.c
index 9315046..1b1c350 100644
--- a/drivers/net/pppox.c
+++ b/drivers/net/pppox.c
@@ -114,6 +114,13 @@ static int pppox_create(struct socket *sock, int protocol)
 		goto out;
 
 	rc = -EPROTONOSUPPORT;
+#ifdef CONFIG_KMOD
+	if (!pppox_protos[protocol]) {
+		char buffer[32];
+		sprintf(buffer, "pppox-proto-%d", protocol);
+		request_module(buffer);
+	}
+#endif
 	if (!pppox_protos[protocol] ||
 	    !try_module_get(pppox_protos[protocol]->owner))
 		goto out;
diff --git a/drivers/net/wireless/Makefile b/drivers/net/wireless/Makefile
index c613af1..c13f957 100644
--- a/drivers/net/wireless/Makefile
+++ b/drivers/net/wireless/Makefile
@@ -43,3 +43,13 @@ obj-$(CONFIG_PCMCIA_RAYCS)	+= ray_cs.o
 obj-$(CONFIG_PCMCIA_WL3501)	+= wl3501_cs.o
 
 obj-$(CONFIG_USB_ZD1201)	+= zd1201.o
+
+obj-$(CONFIG_RT2860V2_AP)       += rt2860v2_ap/
+obj-$(CONFIG_RT2860V2_STA)      += rt2860v2_sta/
+obj-$(CONFIG_RT3090_AP)      	+= RT3090_ap/
+obj-$(CONFIG_RT3572_AP)      	+= RT3572_ap/
+obj-$(CONFIG_RT2880v2_INIC_MII) += iNIC/mii/
+obj-$(CONFIG_RT2880v2_INIC_PCI) += iNIC/pci/
+
+obj-$(CONFIG_RT305x_INIC_MII) += iNIC_RT305x/mii/
+obj-$(CONFIG_RT305x_INIC_USB) += iNIC_RT305x/usb/
diff --git a/drivers/scsi/NCR53C9x.h b/drivers/scsi/NCR53C9x.h
index d85cb73..2be1624 100644
--- a/drivers/scsi/NCR53C9x.h
+++ b/drivers/scsi/NCR53C9x.h
@@ -144,12 +144,7 @@
 
 #ifndef MULTIPLE_PAD_SIZES
 
-#ifdef CONFIG_CPU_HAS_WB
-#include <asm/wbflush.h>
-#define esp_write(__reg, __val) do{(__reg) = (__val); wbflush();} while(0)
-#else
-#define esp_write(__reg, __val) ((__reg) = (__val))
-#endif
+#define esp_write(__reg, __val) do{(__reg) = (__val); iob();} while(0)
 #define esp_read(__reg) (__reg)
 
 struct ESP_regs {
diff --git a/drivers/scsi/sgiwd93.c b/drivers/scsi/sgiwd93.c
index a15752b..8882a58 100644
--- a/drivers/scsi/sgiwd93.c
+++ b/drivers/scsi/sgiwd93.c
@@ -14,6 +14,7 @@
 #include <linux/interrupt.h>
 #include <linux/types.h>
 #include <linux/mm.h>
+#include <linux/module.h>
 #include <linux/blkdev.h>
 #include <linux/delay.h>
 #include <linux/dma-mapping.h>
@@ -197,6 +198,7 @@ void sgiwd93_reset(unsigned long base)
 	udelay(50);
 	hregs->ctrl = 0;
 }
+EXPORT_SYMBOL_GPL(sgiwd93_reset);
 
 static inline void init_hpc_chain(struct hpc_data *hd)
 {
diff --git a/drivers/serial/8250.c b/drivers/serial/8250.c
index 90621c3..f4e5777 100644
--- a/drivers/serial/8250.c
+++ b/drivers/serial/8250.c
@@ -326,7 +326,16 @@ static unsigned int serial_in(struct uart_8250_port *up, int offset)
 			return readb(up->port.membase + offset);
 
 	default:
+#if defined (CONFIG_RALINK_RT2880) || \
+    defined (CONFIG_RALINK_RT2883) || \
+    defined (CONFIG_RALINK_RT3883) || \
+    defined (CONFIG_RALINK_RT3352) || \
+    defined (CONFIG_RALINK_RT5350) || \
+    defined (CONFIG_RALINK_RT3052)
+		return (*(int*)(up->port.iobase + offset));
+#else
 		return inb(up->port.iobase + offset);
+#endif
 	}
 }
 
@@ -360,7 +369,16 @@ serial_out(struct uart_8250_port *up, int offset, int value)
 		break;
 
 	default:
+#if defined (CONFIG_RALINK_RT2880) || \
+    defined (CONFIG_RALINK_RT2883) || \
+    defined (CONFIG_RALINK_RT3883) || \
+    defined (CONFIG_RALINK_RT3352) || \
+    defined (CONFIG_RALINK_RT5350) || \
+    defined (CONFIG_RALINK_RT3052)
+		*(int*)(up->port.iobase + offset) = value;
+#else
 		outb(value, up->port.iobase + offset);
+#endif
 	}
 }
 
@@ -403,22 +421,21 @@ static inline void _serial_dl_write(struct uart_8250_port *up, int value)
 	serial_outp(up, UART_DLM, value >> 8 & 0xff);
 }
 
-#ifdef CONFIG_SERIAL_8250_AU1X00
-/* Au1x00 haven't got a standard divisor latch */
+#if defined (CONFIG_RALINK_RT2880) || \
+    defined (CONFIG_RALINK_RT2883) || \
+    defined (CONFIG_RALINK_RT3883) || \
+    defined (CONFIG_RALINK_RT3352) || \
+    defined (CONFIG_RALINK_RT5350) || \
+    defined (CONFIG_RALINK_RT3052)
+/* Ralink haven't got a standard divisor latch */
 static int serial_dl_read(struct uart_8250_port *up)
 {
-	if (up->port.iotype == UPIO_AU)
-		return __raw_readl(up->port.membase + 0x28);
-	else
-		return _serial_dl_read(up);
+	return serial_inp(up, UART_DLL);
 }
 
 static void serial_dl_write(struct uart_8250_port *up, int value)
 {
-	if (up->port.iotype == UPIO_AU)
-		__raw_writel(value, up->port.membase + 0x28);
-	else
-		_serial_dl_write(up, value);
+	serial_outp(up, UART_DLL, value);
 }
 #else
 #define serial_dl_read(up) _serial_dl_read(up)
@@ -593,11 +610,27 @@ static int size_fifo(struct uart_8250_port *up)
  */
 static unsigned int autoconfig_read_divisor_id(struct uart_8250_port *p)
 {
-	unsigned char old_dll, old_dlm, old_lcr;
+	unsigned char old_lcr;
 	unsigned int id;
+#if defined (CONFIG_RALINK_RT2880) || \
+    defined (CONFIG_RALINK_RT2883) || \
+    defined (CONFIG_RALINK_RT3883) || \
+    defined (CONFIG_RALINK_RT3352) || \
+    defined (CONFIG_RALINK_RT5350) || \
+    defined (CONFIG_RALINK_RT3052)
+	unsigned short old_dl;
+
+	old_dl = serial_dl_read(p);
+	serial_dl_write(p, 0);
+	id = serial_dl_read(p);
+	serial_dl_write(p, old_dl);
 
 	old_lcr = serial_inp(p, UART_LCR);
 	serial_outp(p, UART_LCR, UART_LCR_DLAB);
+#else
+	unsigned char old_dll, old_dlm;
+	old_lcr = serial_inp(p, UART_LCR);
+	serial_outp(p, UART_LCR, UART_LCR_DLAB);
 
 	old_dll = serial_inp(p, UART_DLL);
 	old_dlm = serial_inp(p, UART_DLM);
@@ -609,6 +642,7 @@ static unsigned int autoconfig_read_divisor_id(struct uart_8250_port *p)
 
 	serial_outp(p, UART_DLL, old_dll);
 	serial_outp(p, UART_DLM, old_dlm);
+#endif
 	serial_outp(p, UART_LCR, old_lcr);
 
 	return id;
diff --git a/drivers/serial/8250_early.c b/drivers/serial/8250_early.c
index 7e51119..05f9198 100644
--- a/drivers/serial/8250_early.c
+++ b/drivers/serial/8250_early.c
@@ -103,11 +103,20 @@ static unsigned int __init probe_baud(struct uart_port *port)
 
 	lcr = serial_in(port, UART_LCR);
 	serial_out(port, UART_LCR, lcr | UART_LCR_DLAB);
+#if defined (CONFIG_RALINK_RT2880) || \
+    defined (CONFIG_RALINK_RT2883) || \
+    defined (CONFIG_RALINK_RT3883) || \
+    defined (CONFIG_RALINK_RT3352) || \
+    defined (CONFIG_RALINK_RT5350) || \
+    defined (CONFIG_RALINK_RT3052)
+	quot= serial_in(port, UART_DLL);
+#else
 	dll = serial_in(port, UART_DLL);
 	dlm = serial_in(port, UART_DLM);
+	quot = (dlm << 8) | dll;
+#endif
 	serial_out(port, UART_LCR, lcr);
 
-	quot = (dlm << 8) | dll;
 	return (port->uartclk / 16) / quot;
 }
 
diff --git a/drivers/serial/ip22zilog.c b/drivers/serial/ip22zilog.c
index c3abfb3..f3257f7 100644
--- a/drivers/serial/ip22zilog.c
+++ b/drivers/serial/ip22zilog.c
@@ -862,6 +862,7 @@ ip22zilog_set_termios(struct uart_port *port, struct ktermios *termios,
 	up->cflag = termios->c_cflag;
 
 	ip22zilog_maybe_update_regs(up, ZILOG_CHANNEL_FROM_PORT(port));
+	uart_update_timeout(port, termios->c_cflag, baud);
 
 	spin_unlock_irqrestore(&up->port.lock, flags);
 }
@@ -1017,6 +1018,8 @@ ip22serial_console_termios(struct console *con, char *options)
 	}
 
 	con->cflag = cflag | CS8;			/* 8N1 */
+
+	uart_update_timeout(&ip22zilog_port_table[con->index].port, cflag, baud);
 }
 
 static int __init ip22zilog_console_setup(struct console *con, char *options)
diff --git a/drivers/serial/serial_core.c b/drivers/serial/serial_core.c
index 0422c0f..68e56c0 100644
--- a/drivers/serial/serial_core.c
+++ b/drivers/serial/serial_core.c
@@ -414,6 +414,14 @@ uart_get_divisor(struct uart_port *port, unsigned int baud)
 		quot = port->custom_divisor;
 	else
 		quot = (port->uartclk + (8 * baud)) / (16 * baud);
+#if defined (CONFIG_RALINK_RT2880) || \
+	defined (CONFIG_RALINK_RT2883) || \
+	defined (CONFIG_RALINK_RT3883) || \
+	defined (CONFIG_RALINK_RT3352) || \
+	defined (CONFIG_RALINK_RT5350) || \
+	defined (CONFIG_RALINK_RT3052)
+	quot = port->custom_divisor;
+#endif
 
 	return quot;
 }
diff --git a/drivers/usb/Kconfig b/drivers/usb/Kconfig
index 9980a4d..71abbec 100644
--- a/drivers/usb/Kconfig
+++ b/drivers/usb/Kconfig
@@ -12,7 +12,7 @@ config USB_ARCH_HAS_HCD
 	default y if USB_ARCH_HAS_OHCI
 	default y if USB_ARCH_HAS_EHCI
 	default y if ARM				# SL-811
-	default PCI
+#	default PCI
 
 # many non-PCI SOC chips embed OHCI
 config USB_ARCH_HAS_OHCI
@@ -31,6 +31,7 @@ config USB_ARCH_HAS_OHCI
 	default y if PPC_MPC52xx
 	# MIPS:
 	default y if SOC_AU1X00
+	default y if RT3XXX_EHCI_OHCI
 	# more:
 	default PCI
 
@@ -39,12 +40,13 @@ config USB_ARCH_HAS_EHCI
 	boolean
 	default y if PPC_83xx
 	default y if SOC_AU1200
+	default y if RT3XXX_EHCI_OHCI
 	default PCI
 
 # ARM SA1111 chips have a non-PCI based "OHCI-compatible" USB host interface.
 config USB
 	tristate "Support for Host-side USB"
-	depends on USB_ARCH_HAS_HCD
+#	depends on USB_ARCH_HAS_HCD
 	---help---
 	  Universal Serial Bus (USB) is a specification for a serial bus
 	  subsystem which offers higher speeds and more features than the
diff --git a/drivers/usb/Makefile b/drivers/usb/Makefile
index 8b7ff46..8a8b52f 100644
--- a/drivers/usb/Makefile
+++ b/drivers/usb/Makefile
@@ -71,3 +71,4 @@ obj-$(CONFIG_USB_USS720)	+= misc/
 
 obj-$(CONFIG_USB_ATM)		+= atm/
 obj-$(CONFIG_USB_SPEEDTOUCH)	+= atm/
+obj-$(CONFIG_DWC_OTG) 		+= dwc_otg/
diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index b26c19e..15d18e8 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -786,7 +786,7 @@ static void usb_deregister_bus (struct usb_bus *bus)
  * to register the usb device.  It also assigns the root hub's USB address
  * (always 1).
  */
-static int register_root_hub(struct usb_hcd *hcd)
+int register_root_hub(struct usb_hcd *hcd)
 {
 	struct device *parent_dev = hcd->self.controller;
 	struct usb_device *usb_dev = hcd->self.root_hub;
@@ -830,6 +830,7 @@ static int register_root_hub(struct usb_hcd *hcd)
 
 	return retval;
 }
+EXPORT_SYMBOL (register_root_hub);
 
 void usb_enable_root_hub_irq (struct usb_bus *bus)
 {
diff --git a/drivers/usb/core/message.c b/drivers/usb/core/message.c
index 217a3d6..ac1b35a 100644
--- a/drivers/usb/core/message.c
+++ b/drivers/usb/core/message.c
@@ -982,16 +982,25 @@ void usb_disable_endpoint(struct usb_device *dev, unsigned int epaddr)
 
 	if (!dev)
 		return;
-
-	if (usb_endpoint_out(epaddr)) {
-		ep = dev->ep_out[epnum];
-		dev->ep_out[epnum] = NULL;
-	} else {
-		ep = dev->ep_in[epnum];
-		dev->ep_in[epnum] = NULL;
-	}
-	if (ep && dev->bus)
-		usb_hcd_endpoint_disable(dev, ep);
+ /*
+  * We change the order for the buggy DWC_OTG HCD driver.
+  * --YY@Ralink 2008/06/18
+  */
+    if (usb_endpoint_out(epaddr)) {
+        ep = dev->ep_out[epnum];
+//      dev->ep_out[epnum] = NULL;
+    } else {
+        ep = dev->ep_in[epnum];
+//      dev->ep_in[epnum] = NULL;
+    }
+    if (ep && dev->bus)
+        usb_hcd_endpoint_disable(dev, ep);
+
+    if (usb_endpoint_out(epaddr)) {
+        dev->ep_out[epnum] = NULL;
+    } else {
+        dev->ep_in[epnum] = NULL;
+    }
 }
 
 /**
diff --git a/drivers/usb/core/usb.c b/drivers/usb/core/usb.c
index 54b42ce..1b6ded2 100644
--- a/drivers/usb/core/usb.c
+++ b/drivers/usb/core/usb.c
@@ -997,5 +997,5 @@ EXPORT_SYMBOL(usb_buffer_map_sg);
 EXPORT_SYMBOL(usb_buffer_dmasync_sg);
 #endif
 EXPORT_SYMBOL(usb_buffer_unmap_sg);
-
+EXPORT_SYMBOL(usb_alloc_dev);
 MODULE_LICENSE("GPL");
diff --git a/drivers/usb/gadget/Kconfig b/drivers/usb/gadget/Kconfig
index 4097a86..2ca4a5f 100644
--- a/drivers/usb/gadget/Kconfig
+++ b/drivers/usb/gadget/Kconfig
@@ -247,6 +247,14 @@ config USB_GADGET_DUALSPEED
 	  Means that gadget drivers should include extra descriptors
 	  and code to handle dual-speed controllers.
 
+config USB_GADGET_SNPS_DWC_OTG
+	boolean "Synopsys Driver for DWC_otg Controller"
+	depends on USB && EXPERIMENTAL
+	select USB_OTG
+	select USB_GADGET_DUALSPEED
+	help
+	   Selects the Synopsys Driver for the DWC_otg Controller.
+
 #
 # USB Gadget Drivers
 #
diff --git a/drivers/usb/gadget/Makefile b/drivers/usb/gadget/Makefile
index e71e086..df74ae9 100644
--- a/drivers/usb/gadget/Makefile
+++ b/drivers/usb/gadget/Makefile
@@ -1,7 +1,10 @@
 #
 # USB peripheral controller drivers
 #
-obj-$(CONFIG_USB_DUMMY_HCD)	+= dummy_hcd.o
+
+# mask by kaiker ,for RT3052 USB OTG device mode
+#obj-$(CONFIG_USB_DUMMY_HCD)	+= dummy_hcd.o
+
 obj-$(CONFIG_USB_NET2280)	+= net2280.o
 obj-$(CONFIG_USB_PXA2XX)	+= pxa2xx_udc.o
 obj-$(CONFIG_USB_GOKU)		+= goku_udc.o
@@ -19,6 +22,7 @@ g_midi-objs			:= gmidi.o usbstring.o config.o epautoconf.o
 gadgetfs-objs			:= inode.o
 g_file_storage-objs		:= file_storage.o usbstring.o config.o \
 					epautoconf.o
+g_ram_storage-objs		:= ram_storage.o usbstring.o config.o epautoconf.o
 
 ifeq ($(CONFIG_USB_ETH_RNDIS),y)
 	g_ether-objs		+= rndis.o
diff --git a/drivers/usb/gadget/ether.c b/drivers/usb/gadget/ether.c
index 04e6b85..c69b975 100644
--- a/drivers/usb/gadget/ether.c
+++ b/drivers/usb/gadget/ether.c
@@ -1722,7 +1722,13 @@ rx_submit (struct eth_dev *dev, struct usb_request *req, gfp_t gfp_flags)
 	 * but on at least one, checksumming fails otherwise.  Note:
 	 * RNDIS headers involve variable numbers of LE32 values.
 	 */
-	skb_reserve(skb, NET_IP_ALIGN);
+
+	/*
+	   mask by kaiker ,for RT3052 USB OTG device mode
+	   Synopsys USB internal DMA address must set to 4 byte alignment
+	*/
+
+	//skb_reserve(skb, NET_IP_ALIGN);
 
 	req->buf = skb->data;
 	req->length = size;
@@ -1955,6 +1961,8 @@ static int eth_start_xmit (struct sk_buff *skb, struct net_device *net)
 	struct usb_request	*req = NULL;
 	unsigned long		flags;
 
+	unsigned char *new_addr;
+
 	/* apply outgoing CDC or RNDIS filters */
 	if (!eth_is_promisc (dev)) {
 		u8		*dest = skb->data;
@@ -2001,6 +2009,17 @@ static int eth_start_xmit (struct sk_buff *skb, struct net_device *net)
 		rndis_add_hdr (skb);
 		length = skb->len;
 	}
+	/*
+	   New add by kaiker ,for RT3052 USB OTG device mode
+	   Synopsys USB internal DMA address must set to 4 byte alignment
+	*/
+
+	#if 1
+	new_addr = skb->data - 2;
+	memcpy(new_addr,skb->data,skb->len);
+	skb->data = new_addr;
+    #endif
+
 	req->buf = skb->data;
 	req->context = skb;
 	req->complete = tx_complete;
diff --git a/drivers/usb/gadget/file_storage.c b/drivers/usb/gadget/file_storage.c
index c6b6479..3b41742 100644
--- a/drivers/usb/gadget/file_storage.c
+++ b/drivers/usb/gadget/file_storage.c
@@ -276,8 +276,8 @@ MODULE_LICENSE("Dual BSD/GPL");
  *
  * DO NOT REUSE THESE IDs with any other driver!!  Ever!!
  * Instead:  allocate your own, using normal USB-IF procedures. */
-#define DRIVER_VENDOR_ID	0x0525	// NetChip
-#define DRIVER_PRODUCT_ID	0xa4a5	// Linux-USB File-backed Storage Gadget
+#define DRIVER_VENDOR_ID	0x053f	// Synopsys
+#define DRIVER_PRODUCT_ID	0x0000	// Linux-USB File-backed Storage Gadget
 
 
 /*
@@ -296,11 +296,11 @@ MODULE_LICENSE("Dual BSD/GPL");
 
 #ifdef DEBUG
 #define DBG(fsg,fmt,args...) \
-	xprintk(fsg , KERN_DEBUG , fmt , ## args)
+	xprintk(fsg , KERN_ERR , fmt , ## args)
 #define LDBG(lun,fmt,args...) \
-	yprintk(lun , KERN_DEBUG , fmt , ## args)
+	yprintk(lun , KERN_ERR , fmt , ## args)
 #define MDBG(fmt,args...) \
-	printk(KERN_DEBUG DRIVER_NAME ": " fmt , ## args)
+	printk(KERN_ERR DRIVER_NAME ": " fmt , ## args)
 #else
 #define DBG(fsg,fmt,args...) \
 	do { } while (0)
@@ -356,6 +356,7 @@ static struct {
 
 	int		removable;
 	int		can_stall;
+	int		cdrom;
 
 	char		*transport_parm;
 	char		*protocol_parm;
@@ -374,6 +375,7 @@ static struct {
 	.protocol_parm		= "SCSI",
 	.removable		= 0,
 	.can_stall		= 1,
+	.cdrom			= 0,
 	.vendor			= DRIVER_VENDOR_ID,
 	.product		= DRIVER_PRODUCT_ID,
 	.release		= 0xffff,	// Use controller chip type
@@ -397,6 +399,8 @@ MODULE_PARM_DESC(removable, "true to simulate removable media");
 module_param_named(stall, mod_data.can_stall, bool, S_IRUGO);
 MODULE_PARM_DESC(stall, "false to prevent bulk stalls");
 
+module_param_named(cdrom, mod_data.cdrom, bool, S_IRUGO);
+MODULE_PARM_DESC(cdrom, "true to emulate cdrom instead of disk");
 
 /* In the non-TEST version, only the module parameters listed above
  * are available. */
@@ -426,6 +430,10 @@ MODULE_PARM_DESC(buflen, "I/O buffer size");
 
 /*-------------------------------------------------------------------------*/
 
+/* SCSI device types */
+#define TYPE_DISK 0x00
+#define TYPE_CDROM 0x05
+
 /* USB protocol value = the transport method */
 #define USB_PR_CBI	0x00		// Control/Bulk/Interrupt
 #define USB_PR_CB	0x01		// Control/Bulk w/o interrupt
@@ -502,6 +510,8 @@ struct interrupt_data {
 #define SC_READ_12			0xa8
 #define SC_READ_CAPACITY		0x25
 #define SC_READ_FORMAT_CAPACITIES	0x23
+#define SC_READ_HEADER			0x44
+#define SC_READ_TOC			0x43
 #define SC_RELEASE			0x17
 #define SC_REQUEST_SENSE		0x03
 #define SC_RESERVE			0x16
@@ -563,6 +573,7 @@ struct lun {
 	struct file	*filp;
 	loff_t		file_length;
 	loff_t		num_sectors;
+	loff_t		min_sectors;
 
 	unsigned int	ro : 1;
 	unsigned int	prevent_medium_removal : 1;
@@ -881,8 +892,8 @@ config_desc = {
 	.bNumInterfaces =	1,
 	.bConfigurationValue =	CONFIG_VALUE,
 	.iConfiguration =	STRING_CONFIG,
-	.bmAttributes =		USB_CONFIG_ATT_ONE | USB_CONFIG_ATT_SELFPOWER,
-	.bMaxPower =		1,	// self-powered
+	.bmAttributes =		USB_CONFIG_ATT_ONE  | USB_CONFIG_ATT_SELFPOWER,
+	.bMaxPower =		0,	// self-powered
 };
 
 static struct usb_otg_descriptor
@@ -2060,24 +2071,27 @@ static int do_inquiry(struct fsg_dev *fsg, struct fsg_buffhd *bh)
 	u8	*buf = (u8 *) bh->buf;
 
 	static char vendor_id[] = "Linux   ";
-	static char product_id[] = "File-Stor Gadget";
+	static char product_disk_id[] = "File-Stor Gadget";
+	static char product_cdrom_id[] = "File-CD Gadget ";
 
 	if (!fsg->curlun) {		// Unsupported LUNs are okay
 		fsg->bad_lun_okay = 1;
 		memset(buf, 0, 36);
 		buf[0] = 0x7f;		// Unsupported, no device-type
+		buf[4] = 31;		// Additional length
 		return 36;
 	}
 
-	memset(buf, 0, 8);	// Non-removable, direct-access device
+	memset(buf, 0, 8);
+	buf[0] = (mod_data.cdrom ? TYPE_CDROM : TYPE_DISK);
 	if (mod_data.removable)
 		buf[1] = 0x80;
 	buf[2] = 2;		// ANSI SCSI level 2
 	buf[3] = 2;		// SCSI-2 INQUIRY data format
 	buf[4] = 31;		// Additional length
 				// No special options
-	sprintf(buf + 8, "%-8s%-16s%04x", vendor_id, product_id,
-			mod_data.release);
+
+	sprintf(buf + 8, "%-8s%-16s%04x", vendor_id, (mod_data.cdrom ? product_cdrom_id : product_disk_id), mod_data.release);
 	return 36;
 }
 
@@ -2155,6 +2169,72 @@ static int do_read_capacity(struct fsg_dev *fsg, struct fsg_buffhd *bh)
 }
 
 
+static void store_cdrom_address(u8 *dest, int msf, u32 addr)
+{
+	if (msf) {
+		/* Convert to Minutes-Seconds-Frames */
+		addr >>= 2; /* Convert to 2048-byte frames */
+		addr += 2*75; /* Lead-in occupies 2 seconds */
+		dest[3] = addr % 75; /* Frames */
+		addr /= 75;
+		dest[2] = addr % 60; /* Seconds */
+		addr /= 60;
+		dest[1] = addr; /* Minutes */
+		dest[0] = 0; /* Reserved */
+	} else {
+		/* Absolute sector */
+		put_be32(dest, addr);
+	}
+}
+
+static int do_read_header(struct fsg_dev *fsg, struct fsg_buffhd *bh)
+{
+	struct lun *curlun = fsg->curlun;
+	int msf = fsg->cmnd[1] & 0x02;
+	u32 lba = get_be32(&fsg->cmnd[2]);
+	u8 *buf = (u8 *) bh->buf;
+
+	if ((fsg->cmnd[1] & ~0x02) != 0) { /* Mask away MSF */
+		curlun->sense_data = SS_INVALID_FIELD_IN_CDB;
+		return -EINVAL;
+	}
+
+	if (lba >= curlun->num_sectors) {
+		curlun->sense_data = SS_LOGICAL_BLOCK_ADDRESS_OUT_OF_RANGE;
+		return -EINVAL;
+	}
+
+	memset(buf, 0, 8);
+	buf[0] = 0x01; /* 2048 bytes of user data, rest is EC */
+	store_cdrom_address(&buf[4], msf, lba);
+	return 8;
+}
+
+static int do_read_toc(struct fsg_dev *fsg, struct fsg_buffhd *bh)
+{
+	struct lun *curlun = fsg->curlun;
+	int msf = fsg->cmnd[1] & 0x02;
+	int start_track = fsg->cmnd[6];
+	u8 *buf = (u8 *) bh->buf;
+	if ((fsg->cmnd[1] & ~0x02) != 0 || /* Mask away MSF */ start_track > 1){
+		curlun->sense_data = SS_INVALID_FIELD_IN_CDB;
+		return -EINVAL;
+	}
+	memset(buf, 0, 20);
+	buf[1] = (20-2); /* TOC data length */
+	buf[2] = 1; /* First track number */
+	buf[3] = 1; /* Last track number */
+	buf[5] = 0x16; /* Data track, copying allowed */
+	buf[6] = 0x01; /* Only track is number 1 */
+	store_cdrom_address(&buf[8], msf, 0);
+
+	buf[13] = 0x16; /* Lead-out track is data */
+	buf[14] = 0xAA; /* Lead-out track number */
+	store_cdrom_address(&buf[16], msf, curlun->num_sectors);
+
+	return 20;
+}
+
 static int do_mode_sense(struct fsg_dev *fsg, struct fsg_buffhd *bh)
 {
 	struct lun	*curlun = fsg->curlun;
@@ -2499,7 +2579,7 @@ static int finish_reply(struct fsg_dev *fsg)
 				start_transfer(fsg, fsg->bulk_in, bh->inreq,
 						&bh->inreq_busy, &bh->state);
 				fsg->next_buffhd_to_fill = bh->next;
-				rc = halt_bulk_in_endpoint(fsg);
+//				rc = halt_bulk_in_endpoint(fsg);
 			} else
 				rc = pad_with_zeros(fsg);
 		}
@@ -2863,6 +2943,22 @@ static int do_scsi_command(struct fsg_dev *fsg)
 			reply = do_read_capacity(fsg, bh);
 		break;
 
+	case SC_READ_HEADER:
+		if (!mod_data.cdrom)
+			goto unknown_cmnd;
+		fsg->data_size_from_cmnd = get_be16(&fsg->cmnd[7]);
+		if ((reply = check_command(fsg, 10, DATA_DIR_TO_HOST, (3<<7) | (0x1f<<1), 1, "READ HEADER")) == 0)
+			reply = do_read_header(fsg, bh);
+		break;
+
+	case SC_READ_TOC:
+		if (!mod_data.cdrom)
+			goto unknown_cmnd;
+		fsg->data_size_from_cmnd = get_be16(&fsg->cmnd[7]);
+		if ((reply = check_command(fsg, 10, DATA_DIR_TO_HOST, (7<<6) | (1<<1), 1, "READ TOC")) == 0)
+			reply = do_read_toc(fsg, bh);
+			break;
+
 	case SC_READ_FORMAT_CAPACITIES:
 		fsg->data_size_from_cmnd = get_be16(&fsg->cmnd[7]);
 		if ((reply = check_command(fsg, 10, DATA_DIR_TO_HOST,
@@ -2948,6 +3044,7 @@ static int do_scsi_command(struct fsg_dev *fsg)
 		// Fall through
 
 	default:
+unknown_cmnd:
 		fsg->data_size_from_cmnd = 0;
 		sprintf(unknown, "Unknown x%02x", fsg->cmnd[0]);
 		if ((reply = check_command(fsg, fsg->cmnd_size,
@@ -3002,6 +3099,9 @@ static int received_cbw(struct fsg_dev *fsg, struct fsg_buffhd *bh)
 			set_bit(CLEAR_BULK_HALTS, &fsg->atomic_bitflags);
 		fsg_set_halt(fsg, fsg->bulk_out);
 		halt_bulk_in_endpoint(fsg);
+		fsg->bulk_in->ops->set_halt(fsg->bulk_in, 3);
+		fsg_set_halt(fsg, fsg->bulk_out);
+		fsg->bulk_out->ops->set_halt(fsg->bulk_out, 3);
 		return -EINVAL;
 	}
 
@@ -3015,8 +3115,10 @@ static int received_cbw(struct fsg_dev *fsg, struct fsg_buffhd *bh)
 		/* We can do anything we want here, so let's stall the
 		 * bulk pipes if we are allowed to. */
 		if (mod_data.can_stall) {
-			fsg_set_halt(fsg, fsg->bulk_out);
 			halt_bulk_in_endpoint(fsg);
+			fsg->bulk_in->ops->set_halt(fsg->bulk_in, 3);
+			fsg_set_halt(fsg, fsg->bulk_out);
+			fsg->bulk_out->ops->set_halt(fsg->bulk_out, 3);
 		}
 		return -EINVAL;
 	}
@@ -3369,8 +3471,8 @@ static void handle_exception(struct fsg_dev *fsg)
 		 * requires this.) */
 		if (test_and_clear_bit(CLEAR_BULK_HALTS,
 				&fsg->atomic_bitflags)) {
-			usb_ep_clear_halt(fsg->bulk_in);
-			usb_ep_clear_halt(fsg->bulk_out);
+		fsg->bulk_out->ops->set_halt(fsg->bulk_out, 2);
+		fsg->bulk_in->ops->set_halt(fsg->bulk_in, 2);
 		}
 
 		if (transport_is_bbb()) {
@@ -3409,7 +3511,7 @@ static void handle_exception(struct fsg_dev *fsg)
 
 	case FSG_STATE_DISCONNECT:
 		fsync_all(fsg);
-		do_set_config(fsg, 0);		// Unconfigured state
+ 		do_set_config(fsg, 0);		// Unconfigured state
 		break;
 
 	case FSG_STATE_EXIT:
@@ -3441,6 +3543,9 @@ static int fsg_main_thread(void *fsg_)
 	 * that expects a __user pointer and it will work okay. */
 	set_fs(get_ds());
 
+	/* Setting this thread high priority */
+	set_user_nice(current, -20);
+	
 	/* The main loop */
 	while (fsg->state != FSG_STATE_TERMINATED) {
 		if (exception_in_progress(fsg) || signal_pending(current)) {
@@ -3507,6 +3612,7 @@ static int open_backing_file(struct lun *curlun, const char *filename)
 	struct inode			*inode = NULL;
 	loff_t				size;
 	loff_t				num_sectors;
+	loff_t				min_sectors; 
 
 	/* R/W if we can, R/O if we must */
 	ro = curlun->ro;
@@ -3550,8 +3656,20 @@ static int open_backing_file(struct lun *curlun, const char *filename)
 		rc = (int) size;
 		goto out;
 	}
-	num_sectors = size >> 9;	// File size in 512-byte sectors
-	if (num_sectors == 0) {
+
+	num_sectors = size >> 9; // File size in 512-byte blocks
+	min_sectors = 1;
+	if (mod_data.cdrom) {
+		num_sectors &= ~3; // Reduce to a multiple of 2048
+		min_sectors = 300*4; // Smallest track is 300 frames
+		if (num_sectors >= 256*60*75*4) {
+			num_sectors = (256*60*75 - 1) * 4;
+			LINFO(curlun, "file too big: %s\n", filename);
+			LINFO(curlun, "using only first %d blocks\n", (int) num_sectors);
+		}
+	}
+	if (num_sectors < min_sectors) {
+
 		LINFO(curlun, "file too small: %s\n", filename);
 		rc = -ETOOSMALL;
 		goto out;
@@ -3777,6 +3895,13 @@ static int __init check_parameters(struct fsg_dev *fsg)
 			gcnum = usb_gadget_controller_number(fsg->gadget);
 		if (gcnum >= 0)
 			mod_data.release = 0x0300 + gcnum;
+                else if (gadget_is_dwc_otg(fsg->gadget)) {
+			mod_data.release = __constant_cpu_to_le16 (0x0200);
+                        mod_data.vendor  = __constant_cpu_to_le16 (0x053f);
+                        if (mod_data.product == DRIVER_PRODUCT_ID) {
+                                mod_data.product  = __constant_cpu_to_le16 (0x0000);
+                        }
+                }
 		else {
 			WARN(fsg, "controller '%s' not recognized\n",
 				fsg->gadget->name);
@@ -3859,9 +3984,12 @@ static int __init fsg_bind(struct usb_gadget *gadget)
 		goto out;
 
 	if (mod_data.removable) {	// Enable the store_xxx attributes
-		dev_attr_ro.attr.mode = dev_attr_file.attr.mode = 0644;
-		dev_attr_ro.store = store_ro;
+		dev_attr_file.attr.mode = 0644;
 		dev_attr_file.store = store_file;
+		if (!mod_data.cdrom) {
+			dev_attr_ro.attr.mode = 0644;
+			dev_attr_ro.store = store_ro;
+		} 
 	}
 
 	/* Find out how many LUNs there should be */
@@ -3886,6 +4014,8 @@ static int __init fsg_bind(struct usb_gadget *gadget)
 	for (i = 0; i < fsg->nluns; ++i) {
 		curlun = &fsg->luns[i];
 		curlun->ro = mod_data.ro[i];
+		if (mod_data.cdrom)
+			curlun->ro = 1;
 		curlun->dev.release = lun_release;
 		curlun->dev.parent = &gadget->dev;
 		curlun->dev.driver = &fsg_driver.driver;
@@ -3965,8 +4095,7 @@ static int __init fsg_bind(struct usb_gadget *gadget)
 #endif
 
 	if (gadget->is_otg) {
-		otg_desc.bmAttributes |= USB_OTG_HNP,
-		config_desc.bmAttributes |= USB_CONFIG_ATT_WAKEUP;
+		otg_desc.bmAttributes |= USB_OTG_HNP;
 	}
 
 	rc = -ENOMEM;
diff --git a/drivers/usb/gadget/gadget_chips.h b/drivers/usb/gadget/gadget_chips.h
index 2e3d662..53178ba 100644
--- a/drivers/usb/gadget/gadget_chips.h
+++ b/drivers/usb/gadget/gadget_chips.h
@@ -9,6 +9,15 @@
  *
  * NOTE:  some of these controller drivers may not be available yet.
  */
+
+
+
+#if 1 //def DWC_OTG_DEVICE_ONLY
+#define gadget_is_dwc_otg(g)	!strcmp("dwc_otg_pcd", (g)->name)
+#else
+#define gadget_is_dwc_otg(g)	0
+#endif
+
 #ifdef CONFIG_USB_GADGET_NET2280
 #define	gadget_is_net2280(g)	!strcmp("net2280", (g)->name)
 #else
@@ -119,6 +128,12 @@
 #define gadget_is_mpc8272(g)	0
 #endif
 
+#ifdef CONFIG_USB_GADGET_SNPS_DWC_OTG
+#define	gadget_is_dwc_otg(g)	!strcmp("dwc_otg_pcd", (g)->name)
+#else
+#define	gadget_is_dwc_otg(g)	0
+#endif
+
 // CONFIG_USB_GADGET_SX2
 // CONFIG_USB_GADGET_AU1X00
 // ...
@@ -177,5 +192,11 @@ static inline int usb_gadget_controller_number(struct usb_gadget *gadget)
 		return 0x17;
 	else if (gadget_is_husb2dev(gadget))
 		return 0x18;
+
+//by kaiker ,for RT3052 USB OTG device mode
+
+	else if (gadget_is_dwc_otg(gadget))
+		return 0x19;
+
 	return -ENOENT;
 }
diff -ub a/drivers/usb/gadget/rt_udc.c b/drivers/usb/gadget/rt_udc.c 
--- a/drivers/usb/gadget/rt_udc.c	2014-09-18 15:05:58.678860765 +0700
+++ b/drivers/usb/gadget/rt_udc.c	2014-09-17 10:57:15.660959000 +0700
@@ -209,6 +209,14 @@
 
 	/* Setup ep fifos */
 	rt_udc_init_fifo(rt_usb);
+
+	/* Force the USB Bus(D+/D-) to "disconnect" state.
+	 * This bit will restore to "connect" state in gadget driver initial func
+	 *  -- usb_gadget_register_driver().
+	 */
+#define USBCS                   (0x1A3)
+#define USBCS_DISCON            (0x1 << 6)
+	usb_write(USBCS, usb_read(USBCS) | USBCS_DISCON);
 }
 
 static void rt_ep_irq_disable(struct rt_ep_struct *rt_ep)
@@ -322,6 +330,7 @@
 	if (status && status != -ESHUTDOWN)
 		D_ERR(rt_ep->rt_usb->dev, "<%s> complete %s req %p stat %d len %u/%u\n", __func__, rt_ep->ep.name, &req->req, status,req->req.actual, req->req.length);
 
+	printk("<%s> complete %s req %p stat %d len %u/%u\n", __FUNCTION__, rt_ep->ep.name, &req->req, status, req->req.actual, req->req.length);
 	req->req.complete(&rt_ep->ep, &req->req);
 }
 
@@ -407,7 +416,8 @@
 				break;
 	        }else{
 				if(req && ( (req->req.actual % rt_ep->ep.maxpacket) || (req->req.actual >= req->req.length))){
-					xprintk("q.l=%d,q.a=%d\n", req->req.length, req->req.actual);
+					//xprintk("q.l=%d,q.a=%d\n", req->req.length, req->req.actual);
+					printk("%s q.l=%d q.a=%d\n", __FUNCTION__, req->req.length, req->req.actual);
 					done(rt_ep, req, 0);
 				}
 			}
@@ -423,9 +433,10 @@
 {
 	struct rt_request *req;
 
-	DBG;
+//	DBG;
 	while (!list_empty(&rt_ep->queue)) {
 		req = list_entry(rt_ep->queue.next, struct rt_request, queue);
+		printk("%s status=%d\n", __FUNCTION__, status);
 		done(rt_ep, req, status);
 	}
 }
@@ -573,8 +584,8 @@
 	int	length, i;
 	u32 maxpacket;
 
-DBG;
-	xprintk("q.l=%d, q.a=%d, maxp=%d\n", req->req.length, req->req.actual, rt_ep->ep.maxpacket);
+//DBG;
+	printk("%s q.l=%d, q.a=%d, maxp=%d\n", __FUNCTION__, req->req.length, req->req.actual, rt_ep->ep.maxpacket);
 
 	buf = req->req.buf + req->req.actual;
 	maxpacket = (u32)(rt_ep->ep.maxpacket);
@@ -673,13 +684,16 @@
 {
 	struct rt_request *req = NULL;
 
-DBG;
+//DBG;
 	if (list_empty(&rt_ep->queue)) {
 		D_ERR(rt_ep->rt_usb->dev, "<%s> no request on %s\n", __func__, rt_ep->ep.name);
 		return NULL;
 	}
 
 	req = list_entry(rt_ep->queue.next, struct rt_request, queue);
+
+    printk("%s %s state=%d\n", __FUNCTION__, rt_ep->ep.name, rt_ep->rt_usb->ep0state);
+
 	switch (rt_ep->rt_usb->ep0state) {
 		case EP0_IN_DATA_PHASE:			/* GET_DESCRIPTOR */
 			write_ep0_fifo(rt_ep, req);
@@ -865,6 +879,9 @@
 	 *	handle No-data Ctrl transfer.
 	 */
 	if(!EP_NO(rt_ep)/* EP0 */ && EP_DIR(rt_ep) == EP_OUT && !req->length){
+
+		printk("%s handle No-data Ctrl transfer\n", __FUNCTION__);
+
 		done(rt_ep, rt_req, 0);
 		local_irq_restore(flags);
 		return ret;
@@ -921,6 +938,8 @@
 		return -EINVAL;
 	}
 
+	printk("%s %s done\n", __FUNCTION__, rt_ep->ep.name);
+
 	done(rt_ep, req, -ECONNRESET);
 
 	local_irq_restore(flags);
@@ -1224,6 +1243,9 @@
 		rt_ep->tx_done_count = 0;
 		if(!epinirq /* EP0 */)
 			ep0_chg_stat(__func__, rt_usb, EP0_IDLE);
+
+
+    	printk("%s %s done\n", __FUNCTION__, rt_ep->ep.name);
 		done(rt_ep, req, 0);
 #if 1
 		// more reqs there.
@@ -1290,6 +1312,9 @@
 
 		if(req && ((req->req.actual % rt_ep->ep.maxpacket) || (req->req.actual >= req->req.length))){
 			ep0_chg_stat(__func__, rt_usb, EP0_IDLE);
+
+
+        	printk("%s %s done\n", __FUNCTION__, rt_ep->ep.name);
 			done(rt_ep, req, 0);	// short packet indicates transaction is done.
 
 			epcs = read_epcs(rt_ep);
@@ -1318,6 +1343,7 @@
 			xprintk("q.l=%d,q.a=%d\n", req->req.length, req->req.actual);
 
 			//rx_done(rt_ep, req, 0);
+        	printk("%s %s done\n", __FUNCTION__, rt_ep->ep.name);
 			done(rt_ep, req, 0);
 		}
 
@@ -1523,7 +1549,7 @@
 		.bmAttributes		= USB_ENDPOINT_XFER_CONTROL,
 		.pending		= 0,
 	 },
-#if defined (CONFIG_RALINK_RT3883) || defined (CONFIG_RALINK_RT3352)
+#if defined (CONFIG_RALINK_RT3883) || defined (CONFIG_RALINK_RT3352) || defined (CONFIG_RALINK_RT5350)
 	.rt_ep[1] = {
 		.ep = {
 			.name		= "ep1in-int",
@@ -1593,7 +1619,7 @@
 	 },
 	 */
 
-#elif defined (CONFIG_RALINK_RT5350)
+#else //if defined (CONFIG_RALINK_RT5350)
 	.rt_ep[1] = {
 		.ep = {
 			.name		= "ep1in-bulk",
@@ -1667,6 +1693,10 @@
 
 	D_INI(rt_usb->dev, "<%s> registered gadget driver '%s'\n", __func__, driver->driver.name);
 	rt_udc_enable(rt_usb);
+
+	/* Restore "disconnect" bit */
+	usb_write(USBCS, usb_read(USBCS) & (~USBCS_DISCON));
+
 	return 0;
 
 fail:
@@ -1804,14 +1834,14 @@
 	u32 val;
 
 	val = le32_to_cpu(*(volatile u_long *)(0xB0000030));
-	val = val | 0x00040000;
+	val = val | 0x00140000;
 	*(volatile u_long *)(0xB0000030) = cpu_to_le32(val);
-	udelay(10000);	// enable port0 Phy clock
+	udelay(10000);	// enable port0&1 Phy clock
 
 	val = le32_to_cpu(*(volatile u_long *)(0xB0000034));
-	val = val & 0xFDFFFFFF;
+	val = val & 0xFDBFFFFF;
 	*(volatile u_long *)(0xB0000034) = cpu_to_le32(val);
-	udelay(10000);	// toggle reset bit 25 to 0. UDEV_RST -> 0
+	udelay(10000);	// toggle reset bit 22&25 to 0. UDEV_RST & UHST_RST -> 0
 }
 
 /*----------------------------------------------------------------------------*/
@@ -1877,3 +1907,4 @@
 MODULE_AUTHOR("Ying Yuan Huang <yy_huang@ralinktech.com>");
 MODULE_LICENSE("GPL");
 MODULE_ALIAS("platform:rt_udc");
+
diff -ub a/drivers/usb/gadget/rt_udc.h b/drivers/usb/gadget/rt_udc.h
--- a/drivers/usb/gadget/rt_udc.h	2014-09-18 15:05:58.678860765 +0700
+++ b/drivers/usb/gadget/rt_udc.h	2014-09-17 10:57:15.672959000 +0700
@@ -25,8 +25,8 @@
 #define IN_EP_NUM		2
 #define OUT_EP_NUM		2
 #elif defined (CONFIG_RALINK_RT5350)
-#define IN_EP_NUM		1
-#define OUT_EP_NUM		1
+#define IN_EP_NUM		2//1
+#define OUT_EP_NUM		2//1
 #else
 #error "Please define a platform."
 #endif
@@ -126,6 +126,9 @@
 #define ENDPRST_TOGRST	(0x1 << 5)
 #define ENDPRST_FIFORST	(0x1 << 6)
 
+#define USBCS                   (0x1A3)
+#define USBCS_DISCON            (0x1 << 6)
+
 #define FIFOCTRL		(0x1A8)
 
 #define EP_CS_EP0_STALL		(0x1 << 0)
@@ -343,7 +346,7 @@
 static void handle_pending_epoutirq(struct rt_udc_struct *rt_usb, struct rt_ep_struct *rt_ep, struct rt_request *req);
 
 /* Debug macros */
-#ifdef DEBUG
+#if 1 //def DEBUG
 #define DEBUG_REQ
 #define DEBUG_TRX
 #define DEBUG_INIT
diff -ub a/drivers/usb/gadget/serial.c b/drivers/usb/gadget/serial.c 
--- a/drivers/usb/gadget/serial.c	2014-09-18 15:05:58.678860765 +0700
+++ b/drivers/usb/gadget/serial.c	2014-09-17 10:57:15.648959000 +0700
@@ -82,7 +82,10 @@
 
 #define GS_CLOSE_TIMEOUT		15
 
-#define GS_DEFAULT_USE_ACM		0
+//WNC_Roger 20140417 enable ACM control interface
+//#define GS_DEFAULT_USE_ACM		0
+#define GS_DEFAULT_USE_ACM		1
+//WNC
 
 #define GS_DEFAULT_DTE_RATE		9600
 #define GS_DEFAULT_DATA_BITS		8
@@ -178,6 +181,23 @@
 	struct gs_port		*dev_port[GS_NUM_PORTS]; /* the ports */
 };
 
+//WNC_Roger 20140417 enable ACM control interface
+/* this is the data that is passed to the flow control timeout routine */
+struct push_data_s {
+        struct usb_ep *ep;
+        struct usb_request *req;
+};
+/* 
+ * The serial gadget does not support flow controlling the USB host.
+ * This means that the flip buffer can overflow, corrupting the
+ * transfer. We start a timer when there is not enough room in
+ * the flip buffer, and upon timeout, check again and enqueue
+ * or restart the timer. The ep_queue function is simply not
+ * called if we have to throttle the host. When it is time
+ * to unblock we start calling ep_queue again.
+ */
+static struct push_data_s push_data;
+//WNC
 
 /* Functions */
 
@@ -185,6 +205,11 @@
 static int __init gs_module_init(void);
 static void __exit gs_module_exit(void);
 
+//WNC_Roger 20140417 enable ACM control interface
+static struct timer_list push_timer;
+static void push_timeout(unsigned long arg);
+//WNC
+
 /* tty driver */
 static int gs_open(struct tty_struct *tty, struct file *file);
 static void gs_close(struct tty_struct *tty, struct file *file);
@@ -559,7 +584,10 @@
 MODULE_PARM_DESC(write_buf_size, "Write buffer size, default=8192");
 
 module_param(use_acm, uint, S_IRUGO);
-MODULE_PARM_DESC(use_acm, "Use CDC ACM, 0=no, 1=yes, default=no");
+//WNC_Roger 20140417 enable ACM control interface
+//MODULE_PARM_DESC(use_acm, "Use CDC ACM, 0=no, 1=yes, default=no");
+MODULE_PARM_DESC(use_acm, "Use CDC ACM, 0=no, 1=yes, default=yes");
+//WNC
 
 module_init(gs_module_init);
 module_exit(gs_module_exit);
@@ -574,6 +602,12 @@
 	int i;
 	int retval;
 
+//WNC_Roger 20140417 enable ACM control interface
+    // Initialize the flow control timer
+    init_timer(&push_timer);
+    push_timer.function = push_timeout;
+//WNC
+
 	retval = usb_gadget_register_driver(&gs_gadget_driver);
 	if (retval) {
 		printk(KERN_ERR "gs_module_init: cannot register gadget driver, ret=%d\n", retval);
@@ -1243,7 +1277,14 @@
 	}
 
 	len = tty_buffer_request_room(tty, size);
-	if (len > 0) {
+//WNC_Roger 20140417 enable ACM control interface
+//	if (len > 0) {
+	if (len < size) {
+		ret = 1;       // insufficient room
+		goto exit;
+    }
+    if (size > 0) {
+//WNC
 		tty_insert_flip_string(tty, packet, len);
 		tty_flip_buffer_push(port->port_tty);
 		wake_up_interruptible(&port->port_tty->read_wait);
@@ -1254,6 +1295,33 @@
 	return ret;
 }
 
+//WNC_Roger 20140417 enable ACM control interface
+/*
+* push_timeout - see if it is time to unblock the host in the OUT
+* direction, or wait some more.
+* Note that this should only be called for the OUT endpoint.
+*/
+static void push_timeout(unsigned long arg)
+{
+    int ret;
+    struct push_data_s *datap = (struct push_data_s *)arg;
+    if (1 == gs_recv_packet(
+             datap->ep->driver_data, 
+             datap->req->buf, 
+             datap->req->actual)) {
+            // insufficient room - start a timer and check later
+            push_timer.expires = jiffies + 1;
+            add_timer(&push_timer); 
+            datap->req->no_interrupt = 1;  // core can NOT enable out interrupts now.
+            return;
+    } 
+    datap->req->length = datap->ep->maxpacket;
+    if ((ret=usb_ep_queue(datap->ep, datap->req, GFP_ATOMIC))) {
+            printk(KERN_ERR "push_timeout: cannot queue read request, ret=%d\n", ret);
+    }
+}
+//WNC
+
 /*
 * gs_read_complete
 */
@@ -1270,7 +1338,18 @@
 	switch(req->status) {
 	case 0:
  		/* normal completion */
-		gs_recv_packet(dev, req->buf, req->actual);
+//WNC_Roger 20140417 enable ACM control interface
+//		gs_recv_packet(dev, req->buf, req->actual);
+		if (1 == gs_recv_packet(dev, req->buf, req->actual)) {
+            // insufficient room - start a timer and check later
+            push_data.ep = ep;
+            push_data.req = req;
+            push_timer.data = (unsigned long) &push_data;
+            push_timer.expires = jiffies + 1;
+            add_timer(&push_timer); 
+            return;
+        } 
+//WNC
 requeue:
 		req->length = ep->maxpacket;
 		if ((ret=usb_ep_queue(ep, req, GFP_ATOMIC))) {
@@ -1378,12 +1457,16 @@
 
 	usb_ep_autoconfig_reset(gadget);
 
+    printk("%s usb_ep_autoconfig gs_fullspeed_in_desc \n", __FUNCTION__);
+
 	ep = usb_ep_autoconfig(gadget, &gs_fullspeed_in_desc);
 	if (!ep)
 		goto autoconf_fail;
 	EP_IN_NAME = ep->name;
 	ep->driver_data = ep;	/* claim the endpoint */
 
+    printk("%s usb_ep_autoconfig gs_fullspeed_out_desc \n", __FUNCTION__);
+
 	ep = usb_ep_autoconfig(gadget, &gs_fullspeed_out_desc);
 	if (!ep)
 		goto autoconf_fail;
@@ -1391,6 +1474,9 @@
 	ep->driver_data = ep;	/* claim the endpoint */
 
 	if (use_acm) {
+
+    printk("%s usb_ep_autoconfig gs_fullspeed_notify_desc \n", __FUNCTION__);
+
 		ep = usb_ep_autoconfig(gadget, &gs_fullspeed_notify_desc);
 		if (!ep) {
 			printk(KERN_ERR "gs_bind: cannot run ACM on %s\n", gadget->name);
diff --git a/drivers/usb/host/Kconfig b/drivers/usb/host/Kconfig
index 6271187..9425eb9 100644
--- a/drivers/usb/host/Kconfig
+++ b/drivers/usb/host/Kconfig
@@ -29,6 +29,11 @@ config USB_EHCI_HCD
 	  To compile this driver as a module, choose M here: the
 	  module will be called ehci-hcd.
 
+config RT3XXX_EHCI
+	bool "Ralink EHCI HCD support"
+	depends on USB_EHCI_HCD
+	default y
+
 config USB_EHCI_SPLIT_ISO
 	bool "Full speed ISO transactions (EXPERIMENTAL)"
 	depends on USB_EHCI_HCD && EXPERIMENTAL
@@ -102,6 +107,11 @@ config USB_OHCI_HCD
 	  To compile this driver as a module, choose M here: the
 	  module will be called ohci-hcd.
 
+config RT3XXX_OHCI
+	bool "Ralink OHCI HCD support"
+	depends on USB_OHCI_HCD
+	default y
+
 config USB_OHCI_HCD_PPC_SOC
 	bool "OHCI support for on-chip PPC USB controller"
 	depends on USB_OHCI_HCD && (STB03xxx || PPC_MPC52xx)
diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index c7458f7..cc5afac 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -936,6 +936,11 @@ MODULE_LICENSE ("GPL");
 #define	PLATFORM_DRIVER		ehci_hcd_au1xxx_driver
 #endif
 
+#if defined (CONFIG_RT3XXX_EHCI) || defined (CONFIG_RT3XXX_EHCI_MODULE)
+#include "ehci-rt3xxx.c"
+#define PLATFORM_DRIVER     rt3xxx_ehci_driver
+#endif
+
 #ifdef CONFIG_PPC_PS3
 #include "ehci-ps3.c"
 #define	PS3_SYSTEM_BUS_DRIVER	ps3_ehci_sb_driver
diff --git a/drivers/usb/host/ehci-q.c b/drivers/usb/host/ehci-q.c
index e7fbbd0..4930822 100644
--- a/drivers/usb/host/ehci-q.c
+++ b/drivers/usb/host/ehci-q.c
@@ -1068,8 +1068,14 @@ static void scan_async (struct ehci_hcd *ehci)
 	struct ehci_qh		*qh;
 	enum ehci_timer_action	action = TIMER_IO_WATCHDOG;
 
+#if 1
+    ehci->stamp = ehci_readl(ehci, &ehci->regs->frame_index);
+#else
 	if (!++(ehci->stamp))
 		ehci->stamp++;
+#endif
+
+
 	timer_action_done (ehci, TIMER_ASYNC_SHRINK);
 rescan:
 	qh = ehci->async->qh_next.qh;
@@ -1101,11 +1107,19 @@ rescan:
 			 * (plus, avoids some kind of re-activation race.)
 			 */
 			if (list_empty (&qh->qtd_list)) {
+#if 1
+         if (!ehci->reclaim && ((ehci->stamp - qh->stamp) & 0x1fff)>= ( 10 /* EHCI_SHRINK_FRAMES == 5 */ * 8)
+         	 && (qh->qh_state == QH_STATE_LINKED || qh->qh_state == QH_STATE_UNLINK_WAIT) )
+             start_unlink_async(ehci, qh);
+         else
+             action = TIMER_ASYNC_SHRINK;
+#else
 				if (qh->stamp == ehci->stamp)
 					action = TIMER_ASYNC_SHRINK;
 				else if (!ehci->reclaim
 					    && qh->qh_state == QH_STATE_LINKED)
 					start_unlink_async (ehci, qh);
+#endif
 			}
 
 			qh = qh->qh_next.qh;
diff --git a/drivers/usb/host/ehci-sched.c b/drivers/usb/host/ehci-sched.c
index 7b5ae71..913a05f 100644
--- a/drivers/usb/host/ehci-sched.c
+++ b/drivers/usb/host/ehci-sched.c
@@ -1926,6 +1926,86 @@ sitd_link_urb (
 #define	SITD_ERRS (SITD_STS_ERR | SITD_STS_DBE | SITD_STS_BABBLE \
 				| SITD_STS_XACT | SITD_STS_MMF)
 
+#define CONFIG_FIX_SITD
+#ifdef CONFIG_FIX_SITD
+static unsigned
+sitd_complete (
+	struct ehci_hcd		*ehci,
+	struct ehci_sitd	*sitd
+) {
+	struct urb				*urb = sitd->urb;
+	struct usb_iso_packet_descriptor	*desc;
+	u32					t;
+	int					urb_index = -1;
+	struct ehci_iso_stream			*stream = sitd->stream;
+	struct usb_device			*dev;
+	unsigned				retval = false;
+
+	urb_index = sitd->index;
+	desc = &urb->iso_frame_desc [urb_index];
+	t = le32_to_cpup (&sitd->hw_results);
+
+	/* report transfer status */
+	if (t & SITD_ERRS) {
+		urb->error_count++;
+		if (t & SITD_STS_DBE)
+			desc->status = usb_pipein (urb->pipe)
+				? -ENOSR  /* hc couldn't read */
+				: -ECOMM; /* hc couldn't write */
+		else if (t & SITD_STS_BABBLE)
+			desc->status = -EOVERFLOW;
+		else /* XACT, MMF, etc */
+			desc->status = -EPROTO;
+	} else {
+		desc->status = 0;
+		desc->actual_length = desc->length - SITD_LENGTH (t);
+	}
+
+	usb_put_urb (urb);
+	sitd->urb = NULL;
+	sitd->stream = NULL;
+	stream->depth -= stream->interval << 3;
+
+
+	/* handle completion now? */
+	if ((urb_index + 1) != urb->number_of_packets)
+		goto done;
+
+	/* ASSERT: it's really the last sitd for this urb
+	list_for_each_entry (sitd, &stream->td_list, sitd_list)
+		BUG_ON (sitd->urb == urb);
+	 */
+
+	/* give urb back to the driver */
+	dev = urb->dev;
+	ehci_urb_done (ehci, urb);
+	retval = true;
+	urb = NULL;
+
+	/* defer stopping schedule; completion can submit */
+	ehci->periodic_sched--;
+	if (!ehci->periodic_sched)
+		(void) disable_periodic (ehci);
+	ehci_to_hcd(ehci)->self.bandwidth_isoc_reqs--;
+
+	if (list_empty (&stream->td_list)) {
+		ehci_to_hcd(ehci)->self.bandwidth_allocated
+				-= stream->bandwidth;
+		ehci_vdbg (ehci,
+			"deschedule devp %s ep%d%s-iso\n",
+			dev->devpath, stream->bEndpointAddress & 0x0f,
+			(stream->bEndpointAddress & USB_DIR_IN) ? "in" : "out");
+	}
+	iso_stream_put (ehci, stream);
+
+done:
+	list_move (&sitd->sitd_list, &stream->free_list);
+	iso_stream_put (ehci, stream);
+	return retval;
+}
+
+#else
+
 static unsigned
 sitd_complete (
 	struct ehci_hcd		*ehci,
@@ -1997,7 +2077,7 @@ sitd_complete (
 
 	return 1;
 }
-
+#endif
 
 static int sitd_submit (struct ehci_hcd *ehci, struct urb *urb,
 	gfp_t mem_flags)
diff --git a/drivers/usb/host/ohci-hcd.c b/drivers/usb/host/ohci-hcd.c
index f0d29ed..d078231 100644
--- a/drivers/usb/host/ohci-hcd.c
+++ b/drivers/usb/host/ohci-hcd.c
@@ -916,6 +916,10 @@ MODULE_LICENSE ("GPL");
 #define PLATFORM_DRIVER		usb_hcd_pnx4008_driver
 #endif
 
+#if defined (CONFIG_RT3XXX_OHCI) || defined (CONFIG_RT3XXX_OHCI_MODULE)
+#include "ohci-rt3xxx.c"
+#define PLATFORM_DRIVER     ohci_hcd_rt3xxx_driver
+#endif
 
 #ifdef CONFIG_USB_OHCI_HCD_PPC_OF
 #include "ohci-ppc-of.c"
diff --git a/drivers/usb/serial/Kconfig b/drivers/usb/serial/Kconfig
index 2f4d303..dffdbde 100644
--- a/drivers/usb/serial/Kconfig
+++ b/drivers/usb/serial/Kconfig
@@ -62,6 +62,11 @@ config USB_SERIAL_AIRCABLE
 	    To compile this driver as a module, choose M here: the module
 	    will be called aircable.
 
+config USB_SERIAL_HSO
+	tristate "USB driver for Option High Speed Mobile Devices"
+	depends on USB_SERIAL
+	help
+
 config USB_SERIAL_AIRPRIME
 	tristate "USB AirPrime CDMA Wireless Driver"
 	depends on USB_SERIAL
diff --git a/drivers/usb/serial/Makefile b/drivers/usb/serial/Makefile
index 61166ad..1309a63 100644
--- a/drivers/usb/serial/Makefile
+++ b/drivers/usb/serial/Makefile
@@ -47,4 +47,5 @@ obj-$(CONFIG_USB_SERIAL_TI)			+= ti_usb_3410_5052.o
 obj-$(CONFIG_USB_SERIAL_VISOR)			+= visor.o
 obj-$(CONFIG_USB_SERIAL_WHITEHEAT)		+= whiteheat.o
 obj-$(CONFIG_USB_SERIAL_XIRCOM)			+= keyspan_pda.o
+obj-$(CONFIG_USB_SERIAL_HSO)			+= hso.o
 
diff --git a/drivers/usb/serial/option.c b/drivers/usb/serial/option.c
index e178e6f..b0c8bb3 100644
--- a/drivers/usb/serial/option.c
+++ b/drivers/usb/serial/option.c
@@ -107,9 +107,139 @@ static int  option_send_setup(struct usb_serial_port *port);
 #define HUAWEI_VENDOR_ID			0x12D1
 #define HUAWEI_PRODUCT_E600			0x1001
 #define HUAWEI_PRODUCT_E220			0x1003
+#define HUAWEI_PRODUCT_E220BIS			0x1004
+#define HUAWEI_PRODUCT_E1401			0x1401
+#define HUAWEI_PRODUCT_E1403			0x1403
+#define HUAWEI_PRODUCT_E1405			0x1405
+#define HUAWEI_PRODUCT_E1406			0x1406
+#define HUAWEI_PRODUCT_E1408			0x1408
+#define HUAWEI_PRODUCT_E1409			0x1409
+#define HUAWEI_PRODUCT_E1410			0x1410
+#define HUAWEI_PRODUCT_E1411			0x1411
+#define HUAWEI_PRODUCT_E1412			0x1412
+#define HUAWEI_PRODUCT_E1413			0x1413
+#define HUAWEI_PRODUCT_E1414			0x1414
+#define HUAWEI_PRODUCT_E1415			0x1415
+#define HUAWEI_PRODUCT_E1416			0x1416
+#define HUAWEI_PRODUCT_E1417			0x1417
+#define HUAWEI_PRODUCT_E1418			0x1418
+#define HUAWEI_PRODUCT_E1419			0x1419
+
+#define DATANG_VENDOR_ID			0x1ab7
+#define DATANG_PRODUCT_M5731			0x5731
+
+#define BANDLUXE_VENDOR_ID			0x1a8d
+#define BANDLUXE_PRODUCT_C270			0x1009
+
+#define ALCATEL_VENDOR_ID			0x05c6
+#define ALCATEL_PRODUCT_C820			0x00a0
+
+#define DLINK_VENDOR_ID				0x1186
+#define DLINK_PRODUCT_DWM652			0x3e04
+
+#define MU_VENDOR_ID				0x0408
+#define MU_PRODUCT_Q101_MODEM			0xea02
+#define MU_PRODUCT_Q101				0x1000
 
 #define NOVATELWIRELESS_VENDOR_ID		0x1410
 
+/* MERLIN EVDO PRODUCTS */
+#define NOVATELWIRELESS_PRODUCT_V640		0x1100
+#define NOVATELWIRELESS_PRODUCT_V620		0x1110
+#define NOVATELWIRELESS_PRODUCT_V740		0x1120
+#define NOVATELWIRELESS_PRODUCT_V720		0x1130
+
+/* MERLIN HSDPA/HSPA PRODUCTS */
+#define NOVATELWIRELESS_PRODUCT_U730		0x1400
+#define NOVATELWIRELESS_PRODUCT_U740		0x1410
+#define NOVATELWIRELESS_PRODUCT_U870		0x1420
+#define NOVATELWIRELESS_PRODUCT_XU870		0x1430
+#define NOVATELWIRELESS_PRODUCT_X950D		0x1450
+
+/* EXPEDITE PRODUCTS */
+#define NOVATELWIRELESS_PRODUCT_EV620		0x2100
+#define NOVATELWIRELESS_PRODUCT_ES720		0x2110
+#define NOVATELWIRELESS_PRODUCT_E725		0x2120
+#define NOVATELWIRELESS_PRODUCT_ES620		0x2130
+#define NOVATELWIRELESS_PRODUCT_EU730		0x2400
+#define NOVATELWIRELESS_PRODUCT_EU740		0x2410
+#define NOVATELWIRELESS_PRODUCT_EU870D		0x2420
+
+/* OVATION PRODUCTS */
+#define NOVATELWIRELESS_PRODUCT_MC727		0x4100
+#define NOVATELWIRELESS_PRODUCT_MC950D		0x4400
+
+/* FUTURE NOVATEL PRODUCTS */
+#define NOVATELWIRELESS_PRODUCT_EVDO_1		0x6000
+#define NOVATELWIRELESS_PRODUCT_HSPA_1		0x7000
+#define NOVATELWIRELESS_PRODUCT_EMBEDDED_1	0x8000
+#define NOVATELWIRELESS_PRODUCT_GLOBAL_1	0x9000
+#define NOVATELWIRELESS_PRODUCT_EVDO_2		0x6001
+#define NOVATELWIRELESS_PRODUCT_HSPA_2		0x7001
+#define NOVATELWIRELESS_PRODUCT_EMBEDDED_2	0x8001
+#define NOVATELWIRELESS_PRODUCT_GLOBAL_2	0x9001
+
+/* AMOI PRODUCTS */
+#define AMOI_VENDOR_ID				0x1614
+#define AMOI_PRODUCT_H01			0x0800
+#define AMOI_PRODUCT_H01A			0x7002
+#define AMOI_PRODUCT_H02			0x0802
+
+#define DELL_VENDOR_ID				0x413C
+
+#define KYOCERA_VENDOR_ID			0x0c88
+#define KYOCERA_PRODUCT_KPC650			0x17da
+#define KYOCERA_PRODUCT_KPC680			0x180a
+
+#define ANYDATA_VENDOR_ID			0x16d5
+#define ANYDATA_PRODUCT_ADU_620UW		0x6202
+#define ANYDATA_PRODUCT_ADU_E100A		0x6501
+#define ANYDATA_PRODUCT_ADU_500A		0x6502
+
+#define AXESSTEL_VENDOR_ID			0x1726
+#define AXESSTEL_PRODUCT_MV110H			0x1000
+
+#define ONDA_VENDOR_ID				0x19d2
+#define ONDA_PRODUCT_MSA501HS			0x0001
+#define ONDA_PRODUCT_ET502HS			0x0002
+
+#define BANDRICH_VENDOR_ID			0x1A8D
+#define BANDRICH_PRODUCT_C100_1			0x1002
+#define BANDRICH_PRODUCT_C100_2			0x1003
+#define BANDRICH_PRODUCT_1004			0x1004
+#define BANDRICH_PRODUCT_1005			0x1005
+#define BANDRICH_PRODUCT_1006			0x1006
+#define BANDRICH_PRODUCT_1007			0x1007
+#define BANDRICH_PRODUCT_1008			0x1008
+#define BANDRICH_PRODUCT_1009			0x1009
+#define BANDRICH_PRODUCT_100A			0x100a
+
+#define BANDRICH_PRODUCT_100B			0x100b
+#define BANDRICH_PRODUCT_100C			0x100c
+#define BANDRICH_PRODUCT_100D			0x100d
+#define BANDRICH_PRODUCT_100E			0x100e
+
+#define BANDRICH_PRODUCT_100F			0x100f
+#define BANDRICH_PRODUCT_1010			0x1010
+#define BANDRICH_PRODUCT_1011			0x1011
+#define BANDRICH_PRODUCT_1012			0x1012
+
+#define AMOI_VENDOR_ID			0x1614
+#define AMOI_PRODUCT_9508			0x0800
+
+#define QUALCOMM_VENDOR_ID			0x05C6
+
+#define MAXON_VENDOR_ID				0x16d8
+
+#define TELIT_VENDOR_ID				0x1bc7
+#define TELIT_PRODUCT_UC864E			0x1003
+
+/* ZTE PRODUCTS */
+#define ZTE_VENDOR_ID				0x19d2
+#define ZTE_PRODUCT_MF628			0x0015
+#define ZTE_PRODUCT_CDMA_TECH			0xfffe
+#define ZTE_PRODUCT_CDMA_TECH2			0x0003
+
 #define ANYDATA_VENDOR_ID			0x16d5
 #define ANYDATA_PRODUCT_ID			0x6501
 
@@ -151,20 +281,104 @@ static struct usb_device_id option_ids[] = {
 	{ USB_DEVICE(OPTION_VENDOR_ID, OPTION_PRODUCT_ETNA_KOI_NETWORK) },
 	{ USB_DEVICE(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_E600) },
 	{ USB_DEVICE(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_E220) },
-	{ USB_DEVICE(NOVATELWIRELESS_VENDOR_ID, 0x1100) }, /* Novatel Merlin XS620/S640 */
-	{ USB_DEVICE(NOVATELWIRELESS_VENDOR_ID, 0x1110) }, /* Novatel Merlin S620 */
-	{ USB_DEVICE(NOVATELWIRELESS_VENDOR_ID, 0x1120) }, /* Novatel Merlin EX720 */
-	{ USB_DEVICE(NOVATELWIRELESS_VENDOR_ID, 0x1130) }, /* Novatel Merlin S720 */
-	{ USB_DEVICE(NOVATELWIRELESS_VENDOR_ID, 0x1400) }, /* Novatel U730 */
-	{ USB_DEVICE(NOVATELWIRELESS_VENDOR_ID, 0x1410) }, /* Novatel U740 */
-	{ USB_DEVICE(NOVATELWIRELESS_VENDOR_ID, 0x1420) }, /* Novatel EU870 */
-	{ USB_DEVICE(NOVATELWIRELESS_VENDOR_ID, 0x1430) }, /* Novatel Merlin XU870 HSDPA/3G */
-	{ USB_DEVICE(NOVATELWIRELESS_VENDOR_ID, 0x1430) }, /* Novatel XU870 */
-	{ USB_DEVICE(NOVATELWIRELESS_VENDOR_ID, 0x2100) }, /* Novatel EV620 CDMA/EV-DO */
-	{ USB_DEVICE(NOVATELWIRELESS_VENDOR_ID, 0x2110) }, /* Novatel Merlin ES620 / Merlin ES720 / Ovation U720 */
-	{ USB_DEVICE(NOVATELWIRELESS_VENDOR_ID, 0x2130) }, /* Novatel Merlin ES620 SM Bus */
-	{ USB_DEVICE(NOVATELWIRELESS_VENDOR_ID, 0x2410) }, /* Novatel EU740 */
-	{ USB_DEVICE(ANYDATA_VENDOR_ID, ANYDATA_PRODUCT_ID) },
+	{ USB_DEVICE(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_E220BIS) },
+	{ USB_DEVICE(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_E1401) },
+	{ USB_DEVICE(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_E1403) },
+	{ USB_DEVICE(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_E1405) },
+	{ USB_DEVICE(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_E1406) },
+	{ USB_DEVICE(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_E1408) },
+	{ USB_DEVICE(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_E1409) },
+	{ USB_DEVICE(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_E1410) },
+	{ USB_DEVICE(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_E1411) },
+	{ USB_DEVICE(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_E1412) },
+	{ USB_DEVICE(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_E1413) },
+	{ USB_DEVICE(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_E1414) },
+	{ USB_DEVICE(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_E1415) },
+	{ USB_DEVICE(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_E1416) },
+	{ USB_DEVICE(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_E1417) },
+	{ USB_DEVICE(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_E1418) },
+	{ USB_DEVICE(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_E1419) },
+	{ USB_DEVICE(BANDLUXE_VENDOR_ID, BANDLUXE_PRODUCT_C270) },
+	{ USB_DEVICE(DATANG_VENDOR_ID, DATANG_PRODUCT_M5731) },
+	{ USB_DEVICE(ALCATEL_VENDOR_ID, ALCATEL_PRODUCT_C820) },
+	{ USB_DEVICE(MU_VENDOR_ID, MU_PRODUCT_Q101) },
+	{ USB_DEVICE(DLINK_VENDOR_ID, DLINK_PRODUCT_DWM652) },
+	{ USB_DEVICE(MU_VENDOR_ID, MU_PRODUCT_Q101_MODEM) },
+	{ USB_DEVICE(AMOI_VENDOR_ID, AMOI_PRODUCT_9508) },
+	{ USB_DEVICE(NOVATELWIRELESS_VENDOR_ID, NOVATELWIRELESS_PRODUCT_V640) }, /* Novatel Merlin V640/XV620 */
+	{ USB_DEVICE(NOVATELWIRELESS_VENDOR_ID, NOVATELWIRELESS_PRODUCT_V620) }, /* Novatel Merlin V620/S620 */
+	{ USB_DEVICE(NOVATELWIRELESS_VENDOR_ID, NOVATELWIRELESS_PRODUCT_V740) }, /* Novatel Merlin EX720/V740/X720 */
+	{ USB_DEVICE(NOVATELWIRELESS_VENDOR_ID, NOVATELWIRELESS_PRODUCT_V720) }, /* Novatel Merlin V720/S720/PC720 */
+	{ USB_DEVICE(NOVATELWIRELESS_VENDOR_ID, NOVATELWIRELESS_PRODUCT_U730) }, /* Novatel U730/U740 (VF version) */
+	{ USB_DEVICE(NOVATELWIRELESS_VENDOR_ID, NOVATELWIRELESS_PRODUCT_U740) }, /* Novatel U740 */
+	{ USB_DEVICE(NOVATELWIRELESS_VENDOR_ID, NOVATELWIRELESS_PRODUCT_U870) }, /* Novatel U870 */
+	{ USB_DEVICE(NOVATELWIRELESS_VENDOR_ID, NOVATELWIRELESS_PRODUCT_XU870) }, /* Novatel Merlin XU870 HSDPA/3G */
+	{ USB_DEVICE(NOVATELWIRELESS_VENDOR_ID, NOVATELWIRELESS_PRODUCT_X950D) }, /* Novatel X950D */
+	{ USB_DEVICE(NOVATELWIRELESS_VENDOR_ID, NOVATELWIRELESS_PRODUCT_EV620) }, /* Novatel EV620/ES620 CDMA/EV-DO */
+	{ USB_DEVICE(NOVATELWIRELESS_VENDOR_ID, NOVATELWIRELESS_PRODUCT_ES720) }, /* Novatel ES620/ES720/U720/USB720 */
+	{ USB_DEVICE(NOVATELWIRELESS_VENDOR_ID, NOVATELWIRELESS_PRODUCT_E725) }, /* Novatel E725/E726 */
+	{ USB_DEVICE(NOVATELWIRELESS_VENDOR_ID, NOVATELWIRELESS_PRODUCT_ES620) }, /* Novatel Merlin ES620 SM Bus */
+	{ USB_DEVICE(NOVATELWIRELESS_VENDOR_ID, NOVATELWIRELESS_PRODUCT_EU730) }, /* Novatel EU730 and Vodafone EU740 */
+	{ USB_DEVICE(NOVATELWIRELESS_VENDOR_ID, NOVATELWIRELESS_PRODUCT_EU740) }, /* Novatel non-Vodafone EU740 */
+	{ USB_DEVICE(NOVATELWIRELESS_VENDOR_ID, NOVATELWIRELESS_PRODUCT_EU870D) }, /* Novatel EU850D/EU860D/EU870D */
+	{ USB_DEVICE(NOVATELWIRELESS_VENDOR_ID, NOVATELWIRELESS_PRODUCT_MC950D) }, /* Novatel MC930D/MC950D */
+	{ USB_DEVICE(NOVATELWIRELESS_VENDOR_ID, NOVATELWIRELESS_PRODUCT_MC727) }, /* Novatel MC727/U727/USB727 */
+	{ USB_DEVICE(NOVATELWIRELESS_VENDOR_ID, NOVATELWIRELESS_PRODUCT_EVDO_1) }, /* Novatel EVDO product */
+	{ USB_DEVICE(NOVATELWIRELESS_VENDOR_ID, NOVATELWIRELESS_PRODUCT_HSPA_1) }, /* Novatel HSPA product */
+	{ USB_DEVICE(NOVATELWIRELESS_VENDOR_ID, NOVATELWIRELESS_PRODUCT_EMBEDDED_1) }, /* Novatel Embedded product */
+	{ USB_DEVICE(NOVATELWIRELESS_VENDOR_ID, NOVATELWIRELESS_PRODUCT_GLOBAL_1) }, /* Novatel Global product */
+	{ USB_DEVICE(NOVATELWIRELESS_VENDOR_ID, NOVATELWIRELESS_PRODUCT_EVDO_2) }, /* Novatel EVDO product */
+	{ USB_DEVICE(NOVATELWIRELESS_VENDOR_ID, NOVATELWIRELESS_PRODUCT_HSPA_2) }, /* Novatel HSPA product */
+	{ USB_DEVICE(NOVATELWIRELESS_VENDOR_ID, NOVATELWIRELESS_PRODUCT_EMBEDDED_2) }, /* Novatel Embedded product */
+	{ USB_DEVICE(NOVATELWIRELESS_VENDOR_ID, NOVATELWIRELESS_PRODUCT_GLOBAL_2) }, /* Novatel Global product */
+
+	{ USB_DEVICE(AMOI_VENDOR_ID, AMOI_PRODUCT_H01) },
+	{ USB_DEVICE(AMOI_VENDOR_ID, AMOI_PRODUCT_H01A) },
+	{ USB_DEVICE(AMOI_VENDOR_ID, AMOI_PRODUCT_H02) },
+
+	{ USB_DEVICE(DELL_VENDOR_ID, 0x8114) },	/* Dell Wireless 5700 Mobile Broadband CDMA/EVDO Mini-Card == Novatel Expedite EV620 CDMA/EV-DO */
+	{ USB_DEVICE(DELL_VENDOR_ID, 0x8115) },	/* Dell Wireless 5500 Mobile Broadband HSDPA Mini-Card == Novatel Expedite EU740 HSDPA/3G */
+	{ USB_DEVICE(DELL_VENDOR_ID, 0x8116) },	/* Dell Wireless 5505 Mobile Broadband HSDPA Mini-Card == Novatel Expedite EU740 HSDPA/3G */
+	{ USB_DEVICE(DELL_VENDOR_ID, 0x8117) },	/* Dell Wireless 5700 Mobile Broadband CDMA/EVDO ExpressCard == Novatel Merlin XV620 CDMA/EV-DO */
+	{ USB_DEVICE(DELL_VENDOR_ID, 0x8118) },	/* Dell Wireless 5510 Mobile Broadband HSDPA ExpressCard == Novatel Merlin XU870 HSDPA/3G */
+	{ USB_DEVICE(DELL_VENDOR_ID, 0x8128) },	/* Dell Wireless 5700 Mobile Broadband CDMA/EVDO Mini-Card == Novatel Expedite E720 CDMA/EV-DO */
+	{ USB_DEVICE(DELL_VENDOR_ID, 0x8129) },	/* Dell Wireless 5700 Mobile Broadband CDMA/EVDO Mini-Card == Novatel Expedite ET620 CDMA/EV-DO */
+	{ USB_DEVICE(DELL_VENDOR_ID, 0x8133) }, /* Dell Wireless 5720 == Novatel EV620 CDMA/EV-DO */
+	{ USB_DEVICE(DELL_VENDOR_ID, 0x8136) },	/* Dell Wireless HSDPA 5520 == Novatel Expedite EU860D */
+	{ USB_DEVICE(DELL_VENDOR_ID, 0x8137) },	/* Dell Wireless HSDPA 5520 */
+	{ USB_DEVICE(DELL_VENDOR_ID, 0x8138) },	/* Dell Wireless 5520 Voda I Mobile Broadband (3G HSDPA) Minicard */
+	{ USB_DEVICE(ANYDATA_VENDOR_ID, ANYDATA_PRODUCT_ADU_E100A) },
+	{ USB_DEVICE(ANYDATA_VENDOR_ID, ANYDATA_PRODUCT_ADU_500A) },
+	{ USB_DEVICE(ANYDATA_VENDOR_ID, ANYDATA_PRODUCT_ADU_620UW) },
+	{ USB_DEVICE(AXESSTEL_VENDOR_ID, AXESSTEL_PRODUCT_MV110H) },
+	{ USB_DEVICE(ONDA_VENDOR_ID, ONDA_PRODUCT_MSA501HS) },
+	{ USB_DEVICE(ONDA_VENDOR_ID, ONDA_PRODUCT_ET502HS) },
+	{ USB_DEVICE(BANDRICH_VENDOR_ID, BANDRICH_PRODUCT_C100_1) },
+	{ USB_DEVICE(BANDRICH_VENDOR_ID, BANDRICH_PRODUCT_C100_2) },
+	{ USB_DEVICE(BANDRICH_VENDOR_ID, BANDRICH_PRODUCT_1004) },
+	{ USB_DEVICE(BANDRICH_VENDOR_ID, BANDRICH_PRODUCT_1005) },
+	{ USB_DEVICE(BANDRICH_VENDOR_ID, BANDRICH_PRODUCT_1006) },
+	{ USB_DEVICE(BANDRICH_VENDOR_ID, BANDRICH_PRODUCT_1007) },
+	{ USB_DEVICE(BANDRICH_VENDOR_ID, BANDRICH_PRODUCT_1008) },
+	{ USB_DEVICE(BANDRICH_VENDOR_ID, BANDRICH_PRODUCT_1009) },
+	{ USB_DEVICE(BANDRICH_VENDOR_ID, BANDRICH_PRODUCT_100A) },
+	{ USB_DEVICE(BANDRICH_VENDOR_ID, BANDRICH_PRODUCT_100B) },
+	{ USB_DEVICE(BANDRICH_VENDOR_ID, BANDRICH_PRODUCT_100C) },
+	{ USB_DEVICE(BANDRICH_VENDOR_ID, BANDRICH_PRODUCT_100D) },
+	{ USB_DEVICE(BANDRICH_VENDOR_ID, BANDRICH_PRODUCT_100E) },
+	{ USB_DEVICE(BANDRICH_VENDOR_ID, BANDRICH_PRODUCT_100F) },
+	{ USB_DEVICE(BANDRICH_VENDOR_ID, BANDRICH_PRODUCT_1010) },
+	{ USB_DEVICE(BANDRICH_VENDOR_ID, BANDRICH_PRODUCT_1011) },
+	{ USB_DEVICE(BANDRICH_VENDOR_ID, BANDRICH_PRODUCT_1012) },
+	{ USB_DEVICE(KYOCERA_VENDOR_ID, KYOCERA_PRODUCT_KPC650) },
+	{ USB_DEVICE(KYOCERA_VENDOR_ID, KYOCERA_PRODUCT_KPC680) },
+	{ USB_DEVICE(QUALCOMM_VENDOR_ID, 0x6000)}, /* ZTE AC8700 */
+	{ USB_DEVICE(QUALCOMM_VENDOR_ID, 0x6613)}, /* Onda H600/ZTE MF330 */
+	{ USB_DEVICE(MAXON_VENDOR_ID, 0x6280) }, /* BP3-USB & BP3-EXT HSDPA */
+	{ USB_DEVICE(TELIT_VENDOR_ID, TELIT_PRODUCT_UC864E) },
+	{ USB_DEVICE(ZTE_VENDOR_ID, ZTE_PRODUCT_MF628) },
+	{ USB_DEVICE(ZTE_VENDOR_ID, ZTE_PRODUCT_CDMA_TECH) },
+	{ USB_DEVICE(ZTE_VENDOR_ID, ZTE_PRODUCT_CDMA_TECH2) },
 	{ } /* Terminating entry */
 };
 MODULE_DEVICE_TABLE(usb, option_ids);
@@ -585,7 +799,6 @@ static int option_open(struct usb_serial_port *port, struct file *filp)
 	}
 
 	port->tty->low_latency = 1;
-
 	option_send_setup(port);
 
 	return (0);
diff --git a/drivers/usb/storage/scsiglue.c b/drivers/usb/storage/scsiglue.c
index e227f64..b621310 100644
--- a/drivers/usb/storage/scsiglue.c
+++ b/drivers/usb/storage/scsiglue.c
@@ -420,6 +420,7 @@ static ssize_t store_max_sectors(struct device *dev, struct device_attribute *at
 	unsigned short ms;
 
 	if (sscanf(buf, "%hu", &ms) > 0 && ms <= SCSI_DEFAULT_MAX_SECTORS) {
+		printk("\n kaiker ==>store_max_sectors [%d] \n",ms);
 		blk_queue_max_sectors(sdev->request_queue, ms);
 		return strlen(buf);
 	}
@@ -466,9 +467,12 @@ struct scsi_host_template usb_stor_host_template = {
 	/* lots of sg segments can be handled */
 	.sg_tablesize =			SG_ALL,
 
-	/* limit the total size of a transfer to 120 KB */
+#ifdef CONFIG_DWC_OTG
+	/* limit the total size of a transfer to 120 KB ,kaiker_240*/
+	.max_sectors =                  1024,
+#else
 	.max_sectors =                  240,
-
+#endif
 	/* merge commands... this seems to help performance, but
 	 * periodically someone should test to see which setting is more
 	 * optimal.
diff --git a/drivers/video/Kconfig b/drivers/video/Kconfig
index 8372ace..5ec4cb0 100644
--- a/drivers/video/Kconfig
+++ b/drivers/video/Kconfig
@@ -1252,6 +1252,17 @@ config FB_VOODOO1
 	  Please read the <file:Documentation/fb/README-sstfb.txt> for supported
 	  options and other important info  support.
 
+config FB_SMIVGX
+	tristate "Silicon Motion VoyagerGX support"
+	depends on FB && PCI && (MIPS || EXPERIMENTAL)
+	select FB_CFB_FILLRECT
+	select FB_CFB_COPYAREA
+	select FB_CFB_IMAGEBLIT
+	---help---
+	  This drivers supports SMI VoyagerGX 501 based PCI boards
+	  The default settings drive both a CRT and LCD.  The CRT
+	  can be turned off by passing in the no_crt option
+
 config FB_CYBLA
 	tristate "Cyberblade/i1 support"
 	depends on FB && PCI && X86_32 && !64BIT
@@ -1316,7 +1327,25 @@ config FB_PM3
 
 config FB_AU1100
 	bool "Au1100 LCD Driver"
-	depends on (FB = y) && EXPERIMENTAL && PCI && MIPS && MIPS_PB1100=y
+	depends on FB && MIPS && SOC_AU1100
+	select FB_CFB_FILLRECT
+	select FB_CFB_COPYAREA
+	select FB_CFB_IMAGEBLIT
+	help
+	  This is the framebuffer driver for the AMD Au1100 SOC.  It can drive
+	  various panels and CRTs by passing in kernel cmd line option
+	  au1100fb:panel=<name>.
+
+config FB_AU1200
+	bool "Au1200 LCD Driver"
+	depends on FB && MIPS && SOC_AU1200
+	select FB_CFB_FILLRECT
+	select FB_CFB_COPYAREA
+	select FB_CFB_IMAGEBLIT
+	help
+	  This is the framebuffer driver for the AMD Au1200 SOC.  It can drive
+	  various panels and CRTs by passing in kernel cmd line option
+	  au1200fb:panel=<name>.
 
 config FB_AU1200
 	bool "Au1200 LCD Driver"
diff --git a/drivers/video/Makefile b/drivers/video/Makefile
index 760305c..7c285bc 100644
--- a/drivers/video/Makefile
+++ b/drivers/video/Makefile
@@ -93,6 +93,7 @@ obj-$(CONFIG_FB_MAXINE)		  += maxinefb.o
 obj-$(CONFIG_FB_TX3912)		  += tx3912fb.o
 obj-$(CONFIG_FB_S1D13XXX)	  += s1d13xxxfb.o
 obj-$(CONFIG_FB_IMX)              += imxfb.o
+obj-$(CONFIG_FB_SMIVGX)		  += smivgxfb.o
 obj-$(CONFIG_FB_S3C2410)	  += s3c2410fb.o
 obj-$(CONFIG_FB_PNX4008_DUM)	  += pnx4008/
 obj-$(CONFIG_FB_PNX4008_DUM_RGB)  += pnx4008/
diff --git a/fs/Kconfig b/fs/Kconfig
index 3c4886b..4dac7d0 100644
--- a/fs/Kconfig
+++ b/fs/Kconfig
@@ -419,6 +419,7 @@ config FS_POSIX_ACL
 
 source "fs/xfs/Kconfig"
 source "fs/gfs2/Kconfig"
+source "fs/yaffs2/Kconfig"
 
 config OCFS2_FS
 	tristate "OCFS2 file system support"
@@ -1371,6 +1372,71 @@ config CRAMFS
 
 	  If unsure, say N.
 
+config SQUASHFS
+	tristate "SquashFS 3.2 - Squashed file system support"
+	select ZLIB_INFLATE
+	help
+	  Saying Y here includes support for SquashFS 3.2 (a Compressed Read-Only File
+	  System).  Squashfs is a highly compressed read-only filesystem for Linux.
+	  It uses zlib compression to compress both files, inodes and directories.
+	  Inodes in the system are very small and all blocks are packed to minimise
+	  data overhead. Block sizes greater than 4K are supported up to a maximum of 64K.
+	  SquashFS 3.1 supports 64 bit filesystems and files (larger than 4GB), full
+	  uid/gid information, hard links and timestamps.
+
+	  Squashfs is intended for general read-only filesystem use, for archival
+	  use (i.e. in cases where a .tar.gz file may be used), and in embedded
+	  systems where low overhead is needed.  Further information and filesystem tools
+	  are available from http://squashfs.sourceforge.net.
+
+	  If you want to compile this as a module ( = code which can be
+	  inserted in and removed from the running kernel whenever you want),
+	  say M here and read <file:Documentation/modules.txt>.  The module
+	  will be called squashfs.  Note that the root file system (the one
+	  containing the directory /) cannot be compiled as a module.
+
+	  If unsure, say N.
+
+config SQUASHFS_EMBEDDED
+
+	bool "Additional options for memory-constrained systems" 
+	depends on SQUASHFS
+	default n
+	help
+	  Saying Y here allows you to specify cache sizes and how Squashfs
+	  allocates memory.  This is only intended for memory constrained
+	  systems.
+
+	  If unsure, say N.
+
+config SQUASHFS_FRAGMENT_CACHE_SIZE
+	int "Number of fragments cached" if SQUASHFS_EMBEDDED
+	depends on SQUASHFS
+	default "3"
+	help
+	  By default SquashFS caches the last 3 fragments read from
+	  the filesystem.  Increasing this amount may mean SquashFS
+	  has to re-read fragments less often from disk, at the expense
+	  of extra system memory.  Decreasing this amount will mean
+	  SquashFS uses less memory at the expense of extra reads from disk.
+
+	  Note there must be at least one cached fragment.  Anything
+	  much more than three will probably not make much difference.
+
+config SQUASHFS_VMALLOC
+	bool "Use Vmalloc rather than Kmalloc" if SQUASHFS_EMBEDDED
+	depends on SQUASHFS
+	default n
+	help
+	  By default SquashFS uses kmalloc to obtain fragment cache memory.
+	  Kmalloc memory is the standard kernel allocator, but it can fail
+	  on memory constrained systems.  Because of the way Vmalloc works,
+	  Vmalloc can succeed when kmalloc fails.  Specifying this option
+	  will make SquashFS always use Vmalloc to allocate the
+	  fragment cache memory.
+
+	  If unsure, say N.
+
 config VXFS_FS
 	tristate "FreeVxFS file system support (VERITAS VxFS(TM) compatible)"
 	depends on BLOCK
@@ -1528,7 +1594,7 @@ menu "Network File Systems"
 
 config NFS_FS
 	tristate "NFS file system support"
-	depends on INET
+	depends on INET && FILE_LOCKING
 	select LOCKD
 	select SUNRPC
 	select NFS_ACL_SUPPORT if NFS_V3_ACL
diff --git a/fs/Makefile b/fs/Makefile
index 9edf411..3e6f1ed 100644
--- a/fs/Makefile
+++ b/fs/Makefile
@@ -7,9 +7,9 @@
 
 obj-y :=	open.o read_write.o file_table.o super.o \
 		char_dev.o stat.o exec.o pipe.o namei.o fcntl.o \
-		ioctl.o readdir.o select.o fifo.o locks.o dcache.o inode.o \
+		ioctl.o readdir.o select.o fifo.o dcache.o inode.o \
 		attr.o bad_inode.o file.o filesystems.o namespace.o aio.o \
-		seq_file.o xattr.o libfs.o fs-writeback.o \
+		seq_file.o libfs.o fs-writeback.o \
 		pnode.o drop_caches.o splice.o sync.o utimes.o \
 		stack.o
 
@@ -21,6 +21,8 @@ endif
 
 obj-$(CONFIG_INOTIFY)		+= inotify.o
 obj-$(CONFIG_INOTIFY_USER)	+= inotify_user.o
+obj-$(CONFIG_FILE_LOCKING)	+= locks.o
+obj-$(CONFIG_XATTR)		+= xattr.o
 obj-$(CONFIG_EPOLL)		+= eventpoll.o
 obj-$(CONFIG_COMPAT)		+= compat.o compat_ioctl.o
 
@@ -68,6 +70,7 @@ obj-$(CONFIG_JBD)		+= jbd/
 obj-$(CONFIG_JBD2)		+= jbd2/
 obj-$(CONFIG_EXT2_FS)		+= ext2/
 obj-$(CONFIG_CRAMFS)		+= cramfs/
+obj-$(CONFIG_SQUASHFS)		+= squashfs/
 obj-$(CONFIG_RAMFS)		+= ramfs/
 obj-$(CONFIG_HUGETLBFS)		+= hugetlbfs/
 obj-$(CONFIG_CODA_FS)		+= coda/
@@ -114,3 +117,4 @@ obj-$(CONFIG_HPPFS)		+= hppfs/
 obj-$(CONFIG_DEBUG_FS)		+= debugfs/
 obj-$(CONFIG_OCFS2_FS)		+= ocfs2/
 obj-$(CONFIG_GFS2_FS)           += gfs2/
+obj-$(CONFIG_YAFFS_FS)		+= yaffs2/
diff --git a/fs/aio.c b/fs/aio.c
index e4598d6..5719ce3 100644
--- a/fs/aio.c
+++ b/fs/aio.c
@@ -35,6 +35,8 @@
 #include <asm/uaccess.h>
 #include <asm/mmu_context.h>
 
+#ifdef CONFIG_AIO
+
 #if DEBUG > 1
 #define dprintk		printk
 #else
@@ -1766,3 +1768,54 @@ __initcall(aio_setup);
 EXPORT_SYMBOL(aio_complete);
 EXPORT_SYMBOL(aio_put_req);
 EXPORT_SYMBOL(wait_on_sync_kiocb);
+
+#else
+
+ssize_t fastcall wait_on_sync_kiocb(struct kiocb *iocb)
+{
+	return 0;
+}
+
+void fastcall exit_aio(struct mm_struct *mm)
+{
+}
+
+void fastcall __put_ioctx(struct kioctx *ctx)
+{
+}
+
+int fastcall aio_put_req(struct kiocb *req)
+{
+	return 0;
+}
+
+struct kioctx *lookup_ioctx(unsigned long ctx_id)
+{
+	return 0;
+}
+
+void fastcall kick_iocb(struct kiocb *iocb)
+{
+}
+
+int fastcall aio_complete(struct kiocb *iocb, long res, long res2)
+{
+	return 0;
+}
+
+int fastcall io_submit_one(struct kioctx *ctx, struct iocb __user *user_iocb,
+		struct iocb *iocb)
+{
+	return -EINVAL;
+}
+
+struct kiocb *lookup_kiocb(struct kioctx *ctx, struct iocb *iocb, u32 key)
+{
+	return 0;
+}
+
+EXPORT_SYMBOL(aio_complete);
+EXPORT_SYMBOL(aio_put_req);
+EXPORT_SYMBOL(wait_on_sync_kiocb);
+
+#endif
diff --git a/fs/binfmt_elf.c b/fs/binfmt_elf.c
index 9cc4f0a..ec777cc 100644
--- a/fs/binfmt_elf.c
+++ b/fs/binfmt_elf.c
@@ -44,7 +44,9 @@
 #include <asm/page.h>
 
 static int load_elf_binary(struct linux_binprm *bprm, struct pt_regs *regs);
+#ifdef CONFIG_BINFMT_ELF_AOUT
 static int load_elf_library(struct file *);
+#endif
 static unsigned long elf_map (struct file *, unsigned long, struct elf_phdr *, int, int);
 
 /*
@@ -74,7 +76,11 @@ static int elf_core_dump(long signr, struct pt_regs *regs, struct file *file);
 static struct linux_binfmt elf_format = {
 		.module		= THIS_MODULE,
 		.load_binary	= load_elf_binary,
+#ifdef CONFIG_BINFMT_ELF_AOUT
 		.load_shlib	= load_elf_library,
+#else
+		.load_shlib	= NULL,
+#endif
 		.core_dump	= elf_core_dump,
 		.min_coredump	= ELF_EXEC_PAGESIZE,
 		.hasvdso	= 1
@@ -451,6 +457,7 @@ out:
 	return error;
 }
 
+#ifdef CONFIG_BINFMT_ELF_AOUT
 static unsigned long load_aout_interp(struct exec *interp_ex,
 		struct file *interpreter)
 {
@@ -496,6 +503,7 @@ static unsigned long load_aout_interp(struct exec *interp_ex,
 out:
 	return elf_entry;
 }
+#endif
 
 /*
  * These are the functions used to load ELF style executables and shared
@@ -503,7 +511,9 @@ out:
  */
 
 #define INTERPRETER_NONE 0
+#ifdef CONFIG_BINFMT_ELF_AOUT
 #define INTERPRETER_AOUT 1
+#endif
 #define INTERPRETER_ELF 2
 
 #ifndef STACK_RND_MASK
@@ -543,7 +553,9 @@ static int load_elf_binary(struct linux_binprm *bprm, struct pt_regs *regs)
 	unsigned long elf_entry, interp_load_addr = 0;
 	unsigned long start_code, end_code, start_data, end_data;
 	unsigned long reloc_func_desc = 0;
+#ifdef CONFIG_BINFMT_ELF_AOUT
 	char passed_fileno[6];
+#endif
 	struct files_struct *files;
 	int executable_stack = EXSTACK_DEFAULT;
 	unsigned long def_flags = 0;
@@ -720,12 +732,14 @@ static int load_elf_binary(struct linux_binprm *bprm, struct pt_regs *regs)
 
 	/* Some simple consistency checks for the interpreter */
 	if (elf_interpreter) {
+#ifdef CONFIG_BINFMT_ELF_AOUT
 		interpreter_type = INTERPRETER_ELF | INTERPRETER_AOUT;
 
 		/* Now figure out which format our binary is */
 		if ((N_MAGIC(loc->interp_ex) != OMAGIC) &&
 		    (N_MAGIC(loc->interp_ex) != ZMAGIC) &&
 		    (N_MAGIC(loc->interp_ex) != QMAGIC))
+#endif
 			interpreter_type = INTERPRETER_ELF;
 
 		if (memcmp(loc->interp_elf_ex.e_ident, ELFMAG, SELFMAG) != 0)
@@ -735,6 +749,7 @@ static int load_elf_binary(struct linux_binprm *bprm, struct pt_regs *regs)
 		if (!interpreter_type)
 			goto out_free_dentry;
 
+#ifdef CONFIG_BINFMT_ELF_AOUT
 		/* Make sure only one type was selected */
 		if ((interpreter_type & INTERPRETER_ELF) &&
 		     interpreter_type != INTERPRETER_ELF) {
@@ -742,6 +757,7 @@ static int load_elf_binary(struct linux_binprm *bprm, struct pt_regs *regs)
 			// printk(KERN_WARNING "ELF: Ambiguous type, using ELF\n");
 			interpreter_type = INTERPRETER_ELF;
 		}
+#endif
 		/* Verify the interpreter has a valid arch */
 		if ((interpreter_type == INTERPRETER_ELF) &&
 		    !elf_check_arch(&loc->interp_elf_ex))
@@ -753,6 +769,7 @@ static int load_elf_binary(struct linux_binprm *bprm, struct pt_regs *regs)
 
 	/* OK, we are done with that, now set up the arg stuff,
 	   and then start this sucker up */
+#ifdef CONFIG_BINFMT_ELF_AOUT
 	if ((!bprm->sh_bang) && (interpreter_type == INTERPRETER_AOUT)) {
 		char *passed_p = passed_fileno;
 		sprintf(passed_fileno, "%d", elf_exec_fileno);
@@ -764,6 +781,7 @@ static int load_elf_binary(struct linux_binprm *bprm, struct pt_regs *regs)
 			bprm->argc++;
 		}
 	}
+#endif
 
 	/* Flush all traces of the currently running executable */
 	retval = flush_old_exec(bprm);
@@ -941,10 +959,12 @@ static int load_elf_binary(struct linux_binprm *bprm, struct pt_regs *regs)
 	}
 
 	if (elf_interpreter) {
+#ifdef CONFIG_BINFMT_ELF_AOUT
 		if (interpreter_type == INTERPRETER_AOUT)
 			elf_entry = load_aout_interp(&loc->interp_ex,
 						     interpreter);
 		else
+#endif
 			elf_entry = load_elf_interp(&loc->interp_elf_ex,
 						    interpreter,
 						    &interp_load_addr);
@@ -970,7 +990,9 @@ static int load_elf_binary(struct linux_binprm *bprm, struct pt_regs *regs)
 
 	kfree(elf_phdata);
 
+#ifdef CONFIG_BINFMT_ELF_AOUT
 	if (interpreter_type != INTERPRETER_AOUT)
+#endif
 		sys_close(elf_exec_fileno);
 
 	set_binfmt(&elf_format);
@@ -985,12 +1007,16 @@ static int load_elf_binary(struct linux_binprm *bprm, struct pt_regs *regs)
 
 	compute_creds(bprm);
 	current->flags &= ~PF_FORKNOEXEC;
+#ifdef CONFIG_BINFMT_ELF_AOUT
 	create_elf_tables(bprm, &loc->elf_ex,
 			  (interpreter_type == INTERPRETER_AOUT),
 			  load_addr, interp_load_addr);
 	/* N.B. passed_fileno might not be initialized? */
 	if (interpreter_type == INTERPRETER_AOUT)
 		current->mm->arg_start += strlen(passed_fileno) + 1;
+#else
+	create_elf_tables(bprm, &loc->elf_ex, 0, load_addr, interp_load_addr);
+#endif
 	current->mm->end_code = end_code;
 	current->mm->start_code = start_code;
 	current->mm->start_data = start_data;
@@ -1052,6 +1078,7 @@ out_free_ph:
 	goto out;
 }
 
+#ifdef CONFIG_BINFMT_ELF_AOUT
 /* This is really simpleminded and specialized - we are loading an
    a.out library that is given an ELF header. */
 static int load_elf_library(struct file *file)
@@ -1135,6 +1162,7 @@ out_free_ph:
 out:
 	return error;
 }
+#endif
 
 /*
  * Note that some platforms still use traditional core dumps and not
diff --git a/fs/buffer.c b/fs/buffer.c
index 1d0852f..badf90d 100644
--- a/fs/buffer.c
+++ b/fs/buffer.c
@@ -571,7 +571,11 @@ EXPORT_SYMBOL(mark_buffer_async_write);
 /*
  * The buffer's backing address_space's private_lock must be held
  */
+#ifdef CONFIG_LINUXTINY_DO_UNINLINE
+static void __remove_assoc_queue(struct buffer_head *bh)
+#else
 static inline void __remove_assoc_queue(struct buffer_head *bh)
+#endif
 {
 	list_del_init(&bh->b_assoc_buffers);
 	WARN_ON(!bh->b_assoc_map);
diff --git a/fs/exec.c b/fs/exec.c
index 3155e91..abaed22 100644
--- a/fs/exec.c
+++ b/fs/exec.c
@@ -124,6 +124,7 @@ static inline void put_binfmt(struct linux_binfmt * fmt)
  */
 asmlinkage long sys_uselib(const char __user * library)
 {
+#if defined(CONFIG_BINFMT_AOUT) || defined(CONFIG_BINFMT_AOUT_MODULE) || defined(CONFIG_BINFMT_ELF_AOUT)
 	struct file * file;
 	struct nameidata nd;
 	int error;
@@ -171,6 +172,9 @@ exit:
 	release_open_intent(&nd);
 	path_release(&nd);
 	goto out;
+#else
+	return -ENOSYS;
+#endif
 }
 
 /*
diff --git a/fs/namei.c b/fs/namei.c
index ee60cc4..65764b6 100644
--- a/fs/namei.c
+++ b/fs/namei.c
@@ -608,7 +608,11 @@ static __always_inline int __do_follow_link(struct path *path, struct nameidata
 		char *s = nd_get_link(nd);
 		error = 0;
 		if (s)
+#ifdef CONFIG_LINUXTINY_DO_UNINLINE
+			error = vfs_follow_link(nd, s);
+#else
 			error = __vfs_follow_link(nd, s);
+#endif
 		if (dentry->d_inode->i_op->put_link)
 			dentry->d_inode->i_op->put_link(dentry, nd, cookie);
 	}
@@ -625,7 +629,11 @@ static __always_inline int __do_follow_link(struct path *path, struct nameidata
  * Without that kind of total limit, nasty chains of consecutive
  * symlinks can cause almost arbitrarily long lookups. 
  */
+#ifdef CONFIG_LINUXTINY_DO_UNINLINE
+static int do_follow_link(struct path *path, struct nameidata *nd)
+#else
 static inline int do_follow_link(struct path *path, struct nameidata *nd)
+#endif
 {
 	int err = -ELOOP;
 	if (current->link_count >= MAX_NESTED_LINKS)
@@ -1421,8 +1429,13 @@ static int may_delete(struct inode *dir,struct dentry *victim,int isdir)
  *  3. We should have write and exec permissions on dir
  *  4. We can't do it if dir is immutable (done in permission())
  */
+#ifdef CONFIG_LINUXTINY_DO_UNINLINE
+static int may_create(struct inode *dir, struct dentry *child,
+			     struct nameidata *nd)
+#else
 static inline int may_create(struct inode *dir, struct dentry *child,
 			     struct nameidata *nd)
+#endif
 {
 	if (child->d_inode)
 		return -EEXIST;
diff --git a/fs/proc/proc_misc.c b/fs/proc/proc_misc.c
index e2c4c0a..3a6ee14 100644
--- a/fs/proc/proc_misc.c
+++ b/fs/proc/proc_misc.c
@@ -616,6 +616,7 @@ static int cmdline_read_proc(char *page, char **start, off_t off,
 	return proc_calc_metrics(page, start, off, count, eof, len);
 }
 
+#ifdef CONFIG_FILE_LOCKING
 static int locks_read_proc(char *page, char **start, off_t off,
 				 int count, int *eof, void *data)
 {
@@ -625,6 +626,7 @@ static int locks_read_proc(char *page, char **start, off_t off,
 		*eof = 1;
 	return len;
 }
+#endif
 
 static int execdomains_read_proc(char *page, char **start, off_t off,
 				 int count, int *eof, void *data)
@@ -683,7 +685,9 @@ void __init proc_misc_init(void)
 #endif
 		{"filesystems",	filesystems_read_proc},
 		{"cmdline",	cmdline_read_proc},
+#ifdef CONFIG_FILE_LOCKING
 		{"locks",	locks_read_proc},
+#endif
 		{"execdomains",	execdomains_read_proc},
 		{NULL,}
 	};
diff --git a/fs/super.c b/fs/super.c
index 60b1e50..ec80979 100644
--- a/fs/super.c
+++ b/fs/super.c
@@ -618,6 +618,7 @@ int do_remount_sb(struct super_block *sb, int flags, void *data, int force)
 	return 0;
 }
 
+#ifdef CONFIG_PDFLUSH
 static void do_emergency_remount(unsigned long foo)
 {
 	struct super_block *sb;
@@ -643,10 +644,13 @@ static void do_emergency_remount(unsigned long foo)
 	spin_unlock(&sb_lock);
 	printk("Emergency Remount complete\n");
 }
+#endif
 
 void emergency_remount(void)
 {
+#ifdef CONFIG_PDFLUSH
 	pdflush_operation(do_emergency_remount, 0);
+#endif
 }
 
 /*
diff --git a/fs/sync.c b/fs/sync.c
index d0feff6..ecac067 100644
--- a/fs/sync.c
+++ b/fs/sync.c
@@ -44,7 +44,9 @@ asmlinkage long sys_sync(void)
 
 void emergency_sync(void)
 {
+#ifdef CONFIG_PDFLUSH
 	pdflush_operation(do_sync, 0);
+#endif
 }
 
 /*
diff --git a/include/asm-mips/addrspace.h b/include/asm-mips/addrspace.h
index c627508..964c5ed 100644
--- a/include/asm-mips/addrspace.h
+++ b/include/asm-mips/addrspace.h
@@ -133,6 +133,7 @@
     || defined (CONFIG_CPU_R4X00)					\
     || defined (CONFIG_CPU_R5000)					\
     || defined (CONFIG_CPU_RM7000)					\
+    || defined (CONFIG_CPU_RM9000)					\
     || defined (CONFIG_CPU_NEVADA)					\
     || defined (CONFIG_CPU_TX49XX)					\
     || defined (CONFIG_CPU_MIPS64)
diff --git a/include/asm-mips/bootinfo.h b/include/asm-mips/bootinfo.h
index c7c945b..ab49ee2 100644
--- a/include/asm-mips/bootinfo.h
+++ b/include/asm-mips/bootinfo.h
@@ -208,6 +208,13 @@
 #define  MACH_TITAN_EXCITE	2	/* Basler eXcite		*/
 
 /*
+ * Valid machtype for group Ralink
+ */
+#define MACH_GROUP_RT2880    23 	/* Ralink AP SoC */
+#define MACH_RALINK_ROUTER   0 		/* Ralink Wireless ROUTER*/
+
+
+/*
  * Valid machtype for group NEC EMMA2RH
  */
 #define MACH_GROUP_NEC_EMMA2RH 25	/* NEC EMMA2RH (was 23)		*/
diff --git a/include/asm-mips/mach-generic/ide.h b/include/asm-mips/mach-generic/ide.h
index 6eba2e5..a54c19f 100644
--- a/include/asm-mips/mach-generic/ide.h
+++ b/include/asm-mips/mach-generic/ide.h
@@ -29,17 +29,12 @@
 
 #define IDE_ARCH_OBSOLETE_DEFAULTS
 
+extern int mips_system_has_legacy_ide;
+
 static __inline__ int ide_probe_legacy(void)
 {
 #ifdef CONFIG_PCI
-	struct pci_dev *dev;
-	if ((dev = pci_get_class(PCI_CLASS_BRIDGE_EISA << 8, NULL)) != NULL ||
-	    (dev = pci_get_class(PCI_CLASS_BRIDGE_ISA << 8, NULL)) != NULL) {
-		pci_dev_put(dev);
-
-		return 1;
-	}
-	return 0;
+	return mips_system_has_legacy_ide;
 #elif defined(CONFIG_EISA) || defined(CONFIG_ISA)
 	return 1;
 #else
diff --git a/include/linux/Kbuild b/include/linux/Kbuild
index e81e301..3cb525b 100644
--- a/include/linux/Kbuild
+++ b/include/linux/Kbuild
@@ -220,6 +220,7 @@ unifdef-y += if_fddi.h
 unifdef-y += if_frad.h
 unifdef-y += if_ltalk.h
 unifdef-y += if_link.h
+unifdef-y += if_pppol2tp.h
 unifdef-y += if_pppox.h
 unifdef-y += if_shaper.h
 unifdef-y += if_tr.h
diff --git a/include/linux/ethtool.h b/include/linux/ethtool.h
index c6310ae..14e61b7 100644
--- a/include/linux/ethtool.h
+++ b/include/linux/ethtool.h
@@ -260,6 +260,7 @@ struct ethtool_perm_addr {
 
 struct net_device;
 
+#ifdef CONFIG_ETHTOOL
 /* Some generic methods drivers may use in their ethtool_ops */
 u32 ethtool_op_get_link(struct net_device *dev);
 u32 ethtool_op_get_tx_csum(struct net_device *dev);
@@ -273,6 +274,23 @@ int ethtool_op_get_perm_addr(struct net_device *dev,
 			     struct ethtool_perm_addr *addr, u8 *data);
 u32 ethtool_op_get_ufo(struct net_device *dev);
 int ethtool_op_set_ufo(struct net_device *dev, u32 data);
+#else
+static inline u32 ethtool_noop1(struct net_device *dev) { return 0; }
+static inline int ethtool_noop2(struct net_device *dev, u32 data) { return 0; }
+static inline int ethtool_noop3(struct net_device *dev,
+		struct ethtool_perm_addr *addr, u32 data) { return 0; }
+#define ethtool_op_get_link ethtool_noop1
+#define ethtool_op_get_tx_csum ethtool_noop1
+#define ethtool_op_set_tx_csum ethtool_noop2
+#define ethtool_op_set_tx_hw_csum ethtool_noop2
+#define ethtool_op_get_sg ethtool_noop1
+#define ethtool_op_set_sg ethtool_noop2
+#define ethtool_op_get_tso ethtool_noop1
+#define ethtool_op_set_tso ethtool_noop2
+#define ethtool_op_get_perm_addr ethtool_noop3
+#define ethtool_op_get_ufo ethtool_noop1
+#define ethtool_op_set_ufo ethtool_noop2
+#endif
 
 /**
  * &ethtool_ops - Alter and report network device settings
diff --git a/include/linux/filter.h b/include/linux/filter.h
index 91b2e3b..0370113 100644
--- a/include/linux/filter.h
+++ b/include/linux/filter.h
@@ -141,12 +141,18 @@ static inline unsigned int sk_filter_len(struct sk_filter *fp)
 #define SKF_LL_OFF    (-0x200000)
 
 #ifdef __KERNEL__
+#ifdef CONFIG_NET_SK_FILTER
 struct sk_buff;
 struct sock;
 
 extern unsigned int sk_run_filter(struct sk_buff *skb, struct sock_filter *filter, int flen);
 extern int sk_attach_filter(struct sock_fprog *fprog, struct sock *sk);
 extern int sk_chk_filter(struct sock_filter *filter, int flen);
+#else
+#define sk_run_filter(a, b, c) (0)
+#define sk_attach_filter(a, b) (-EINVAL)
+#define sk_chk_filter(a, b) (-EINVAL)
+#endif /* NET_SK_FILTER */
 #endif /* __KERNEL__ */
 
 #endif /* __LINUX_FILTER_H__ */
diff --git a/include/linux/fs.h b/include/linux/fs.h
index 86ec3f4..ae5fd65 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -828,6 +828,13 @@ struct file_lock {
 
 #include <linux/fcntl.h>
 
+extern void send_sigio(struct fown_struct *fown, int fd, int band);
+
+/* fs/sync.c */
+extern int do_sync_file_range(struct file *file, loff_t offset, loff_t endbyte,
+			unsigned int flags);
+
+#ifdef CONFIG_FILE_LOCKING
 extern int fcntl_getlk(struct file *, struct flock __user *);
 extern int fcntl_setlk(unsigned int, struct file *, unsigned int,
 			struct flock __user *);
@@ -838,14 +845,9 @@ extern int fcntl_setlk64(unsigned int, struct file *, unsigned int,
 			struct flock64 __user *);
 #endif
 
-extern void send_sigio(struct fown_struct *fown, int fd, int band);
 extern int fcntl_setlease(unsigned int fd, struct file *filp, long arg);
 extern int fcntl_getlease(struct file *filp);
 
-/* fs/sync.c */
-extern int do_sync_file_range(struct file *file, loff_t offset, loff_t endbyte,
-			unsigned int flags);
-
 /* fs/locks.c */
 extern void locks_init_lock(struct file_lock *);
 extern void locks_copy_lock(struct file_lock *, struct file_lock *);
@@ -864,6 +866,38 @@ extern int lease_modify(struct file_lock **, int);
 extern int lock_may_read(struct inode *, loff_t start, unsigned long count);
 extern int lock_may_write(struct inode *, loff_t start, unsigned long count);
 
+#else /* !CONFIG_FILE_LOCKING */
+
+#define fcntl_getlk(a, b) (-EINVAL)
+#define fcntl_setlk(a, b, c, d) (-EACCES)
+#if BITS_PER_LONG == 32
+#define fcntl_getlk64(a, b) (-EINVAL)
+#define fcntl_setlk64(a, b, c, d) (-EACCES)
+#endif
+#define fcntl_setlease(a, b, c) (0)
+#define fcntl_getlease(a) (0)
+#define locks_init_lock(a)
+#define locks_copy_lock(a, b)
+#define locks_remove_posix(a, b)
+#define locks_remove_flock(a)
+#define posix_test_lock(a, b) (0)
+#define posix_lock_file(a, b) (-ENOLCK)
+#define posix_lock_file_wait(a, b) (-ENOLCK)
+#define posix_block_lock(a, b)
+#define posix_unblock_lock(a, b) (-ENOENT)
+#define posix_locks_deadlock(a, b) (0)
+#define vfs_test_lock(a, b) (0)
+#define vfs_lock_file(a, b, c, d) (-ENOLCK)
+#define vfs_cancel_lock(a, b) (0)
+#define flock_lock_file_wait(a, b) (-ENOLCK)
+#define __break_lease(a, b) (0)
+#define lease_get_mtime(a, b)
+#define lock_may_read(a, b, c) (1)
+#define lock_may_write(a, b, c) (1)
+#define steal_locks(a)
+
+#endif /* !CONFIG_FILE_LOCKING */
+
 struct fasync_struct {
 	int	magic;
 	int	fa_fd;
@@ -1416,6 +1450,7 @@ extern struct subsystem fs_subsys;
 #define FLOCK_VERIFY_READ  1
 #define FLOCK_VERIFY_WRITE 2
 
+#ifdef CONFIG_FILE_LOCKING
 extern int locks_mandatory_locked(struct inode *);
 extern int locks_mandatory_area(int, struct inode *, struct file *, loff_t, size_t);
 
@@ -1456,6 +1491,18 @@ static inline int break_lease(struct inode *inode, unsigned int mode)
 	return 0;
 }
 
+#else /* !CONFIG_FILE_LOCKING */
+
+#define locks_mandatory_locked(a) (0)
+#define locks_mandatory_area(a, b, c, d, e) (0)
+#define MANDATORY_LOCK(inode) (0)
+#define locks_verify_locked(a) (0)
+#define locks_verify_area(a, b, c, d, e) (0 && (b))
+#define locks_verify_truncate(a, b, c) (0)
+#define break_lease(a, b) (0)
+
+#endif /* !CONFIG_FILE_LOCKING */
+
 /* fs/open.c */
 
 extern int do_truncate(struct dentry *, loff_t start, unsigned int time_attrs,
diff --git a/include/linux/if_ppp.h b/include/linux/if_ppp.h
index 768372f..211531c 100644
--- a/include/linux/if_ppp.h
+++ b/include/linux/if_ppp.h
@@ -110,6 +110,21 @@ struct ifpppcstatsreq {
 	struct ppp_comp_stats stats;
 };
 
+/* For PPPIOCGL2TPSTATS */
+struct pppol2tp_ioc_stats {
+	__u16	tunnel_id;	/* redundant */
+	__u16	session_id;	/* if zero, get tunnel stats */
+	__u64	tx_packets;
+	__u64	tx_bytes;
+	__u64	tx_errors;
+	__u64	rx_packets;
+	__u64	rx_bytes;
+	__u64	rx_seq_discards;
+	__u64	rx_oos_packets;
+	__u64	rx_errors;
+	int	using_ipsec;	/* valid only for session_id == 0 */
+};
+
 #define ifr__name       b.ifr_ifrn.ifrn_name
 #define stats_ptr       b.ifr_ifru.ifru_data
 
@@ -146,6 +161,7 @@ struct ifpppcstatsreq {
 #define PPPIOCDISCONN	_IO('t', 57)		/* disconnect channel */
 #define PPPIOCATTCHAN	_IOW('t', 56, int)	/* attach to ppp channel */
 #define PPPIOCGCHAN	_IOR('t', 55, int)	/* get ppp channel number */
+#define PPPIOCGL2TPSTATS _IOR('t', 54, struct pppol2tp_ioc_stats)
 
 #define SIOCGPPPSTATS   (SIOCDEVPRIVATE + 0)
 #define SIOCGPPPVER     (SIOCDEVPRIVATE + 1)	/* NEVER change this!! */
diff --git a/include/linux/if_pppox.h b/include/linux/if_pppox.h
index e33ee76..08e302b 100644
--- a/include/linux/if_pppox.h
+++ b/include/linux/if_pppox.h
@@ -18,15 +18,28 @@
 
 
 #include <asm/types.h>
+#ifdef __KERNEL__
 #include <asm/byteorder.h>
+#else
+#include <endian.h>
+#include <byteswap.h>
+#if __BYTE_ORDER == __LITTLE_ENDIAN
+#define __LITTLE_ENDIAN_BITFIELD
+#elif __BYTE_ORDER == __BIG_ENDIAN
+#define __BIG_ENDIAN_BITFIELD
+#else
+#error "Adjust your <endian.h> defines."
+#endif
+#endif
 
-#ifdef  __KERNEL__
+#ifdef	__KERNEL__
 #include <linux/if_ether.h>
 #include <linux/if.h>
 #include <linux/netdevice.h>
 #include <asm/semaphore.h>
 #include <linux/ppp_channel.h>
 #endif /* __KERNEL__ */
+#include <linux/if_pppol2tp.h>
 
 /* For user-space programs to pick up these definitions
  * which they wouldn't get otherwise without defining __KERNEL__
@@ -36,30 +49,48 @@
 #define PF_PPPOX	AF_PPPOX
 #endif /* !(AF_PPPOX) */
 
-/************************************************************************ 
- * PPPoE addressing definition 
- */ 
-typedef __u16 sid_t; 
-struct pppoe_addr{ 
-       sid_t           sid;                    /* Session identifier */ 
-       unsigned char   remote[ETH_ALEN];       /* Remote address */ 
-       char            dev[IFNAMSIZ];          /* Local device to use */ 
-}; 
- 
-/************************************************************************ 
- * Protocols supported by AF_PPPOX 
- */ 
-#define PX_PROTO_OE    0 /* Currently just PPPoE */
-#define PX_MAX_PROTO   1	
- 
-struct sockaddr_pppox { 
-       sa_family_t     sa_family;            /* address family, AF_PPPOX */ 
-       unsigned int    sa_protocol;          /* protocol identifier */ 
-       union{ 
-               struct pppoe_addr       pppoe; 
-       }sa_addr; 
-}__attribute__ ((packed)); 
+/************************************************************************
+ * PPPoE addressing definition
+ */
+typedef __u16 sid_t;
+struct pppoe_addr{
+       sid_t           sid;                    /* Session identifier */
+       unsigned char   remote[ETH_ALEN];       /* Remote address */
+       char            dev[IFNAMSIZ];          /* Local device to use */
+};
 
+struct pptp_addr{
+       __u16           call_id;
+       struct in_addr  sin_addr;
+};
+
+/************************************************************************
+ * Protocols supported by AF_PPPOX
+ */
+#define PX_PROTO_OE    0 /* Currently just PPPoE */
+#define PX_PROTO_OL2TP 1 /* Now L2TP also */
+#define PX_PROTO_PPTP  2 /* Now PPTP also */
+#define PX_MAX_PROTO   3
+
+struct sockaddr_pppox {
+       sa_family_t     sa_family;            /* address family, AF_PPPOX */
+       unsigned int    sa_protocol;          /* protocol identifier */
+       union{
+               struct pppoe_addr       pppoe;
+	       struct pptp_addr        pptp;
+       }sa_addr;
+}__attribute__ ((packed));
+
+/* The use of the above union isn't viable because the size of this
+ * struct must stay fixed over time -- applications use sizeof(struct
+ * sockaddr_pppox) to fill it. We use a protocol specific sockaddr
+ * type instead.
+ */
+struct sockaddr_pppol2tp {
+	sa_family_t     sa_family;      /* address family, AF_PPPOX */
+	unsigned int    sa_protocol;    /* protocol identifier */
+	struct pppol2tp_addr pppol2tp;
+}__attribute__ ((packed));
 
 /*********************************************************************
  *
@@ -70,6 +101,7 @@ struct sockaddr_pppox {
 #define PPPOEIOCSFWD	_IOW(0xB1 ,0, size_t)
 #define PPPOEIOCDFWD	_IO(0xB1 ,1)
 /*#define PPPOEIOCGFWD	_IOWR(0xB1,2, size_t)*/
+#define PPPTPIOWFP  	_IOWR(0xB1 ,2,size_t)
 
 /* Codes to identify message types */
 #define PADI_CODE	0x09
@@ -89,11 +121,11 @@ struct pppoe_tag {
 #define PTT_AC_NAME	__constant_htons(0x0102)
 #define PTT_HOST_UNIQ	__constant_htons(0x0103)
 #define PTT_AC_COOKIE	__constant_htons(0x0104)
-#define PTT_VENDOR 	__constant_htons(0x0105)
+#define PTT_VENDOR	__constant_htons(0x0105)
 #define PTT_RELAY_SID	__constant_htons(0x0110)
-#define PTT_SRV_ERR     __constant_htons(0x0201)
-#define PTT_SYS_ERR  	__constant_htons(0x0202)
-#define PTT_GEN_ERR  	__constant_htons(0x0203)
+#define PTT_SRV_ERR	__constant_htons(0x0201)
+#define PTT_SYS_ERR	__constant_htons(0x0202)
+#define PTT_GEN_ERR	__constant_htons(0x0203)
 
 struct pppoe_hdr {
 #if defined(__LITTLE_ENDIAN_BITFIELD)
@@ -111,9 +143,13 @@ struct pppoe_hdr {
 	struct pppoe_tag tag[0];
 } __attribute__ ((packed));
 
+/* Socket options */
+#define PPTP_SO_TIMEOUT 1
+#define PPTP_SO_WINDOW  2
+
 #ifdef __KERNEL__
 struct pppoe_opt {
-	struct net_device      *dev;	  /* device associated with socket*/
+	struct net_device	*dev;	  /* device associated with socket*/
 	int			ifindex;  /* ifindex of device associated with socket */
 	struct pppoe_addr	pa;	  /* what this socket is bound to*/
 	struct sockaddr_pppox	relay;	  /* what socket data will be
@@ -122,6 +158,26 @@ struct pppoe_opt {
 
 #include <net/sock.h>
 
+struct pptp_opt {
+       struct pptp_addr        src_addr;
+       struct pptp_addr        dst_addr;
+       int timeout;
+       int window;
+       __u32 ack_sent, ack_recv;
+       __u32 seq_sent, seq_recv;
+       int ppp_flags;
+       int flags;
+       int pause:1;
+       int proc:1;
+       spinlock_t skb_buf_lock;
+       struct sk_buff_head skb_buf;
+       struct delayed_work buf_work; //check bufferd packets work
+       struct gre_statistics *stat;
+	wait_queue_head_t	wait;
+	spinlock_t xmit_lock;
+	spinlock_t rcv_lock;
+};
+
 struct pppox_sock {
 	/* struct sock must be the first member of pppox_sock */
 	struct sock		sk;
@@ -129,6 +185,7 @@ struct pppox_sock {
 	struct pppox_sock	*next;	  /* for hash table */
 	union {
 		struct pppoe_opt pppoe;
+		struct pptp_opt pptp;
 	} proto;
 	unsigned short		num;
 };
diff --git a/include/linux/igmp.h b/include/linux/igmp.h
index a113fe6..1bf3119 100644
--- a/include/linux/igmp.h
+++ b/include/linux/igmp.h
@@ -198,6 +198,7 @@ struct ip_mc_list
 #define IGMPV3_QQIC(value) IGMPV3_EXP(0x80, 4, 3, value)
 #define IGMPV3_MRC(value) IGMPV3_EXP(0x80, 4, 3, value)
 
+#ifdef CONFIG_IGMP
 extern int ip_check_mc(struct in_device *dev, __be32 mc_addr, __be32 src_addr, u16 proto);
 extern int igmp_rcv(struct sk_buff *);
 extern int ip_mc_join_group(struct sock *sk, struct ip_mreqn *imr);
@@ -219,6 +220,25 @@ extern void ip_mc_down(struct in_device *);
 extern void ip_mc_dec_group(struct in_device *in_dev, __be32 addr);
 extern void ip_mc_inc_group(struct in_device *in_dev, __be32 addr);
 extern void ip_mc_rejoin_group(struct ip_mc_list *im);
+#else /* !CONFIG_IGMP */
+#define ip_check_mc(a, b, c, d) (0)
+#define igmp_rcv(a) (0)
+#define ip_mc_join_group(a, b) (0)
+#define ip_mc_leave_group(a, b) (0)
+#define ip_mc_drop_socket(a)
+#define ip_mc_source(a, b, c, d, e) (0)
+#define ip_mc_msfilter(a, b, c) (0)
+#define ip_mc_msfget(a, b, c, d) (0)
+#define ip_mc_gsfget(a, b, c, d) (0)
+#define ip_mc_sf_allow(a, b, c, d) (0)
+#define ip_mc_init_dev(a)
+#define ip_mc_destroy_dev(a)
+#define ip_mc_up(a)
+#define ip_mc_down(a)
+#define ip_mc_dec_group(a, b)
+#define ip_mc_inc_group(a, b)
+#define ip_mc_rejoin_group(a)
+#endif /* !CONFIG_IGMP */
 
 #endif
 #endif
diff --git a/include/linux/irq.h b/include/linux/irq.h
index a689940..17dcc4b 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -304,10 +304,12 @@ static inline void generic_handle_irq(unsigned int irq)
 #ifdef CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ
 	desc->handle_irq(irq, desc);
 #else
-	if (likely(desc->handle_irq))
+	if (likely(desc->handle_irq)){
 		desc->handle_irq(irq, desc);
-	else
+	}
+	else{
 		__do_IRQ(irq);
+	}
 #endif
 }
 
diff --git a/include/linux/kernel.h b/include/linux/kernel.h
index 9ddf25c..eee2dd3 100644
--- a/include/linux/kernel.h
+++ b/include/linux/kernel.h
@@ -94,8 +94,23 @@ extern int cond_resched(void);
 
 extern struct atomic_notifier_head panic_notifier_list;
 extern long (*panic_blink)(long time);
+
+#ifndef CONFIG_PANIC
+NORET_TYPE static inline void panic(const char * fmt, ...)
+	__attribute__ ((NORET_AND format (printf, 1, 2)));
+NORET_TYPE static inline void panic(const char * fmt, ...) {}
+#else
+
+#ifdef CONFIG_FULL_PANIC
 NORET_TYPE void panic(const char * fmt, ...)
 	__attribute__ ((NORET_AND format (printf, 1, 2)));
+#else
+#define panic(fmt, ...) tiny_panic(0, ## __VA_ARGS__)
+NORET_TYPE void tiny_panic(int a, ...) ATTRIB_NORET;
+#endif
+
+#endif
+
 extern void oops_enter(void);
 extern void oops_exit(void);
 extern int oops_may_print(void);
@@ -139,7 +154,7 @@ extern struct pid *session_of_pgrp(struct pid *pgrp);
 
 extern void dump_thread(struct pt_regs *regs, struct user *dump);
 
-#ifdef CONFIG_PRINTK
+#if defined(CONFIG_PRINTK) || (defined(CONFIG_PRINTK_FUNC) && defined(DO_PRINTK))
 asmlinkage int vprintk(const char *fmt, va_list args)
 	__attribute__ ((format (printf, 1, 0)));
 asmlinkage int printk(const char * fmt, ...)
diff --git a/include/linux/mempool.h b/include/linux/mempool.h
index 9be484d..79fbb21 100644
--- a/include/linux/mempool.h
+++ b/include/linux/mempool.h
@@ -11,6 +11,7 @@ struct kmem_cache;
 typedef void * (mempool_alloc_t)(gfp_t gfp_mask, void *pool_data);
 typedef void (mempool_free_t)(void *element, void *pool_data);
 
+#ifdef CONFIG_MEMPOOL
 typedef struct mempool_s {
 	spinlock_t lock;
 	int min_nr;		/* nr of elements at *elements */
@@ -33,6 +34,24 @@ extern void mempool_destroy(mempool_t *pool);
 extern void * mempool_alloc(mempool_t *pool, gfp_t gfp_mask);
 extern void mempool_free(void *element, mempool_t *pool);
 
+#else
+
+typedef struct mempool_s {
+	void *pool_data;
+	void *cache;
+	mempool_alloc_t *alloc;
+	mempool_free_t *free;
+} mempool_t;
+
+extern mempool_t * mempool_create(int min_nr, mempool_alloc_t *alloc_fn,
+		mempool_free_t *free_fn, void *pool_data);
+extern void * mempool_alloc(mempool_t *pool, int gfp_mask);
+extern void mempool_free(void *element, mempool_t *pool);
+extern void mempool_destroy(mempool_t *pool);
+#define mempool_resize(a, b, c) (0)
+#define mempool_create_node(m, a, f, p, n) mempool_create(m, a, f, p)
+
+#endif
 /*
  * A mempool_alloc_t and mempool_free_t that get the memory from
  * a slab that is passed in through pool_data.
diff --git a/include/linux/mroute.h b/include/linux/mroute.h
index 7da2cee..ccfa7d1 100644
--- a/include/linux/mroute.h
+++ b/include/linux/mroute.h
@@ -131,7 +131,11 @@ struct igmpmsg
 extern int ip_mroute_setsockopt(struct sock *, int, char __user *, int);
 extern int ip_mroute_getsockopt(struct sock *, int, char __user *, int __user *);
 extern int ipmr_ioctl(struct sock *sk, int cmd, void __user *arg);
+#ifdef CONFIG_IGMP
 extern void ip_mr_init(void);
+#else
+static inline void ip_mr_init(void) {}
+#endif
 
 
 struct vif_device
diff --git a/include/linux/mtd/cfi.h b/include/linux/mtd/cfi.h
index 123948b..ab0a700 100644
--- a/include/linux/mtd/cfi.h
+++ b/include/linux/mtd/cfi.h
@@ -201,6 +201,27 @@ struct cfi_pri_amdstd {
 
 /* Vendor-Specific PRI for Atmel chips (command set 0x0002) */
 
+/* Vendor-Specific PRI for SST Extended Command Set (0x0701) */
+
+struct cfi_pri_sststd {
+	uint8_t  pri[3];
+	uint8_t  MajorVersion;
+	uint8_t  MinorVersion;
+	uint8_t  SiliconRevision; /* bits 1-0: Address Sensitive Unlock */
+	uint8_t  EraseSuspend;
+	uint8_t  BlkProt;
+	uint8_t  TmpBlkUnprotect;
+	uint8_t  BlkProtUnprot;
+	uint8_t  SimultaneousOps;
+	uint8_t  BurstMode;
+	uint8_t  PageMode;
+	uint8_t  VppMin;
+	uint8_t  VppMax;
+	uint8_t  TopBottom;
+} __attribute__((packed));
+
+/* Vendor-Specific PRI for SST chips (command set 0x0701) */
+
 struct cfi_pri_atmel {
 	uint8_t pri[3];
 	uint8_t MajorVersion;
@@ -477,7 +498,9 @@ struct cfi_fixup {
 
 #define CFI_MFR_AMD 0x0001
 #define CFI_MFR_ATMEL 0x001F
+#define CFI_MFR_SAMSUNG 0x00EC
 #define CFI_MFR_ST  0x0020 	/* STMicroelectronics */
+#define CFI_MFR_SST 0x00BF
 
 void cfi_fixup(struct mtd_info *mtd, struct cfi_fixup* fixups);
 
diff --git a/include/linux/netdevice.h b/include/linux/netdevice.h
index 1a52854..7c0194c 100644
--- a/include/linux/netdevice.h
+++ b/include/linux/netdevice.h
@@ -971,17 +971,27 @@ extern struct net_device *alloc_netdev(int sizeof_priv, const char *name,
 extern int		register_netdev(struct net_device *dev);
 extern void		unregister_netdev(struct net_device *dev);
 /* Functions used for multicast support */
+#ifdef CONFIG_NET_DEV_MULTICAST
 extern void		dev_mc_upload(struct net_device *dev);
 extern int 		dev_mc_delete(struct net_device *dev, void *addr, int alen, int all);
 extern int		dev_mc_add(struct net_device *dev, void *addr, int alen, int newonly);
 extern void		dev_mc_discard(struct net_device *dev);
+extern void		dev_mcast_init(void);
+#else
+#define		dev_mc_upload(a)
+static inline int dev_mc_delete(struct net_device *dev,
+		void *addr, int alen, int all) { return 0; }
+static inline int dev_mc_add(struct net_device *dev,
+		void *addr, int alen, int newonly) { return 0; }
+#define		dev_mc_discard(a)
+#define		dev_mcast_init()
+#endif
 extern void		dev_set_promiscuity(struct net_device *dev, int inc);
 extern void		dev_set_allmulti(struct net_device *dev, int inc);
 extern void		netdev_state_change(struct net_device *dev);
 extern void		netdev_features_change(struct net_device *dev);
 /* Load a device via the kmod */
 extern void		dev_load(const char *name);
-extern void		dev_mcast_init(void);
 extern int		netdev_max_backlog;
 extern int		weight_p;
 extern int		netdev_set_master(struct net_device *dev, struct net_device *master);
diff --git a/include/linux/netfilter_ipv4.h b/include/linux/netfilter_ipv4.h
index ceae87a..2af23c7 100644
--- a/include/linux/netfilter_ipv4.h
+++ b/include/linux/netfilter_ipv4.h
@@ -57,6 +57,9 @@ enum nf_ip_hook_priorities {
 	NF_IP_PRI_RAW = -300,
 	NF_IP_PRI_SELINUX_FIRST = -225,
 	NF_IP_PRI_CONNTRACK = -200,
+#ifdef CONFIG_NETFILTER_RALINK_SWQOS_SUPPORT
+	NF_IP_PRI_NAT_DST_RALINK_QOS = -170,
+#endif
 	NF_IP_PRI_MANGLE = -150,
 	NF_IP_PRI_NAT_DST = -100,
 	NF_IP_PRI_FILTER = 0,
diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index 2a20f48..6cb13fd 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -25,7 +25,9 @@
 #define NETLINK_SCSITRANSPORT	18	/* SCSI Transports */
 #define NETLINK_ECRYPTFS	19
 
-#define MAX_LINKS 32		
+#define NETLINK_CSR             38
+
+#define MAX_LINKS 64 /* update for csr_test, by bobtseng 2006.5.15. */
 
 struct sockaddr_nl
 {
diff --git a/include/linux/pci_ids.h b/include/linux/pci_ids.h
index 600308f..e19e199 100644
--- a/include/linux/pci_ids.h
+++ b/include/linux/pci_ids.h
@@ -1623,6 +1623,9 @@
 #define PCI_VENDOR_ID_SATSAGEM		0x1267
 #define PCI_DEVICE_ID_SATSAGEM_NICCY	0x1016
 
+#define PCI_VENDOR_ID_SILICON_MOTION		0x126f
+#define PCI_DEVICE_ID_SM501_VOYAGER_GX_REV_AA	0x0501
+#define PCI_DEVICE_ID_SM501_VOYAGER_GX_REV_B	0x0510
 
 #define PCI_VENDOR_ID_ENSONIQ		0x1274
 #define PCI_DEVICE_ID_ENSONIQ_CT5880	0x5880
diff --git a/include/linux/sched.h b/include/linux/sched.h
index 49fe299..d289e04 100644
--- a/include/linux/sched.h
+++ b/include/linux/sched.h
@@ -520,7 +520,7 @@ struct signal_struct {
  * MAX_RT_PRIO must not be smaller than MAX_USER_RT_PRIO.
  */
 
-#define MAX_USER_RT_PRIO	100
+#define MAX_USER_RT_PRIO	CONFIG_MAX_USER_RT_PRIO
 #define MAX_RT_PRIO		MAX_USER_RT_PRIO
 
 #define MAX_PRIO		(MAX_RT_PRIO + 40)
diff --git a/include/linux/serial.h b/include/linux/serial.h
index 33fc8cb..c69c6b9 100644
--- a/include/linux/serial.h
+++ b/include/linux/serial.h
@@ -76,7 +76,8 @@ struct serial_struct {
 #define PORT_16654	11
 #define PORT_16850	12
 #define PORT_RSA	13	/* RSA-DV II/S card */
-#define PORT_MAX	13
+#define PORT_SB1250	14
+#define PORT_MAX	14
 
 #define SERIAL_IO_PORT	0
 #define SERIAL_IO_HUB6	1
diff --git a/include/linux/serialP.h b/include/linux/serialP.h
index e811a61..e474242 100644
--- a/include/linux/serialP.h
+++ b/include/linux/serialP.h
@@ -24,6 +24,7 @@
 #include <linux/interrupt.h>
 #include <linux/circ_buf.h>
 #include <linux/wait.h>
+#include <linux/serial.h>
 
 struct serial_state {
 	int	magic;
diff --git a/include/linux/serial_reg.h b/include/linux/serial_reg.h
index 3c8a6aa..5a41132 100644
--- a/include/linux/serial_reg.h
+++ b/include/linux/serial_reg.h
@@ -14,13 +14,68 @@
 #ifndef _LINUX_SERIAL_REG_H
 #define _LINUX_SERIAL_REG_H
 
-/*
- * DLAB=0
+#if defined (CONFIG_RALINK_RT2880) || defined (CONFIG_RALINK_RT3052) || defined (CONFIG_RALINK_RT3352) || \
+    defined (CONFIG_RALINK_RT2883) || defined (CONFIG_RALINK_RT3883) || defined (CONFIG_RALINK_RT5350)
+
+#define UART_RX		0	/* In:  Receive buffer (DLAB=0) */
+
+#define UART_TX		1	/* Out: Transmit buffer (DLAB=0) */
+#define UART_TRG	1	/* (LCR=BF) FCTR bit 7 selects Rx or Tx
+				 * In: Fifo count
+				 * Out: Fifo custom trigger levels
+				 * XR16C85x only
+				 */
+
+#define UART_IER	2	/* Out: Interrupt Enable Register */
+#define UART_FCTR	2	/* (LCR=BF) Feature Control Register
+				 * XR16C85x only
+				 */
+
+#define UART_IIR	3	/* In:  Interrupt ID Register */
+#define UART_EFR	3	/* I/O: Extended Features Register */
+				/* (DLAB=1, 16C660 only) */
+
+#define UART_FCR	4 	/* Out: FIFO Control Register */
+#define UART_LCR	5	/* Out: Line Control Register */
+#define UART_MCR	6	/* Out: Modem Control Register */
+#define UART_LSR	7	/* In:  Line Status Register */
+#define UART_MSR	8	/* In:  Modem Status Register */
+#define UART_SCR	9	/* I/O: Scratch Register */
+#define UART_DLL	10	/* Out: Divisor Latch Low (DLAB=1) */
+/* Since surfboard uart cannot be accessed by byte, using UART_DLM will cause
+ * unpredictable values to be written to the Divisor Latch
  */
+#define UART_DLM	11	/* Out: Divisor Latch High (DLAB=1) */
+
+#else
+
 #define UART_RX		0	/* In:  Receive buffer */
 #define UART_TX		0	/* Out: Transmit buffer */
+#define UART_DLL	0	/* Out: Divisor Latch Low */
+#define UART_TRG	0	/* FCTR bit 7 selects Rx or Tx
+				 * In: Fifo count
+				 * Out: Fifo custom trigger levels */
 
+#define UART_DLM	1	/* Out: Divisor Latch High */
 #define UART_IER	1	/* Out: Interrupt Enable Register */
+#define UART_FCTR	1	/* Feature Control Register */
+
+#define UART_IIR	2	/* In:  Interrupt ID Register */
+#define UART_FCR	2	/* Out: FIFO Control Register */
+#define UART_EFR	2	/* I/O: Extended Features Register */
+
+#define UART_LCR	3	/* Out: Line Control Register */
+#define UART_MCR	4	/* Out: Modem Control Register */
+#define UART_LSR	5	/* In:  Line Status Register */
+#define UART_MSR	6	/* In:  Modem Status Register */
+#define UART_SCR	7	/* I/O: Scratch Register */
+#define UART_EMSR	7	/* Extended Mode Select Register */
+
+#endif
+/*
+ * DLAB=0
+ */
+//#define UART_IER	1	/* Out: Interrupt Enable Register */
 #define UART_IER_MSI		0x08 /* Enable Modem status interrupt */
 #define UART_IER_RLSI		0x04 /* Enable receiver line status interrupt */
 #define UART_IER_THRI		0x02 /* Enable Transmitter holding register int. */
@@ -30,7 +85,7 @@
  */
 #define UART_IERX_SLEEP		0x10 /* Enable sleep mode */
 
-#define UART_IIR	2	/* In:  Interrupt ID Register */
+//#define UART_IIR	2	/* In:  Interrupt ID Register */
 #define UART_IIR_NO_INT		0x01 /* No interrupts pending */
 #define UART_IIR_ID		0x06 /* Mask for the interrupt ID */
 #define UART_IIR_MSI		0x00 /* Modem status interrupt */
@@ -38,7 +93,7 @@
 #define UART_IIR_RDI		0x04 /* Receiver data interrupt */
 #define UART_IIR_RLSI		0x06 /* Receiver line status interrupt */
 
-#define UART_FCR	2	/* Out: FIFO Control Register */
+//#define UART_FCR	2	/* Out: FIFO Control Register */
 #define UART_FCR_ENABLE_FIFO	0x01 /* Enable the FIFO */
 #define UART_FCR_CLEAR_RCVR	0x02 /* Clear the RCVR FIFO */
 #define UART_FCR_CLEAR_XMIT	0x04 /* Clear the XMIT FIFO */
@@ -81,7 +136,7 @@
 #define UART_FCR6_T_TRIGGER_30	0x30 /* Mask for transmit trigger set at 30 */
 #define UART_FCR7_64BYTE	0x20 /* Go into 64 byte mode (TI16C750) */
 
-#define UART_LCR	3	/* Out: Line Control Register */
+//#define UART_LCR	3	/* Out: Line Control Register */
 /*
  * Note: if the word length is 5 bits (UART_LCR_WLEN5), then setting 
  * UART_LCR_STOP will select 1.5 stop bits, not 2 stop bits.
@@ -97,7 +152,7 @@
 #define UART_LCR_WLEN7		0x02 /* Wordlength: 7 bits */
 #define UART_LCR_WLEN8		0x03 /* Wordlength: 8 bits */
 
-#define UART_MCR	4	/* Out: Modem Control Register */
+//#define UART_MCR	4	/* Out: Modem Control Register */
 #define UART_MCR_CLKSEL		0x80 /* Divide clock by 4 (TI16C752, EFR[4]=1) */
 #define UART_MCR_TCRTLR		0x40 /* Access TCR/TLR (TI16C752, EFR[4]=1) */
 #define UART_MCR_XONANY		0x20 /* Enable Xon Any (TI16C752, EFR[4]=1) */
@@ -108,7 +163,7 @@
 #define UART_MCR_RTS		0x02 /* RTS complement */
 #define UART_MCR_DTR		0x01 /* DTR complement */
 
-#define UART_LSR	5	/* In:  Line Status Register */
+//#define UART_LSR	5	/* In:  Line Status Register */
 #define UART_LSR_TEMT		0x40 /* Transmitter empty */
 #define UART_LSR_THRE		0x20 /* Transmit-hold-register empty */
 #define UART_LSR_BI		0x10 /* Break interrupt indicator */
@@ -117,7 +172,7 @@
 #define UART_LSR_OE		0x02 /* Overrun error indicator */
 #define UART_LSR_DR		0x01 /* Receiver data ready */
 
-#define UART_MSR	6	/* In:  Modem Status Register */
+//#define UART_MSR	6	/* In:  Modem Status Register */
 #define UART_MSR_DCD		0x80 /* Data Carrier Detect */
 #define UART_MSR_RI		0x40 /* Ring Indicator */
 #define UART_MSR_DSR		0x20 /* Data Set Ready */
@@ -128,18 +183,18 @@
 #define UART_MSR_DCTS		0x01 /* Delta CTS */
 #define UART_MSR_ANY_DELTA	0x0F /* Any of the delta bits! */
 
-#define UART_SCR	7	/* I/O: Scratch Register */
+//#define UART_SCR	7	/* I/O: Scratch Register */
 
 /*
  * DLAB=1
  */
-#define UART_DLL	0	/* Out: Divisor Latch Low */
-#define UART_DLM	1	/* Out: Divisor Latch High */
+//#define UART_DLL	0	/* Out: Divisor Latch Low */
+//#define UART_DLM	1	/* Out: Divisor Latch High */
 
 /*
  * LCR=0xBF (or DLAB=1 for 16C660)
  */
-#define UART_EFR	2	/* I/O: Extended Features Register */
+//#define UART_EFR	2	/* I/O: Extended Features Register */
 #define UART_EFR_CTS		0x80 /* CTS flow control */
 #define UART_EFR_RTS		0x40 /* RTS flow control */
 #define UART_EFR_SCD		0x20 /* Special character detect */
@@ -165,9 +220,9 @@
 /*
  * LCR=0xBF, XR16C85x
  */
-#define UART_TRG	0	/* FCTR bit 7 selects Rx or Tx
-				 * In: Fifo count
-				 * Out: Fifo custom trigger levels */
+//#define UART_TRG	0	/* FCTR bit 7 selects Rx or Tx
+//				 * In: Fifo count
+//				 * Out: Fifo custom trigger levels */
 /*
  * These are the definitions for the Programmable Trigger Register
  */
@@ -181,7 +236,7 @@
 #define UART_TRG_120		0x78
 #define UART_TRG_128		0x80
 
-#define UART_FCTR	1	/* Feature Control Register */
+//#define UART_FCTR	1	/* Feature Control Register */
 #define UART_FCTR_RTS_NODELAY	0x00  /* RTS flow control delay */
 #define UART_FCTR_RTS_4DELAY	0x01
 #define UART_FCTR_RTS_6DELAY	0x02
@@ -199,7 +254,7 @@
 /*
  * LCR=0xBF, FCTR[6]=1
  */
-#define UART_EMSR	7	/* Extended Mode Select Register */
+//#define UART_EMSR	7	/* Extended Mode Select Register */
 #define UART_EMSR_FIFO_COUNT	0x01  /* Rx/Tx select */
 #define UART_EMSR_ALT_COUNT	0x02  /* Alternating count select */
 
diff --git a/include/linux/skbuff.h b/include/linux/skbuff.h
index 5992f65..09423dd 100644
--- a/include/linux/skbuff.h
+++ b/include/linux/skbuff.h
@@ -294,6 +294,10 @@ struct sk_buff {
 #if defined(CONFIG_NF_CONNTRACK) || defined(CONFIG_NF_CONNTRACK_MODULE)
 	struct sk_buff		*nfct_reasm;
 #endif
+#if defined(CONFIG_IMQ) || defined(CONFIG_IMQ_MODULE)
+	unsigned char		imq_flags;
+	struct nf_info		*nf_info;
+#endif
 #ifdef CONFIG_BRIDGE_NETFILTER
 	struct nf_bridge_info	*nf_bridge;
 #endif
diff --git a/include/linux/socket.h b/include/linux/socket.h
index fcd35a2..1369d04 100644
--- a/include/linux/socket.h
+++ b/include/linux/socket.h
@@ -284,6 +284,8 @@ struct ucred {
 #define SOL_DCCP	269
 #define SOL_NETLINK	270
 #define SOL_TIPC	271
+#define SOL_RXRPC	272
+#define SOL_PPPOL2TP	273
 
 /* IPX options */
 #define IPX_TYPE	1
diff --git a/include/linux/swap.h b/include/linux/swap.h
index 0068688..2f6591e 100644
--- a/include/linux/swap.h
+++ b/include/linux/swap.h
@@ -31,7 +31,7 @@ static inline int current_is_kswapd(void)
  * on 32-bit-pgoff_t architectures.  And that assumes that the architecture packs
  * the type/offset into the pte as 5/27 as well.
  */
-#define MAX_SWAPFILES_SHIFT	5
+#define MAX_SWAPFILES_SHIFT	CONFIG_MAX_SWAPFILES_SHIFT
 #ifndef CONFIG_MIGRATION
 #define MAX_SWAPFILES		(1 << MAX_SWAPFILES_SHIFT)
 #else
diff --git a/include/linux/swapops.h b/include/linux/swapops.h
index ceb6cc5..e5c5a05 100644
--- a/include/linux/swapops.h
+++ b/include/linux/swapops.h
@@ -12,6 +12,7 @@
 #define SWP_TYPE_SHIFT(e)	(sizeof(e.val) * 8 - MAX_SWAPFILES_SHIFT)
 #define SWP_OFFSET_MASK(e)	((1UL << SWP_TYPE_SHIFT(e)) - 1)
 
+#if MAX_SWAPFILES_SHIFT > 0
 /*
  * Store a type+offset into a swp_entry_t in an arch-independent format
  */
@@ -41,6 +42,26 @@ static inline pgoff_t swp_offset(swp_entry_t entry)
 {
 	return entry.val & SWP_OFFSET_MASK(entry);
 }
+#else /* avoid undefined shift operations */
+
+static inline swp_entry_t swp_entry(unsigned type, pgoff_t offset)
+{
+	swp_entry_t ret;
+	ret.val = offset;
+	return ret;
+}
+
+static inline unsigned swp_type(swp_entry_t entry)
+{
+	return 0;
+}
+
+static inline pgoff_t swp_offset(swp_entry_t entry)
+{
+	return entry.val;
+}
+
+#endif
 
 /*
  * Convert the arch-dependent pte representation of a swp_entry_t into an
diff --git a/include/linux/tty.h b/include/linux/tty.h
index dee72b9..7ce9e2e 100644
--- a/include/linux/tty.h
+++ b/include/linux/tty.h
@@ -24,7 +24,7 @@
 #define NR_PTYS	CONFIG_LEGACY_PTY_COUNT   /* Number of legacy ptys */
 #define NR_UNIX98_PTY_DEFAULT	4096      /* Default maximum for Unix98 ptys */
 #define NR_UNIX98_PTY_MAX	(1 << MINORBITS) /* Absolute limit */
-#define NR_LDISCS		17
+#define NR_LDISCS		CONFIG_NR_LDISCS
 
 /* line disciplines */
 #define N_TTY		0
diff --git a/include/linux/usb_gadget.h b/include/linux/usb_gadget.h
index e17186d..a53684e 100644
--- a/include/linux/usb_gadget.h
+++ b/include/linux/usb_gadget.h
@@ -457,6 +457,7 @@ struct usb_gadget_ops {
 	int	(*pullup) (struct usb_gadget *, int is_on);
 	int	(*ioctl)(struct usb_gadget *,
 				unsigned code, unsigned long param);
+	int     (*lpm_support) (struct usb_gadget *);
 };
 
 /**
diff --git a/include/linux/xattr.h b/include/linux/xattr.h
index def131a..7304ddb 100644
--- a/include/linux/xattr.h
+++ b/include/linux/xattr.h
@@ -51,10 +51,17 @@ ssize_t vfs_listxattr(struct dentry *d, char *list, size_t size);
 int vfs_setxattr(struct dentry *, char *, void *, size_t, int);
 int vfs_removexattr(struct dentry *, char *);
 
+#ifdef CONFIG_XATTR
 ssize_t generic_getxattr(struct dentry *dentry, const char *name, void *buffer, size_t size);
 ssize_t generic_listxattr(struct dentry *dentry, char *buffer, size_t buffer_size);
 int generic_setxattr(struct dentry *dentry, const char *name, const void *value, size_t size, int flags);
 int generic_removexattr(struct dentry *dentry, const char *name);
+#else
+#define generic_getxattr NULL
+#define generic_listxattr NULL
+#define generic_setxattr NULL
+#define generic_removexattr NULL
+#endif
 
 #endif  /*  __KERNEL__  */
 
diff --git a/include/net/af_unix.h b/include/net/af_unix.h
index c0398f5..3436a46 100644
--- a/include/net/af_unix.h
+++ b/include/net/af_unix.h
@@ -10,7 +10,11 @@ extern void unix_inflight(struct file *fp);
 extern void unix_notinflight(struct file *fp);
 extern void unix_gc(void);
 
+#ifdef CONFIG_NET_SMALL
+#define UNIX_HASH_SIZE	16
+#else
 #define UNIX_HASH_SIZE	256
+#endif
 
 extern struct hlist_head unix_socket_table[UNIX_HASH_SIZE + 1];
 extern spinlock_t unix_table_lock;
diff --git a/include/net/inetpeer.h b/include/net/inetpeer.h
index aa10a81..45bea3b 100644
--- a/include/net/inetpeer.h
+++ b/include/net/inetpeer.h
@@ -31,6 +31,7 @@ struct inet_peer
 	unsigned long		tcp_ts_stamp;
 };
 
+#ifdef CONFIG_INETPEER
 void			inet_initpeers(void) __init;
 
 /* can be called with or without local BH being disabled */
@@ -51,5 +52,13 @@ static inline __u16	inet_getid(struct inet_peer *p, int more)
 	spin_unlock_bh(&inet_peer_idlock);
 	return id;
 }
+#else
+
+#define inet_getpeer(a, b) (0)
+#define inet_putpeer(b)
+static void inline inet_initpeers(void) { }
+#define inet_getid(a, b) (0)
+
+#endif
 
 #endif /* _NET_INETPEER_H */
diff --git a/include/net/netfilter/nf_conntrack.h b/include/net/netfilter/nf_conntrack.h
index 0e690e3..cef4395 100644
--- a/include/net/netfilter/nf_conntrack.h
+++ b/include/net/netfilter/nf_conntrack.h
@@ -128,6 +128,22 @@ struct nf_conn
 	u_int32_t secmark;
 #endif
 
+#if defined(CONFIG_NETFILTER_XT_MATCH_LAYER7) || \
+    defined(CONFIG_NETFILTER_XT_MATCH_LAYER7_MODULE)
+	struct {
+		/*
+		 * e.g. "http". NULL before decision. "unknown" after decision
+		 * if no match.
+		 */
+		char *app_proto;
+		/*
+		 * application layer data so far. NULL after match decision.
+		 */
+		char *app_data;
+		unsigned int app_data_len;
+	} layer7;
+#endif
+
 	/* Storage reserved for other modules: */
 	union nf_conntrack_proto proto;
 
diff --git a/include/net/protocol.h b/include/net/protocol.h
index 105bf12..e9c8ac5 100644
--- a/include/net/protocol.h
+++ b/include/net/protocol.h
@@ -29,7 +29,11 @@
 #include <linux/ipv6.h>
 #endif
 
+#ifdef CONFIG_NET_SMALL
+#define MAX_INET_PROTOS 32
+#else
 #define MAX_INET_PROTOS	256		/* Must be a power of 2		*/
+#endif
 
 
 /* This is used to register protocols. */
diff --git a/include/net/sock.h b/include/net/sock.h
index 2c7d60c..5db7421 100644
--- a/include/net/sock.h
+++ b/include/net/sock.h
@@ -887,6 +887,7 @@ extern void sock_init_data(struct socket *sock, struct sock *sk);
  *
  */
 
+#ifdef CONFIG_NET_SK_FILTER
 static inline int sk_filter(struct sock *sk, struct sk_buff *skb)
 {
 	int err;
@@ -941,6 +942,13 @@ static inline void sk_filter_charge(struct sock *sk, struct sk_filter *fp)
 	atomic_inc(&fp->refcnt);
 	atomic_add(sk_filter_len(fp), &sk->sk_omem_alloc);
 }
+#else
+
+#define sk_filter(a, b) (0)
+#define sk_filter_release(a, fp)
+#define sk_filter_charge(a, b)
+
+#endif
 
 /*
  * Socket reference counting postulates.
diff --git a/init/Kconfig b/init/Kconfig
index b170aa1..2069196 100644
--- a/init/Kconfig
+++ b/init/Kconfig
@@ -306,7 +306,7 @@ config RELAY
 
 config BLK_DEV_INITRD
 	bool "Initial RAM filesystem and RAM disk (initramfs/initrd) support"
-	depends on BROKEN || !FRV
+	depends on (BROKEN || !FRV) && RT2880_ROOTFS_IN_RAM
 	help
 	  The initial RAM filesystem is a ramfs which is loaded by the
 	  boot loader (loadlin or lilo) and that is mounted as root
@@ -413,15 +413,33 @@ config HOTPLUG
 	  disabling this option for embedded systems that do not use modules, a
 	  dynamic /dev tree, or dynamic device discovery.  Just say Y.
 
+config PRINTK_FUNC
+	default y
+	bool "Enable printk function in the kernel" if EMBEDDED
+	help
+	  This option controls whether the printk function is compiled
+	  into the kernel or not. Removing it eliminates a small amount of
+	  code size from the kernel, which is OK if it is not being used.
+	  See CONFIG_PRINTK to disable the function calls to printk(),
+	  which is where the big win comes in reducing kernel size.
+
 config PRINTK
 	default y
-	bool "Enable support for printk" if EMBEDDED
+	bool "Enable support for printk message" if EMBEDDED
+	depends on PRINTK_FUNC
 	help
 	  This option enables normal printk support. Removing it
 	  eliminates most of the message strings from the kernel image
 	  and makes the kernel more or less silent. As this makes it
-	  very difficult to diagnose system problems, saying N here is
-	  strongly discouraged.
+	  very difficult to diagnose system problems, saying N here on
+	  non-embedded systems is strongly discouraged.
+
+	  With this set to 'N', if the printk function is still enabled,
+	  (see CONFIG_PRINTK_FUNC) you can enable printk messages from
+	  a single file, by putting "#define DO_PRINTK 1" at the top of
+	  the file.  This must appear before any #include lines.
+	  This makes it possible to have fine-grained control over
+	  which printk messages to include in the kernel.
 
 config BUG
 	bool "BUG() support" if EMBEDDED
@@ -492,6 +510,158 @@ config VM_EVENT_COUNTERS
 	  on EMBEDDED systems.  /proc/vmstat will only show page counts
 	  if VM event counters are disabled.
 
+menuconfig TINY
+	bool "Configure tiny kernel features"
+	help
+	  This option allows certain base kernel options and settings
+          to be disabled or tweaked. This is for specialized
+          environments which can tolerate a "non-standard" tiny kernel.
+          Only use this if you really know what you are doing.
+
+config NET_SMALL
+	default n
+	bool "Enable various size reductions for networking" if TINY
+	help
+	  This reduces the size of miscellaneous networking data structures.
+	  Currently a placeholder.
+
+config LINUXTINY_DO_UNINLINE
+	bool "un-inline several functions for smaller kernel size" if TINY
+	default n
+	help
+	  Un-inline some function for smaller kernel size.
+
+config PANIC
+	default y
+	bool "Enable panic reporting code" if TINY
+	help
+	  Disabling this completely removes panic handling code.
+	  Warning: this can result in data loss if a panic condition
+	  occurs, as the kernel may ignore the condition entirely.<F11>jj
+
+config FULL_PANIC
+	depends PANIC
+	default y
+	bool "Full panic reporting data" if TINY
+	help
+	  This includes text descriptions of panics in addition to stack dumps.
+	  Disabling compiles out the explanations for panics, saving
+	  string space. Use with caution.
+
+config MEMPOOL
+	default y
+	bool "Use mempool allocator" if TINY
+	help
+	  The mempool allocator attempts keep a reserve pool of
+	  various objects available for use in low-memory situations.
+	  Disabling this feature may make more memory available and
+	  will somewhat decrease code size, but with a higher risk of
+	  deadlock under some loads.
+
+config AIO
+	default y
+	bool "Enable AIO support" if TINY
+	help
+	  This option enables POSIX async IO which may be used by
+	  some high performance threaded applications. Disabling
+	  this option saves about 5k.
+
+config XATTR
+	default y
+	bool "Enable filesystem extended attribute support" if TINY
+	help
+	  This enables the filesystem extended attribute syscalls.
+
+config FILE_LOCKING
+	default y
+	bool "Enable POSIX file locking API" if TINY
+	help
+	  This enables standard file locking support.
+
+config ETHTOOL
+	depends NET
+	default y
+	bool "Enable ethtool support" if TINY
+	help
+	  Disabling this option removes support for configuring
+	  ethernet device features via ethtool. Saves about 6k.
+
+config INETPEER
+	default y
+	bool "Enable INET peer information storage" if TINY
+	help
+	  This allows storing various information about network peers.
+	  Disabling saves about 2k.
+
+config NET_SK_FILTER
+	default y
+	depends NET
+	bool "Enable network socket filter" if TINY
+	help
+	  This enables the basic kernel level socket filtering, not to
+	  be confused with netfilter. Required by PPP.
+
+config NET_DEV_MULTICAST
+	default y
+	depends NET
+	bool "Enable device multicast support" if TINY
+	help
+	  This enables the core device multicast list management code.
+
+config IGMP
+	depends NET
+	default y
+	bool "Enable IGMP support" if TINY && !IP_MULTICAST
+	help
+	  This includes support for the Internet group management
+	  protocol, used for multicast.
+
+config MAX_SWAPFILES_SHIFT
+	int "Number of swap files log2 (0 => 1, 5 => 32)" if TINY
+	range 0 5
+	default 5
+	help
+	  Select the maximum number of swapfiles (5 for default).
+
+config NR_LDISCS
+	int "Number of tty line disciplines (1~16)" if TINY
+	range 1 16
+	default 16
+	help
+	  Select the maximum number of tty line disciplines. Embedded systems
+	  can probably get by with only a few of these.
+
+config MAX_USER_RT_PRIO
+	int "Number of realtime priority levels (5~100)" if TINY
+	range 5 100
+	default 100
+	help
+	  This option allows reducing the size of the O(1) scheduler arrays.
+
+menuconfig TINY_EXPERIMENTAL
+	bool "Configure experimental tiny kernel features"
+	help
+	  This option allows certain base kernel options and settings
+          to be disabled or tweaked. This is for specialized
+          environments which can tolerate a "non-standard" tiny kernel.
+          Only use this if you really know what you are doing.
+
+config PDFLUSH
+	default y
+	bool "Enable pdflush daemon" if TINY_EXPERIMENTAL
+	help
+	  Enable kernel pdflush daemon.
+
+config BINFMT_ELF_AOUT
+	bool "ELF binaries with a.out linkage" if TINY_EXPERIMENTAL
+	depends on BINFMT_ELF
+	default y
+	help
+	  The kernel may support ELF executables which use an a.out format
+	  interpreter (dynamic linker) and/or a.out shared libraries, in
+	  addition to the usual ELF-ELF setups. You shouldn't need this.
+
+
 endmenu		# General setup
 
 config RT_MUTEXES
diff --git a/init/do_mounts.c b/init/do_mounts.c
index dc1ec08..dc3a12d 100644
--- a/init/do_mounts.c
+++ b/init/do_mounts.c
@@ -15,7 +15,7 @@
 #include <linux/nfs_mount.h>
 
 #include "do_mounts.h"
-
+int mount_fail = 0;
 extern int get_filesystem_list(char * buf);
 
 int __initdata rd_doload;	/* 1 = load RAM disk, 0 = don't load */
@@ -208,6 +208,7 @@ fail:
 
 static int __init root_dev_setup(char *line)
 {
+	printk(KERN_EMERG "root_dev_setup: line=[%s]\n", line);
 	strlcpy(saved_root_name, line, sizeof(saved_root_name));
 	return 1;
 }
@@ -228,6 +229,17 @@ static int __init fs_names_setup(char *str)
 	return 1;
 }
 
+/*
+static char __initdata bootstate[3];
+static int __init bootstate_setup(char *line)
+{
+	printk(KERN_EMERG "************** bootstate line = [%s]\n", line);
+	strlcpy(bootstate, line, sizeof(bootstate));
+	printk(KERN_EMERG "************** bootstate = [%s]\n", bootstate);
+	return 1;
+}
+*/
+
 static unsigned int __initdata root_delay;
 static int __init root_delay_setup(char *str)
 {
@@ -237,6 +249,7 @@ static int __init root_delay_setup(char *str)
 
 __setup("rootflags=", root_data_setup);
 __setup("rootfstype=", fs_names_setup);
+//__setup("bootstate=", bootstate_setup);
 __setup("rootdelay=", root_delay_setup);
 
 static void __init get_fs_names(char *page)
@@ -274,7 +287,7 @@ static int __init do_mount_root(char *name, char *fs, int flags, void *data)
 
 	sys_chdir("/root");
 	ROOT_DEV = current->fs->pwdmnt->mnt_sb->s_dev;
-	printk("VFS: Mounted root (%s filesystem)%s.\n",
+	printk("VFS: [%s] Mounted root (%s filesystem)%s.\n", name,
 	       current->fs->pwdmnt->mnt_sb->s_type->name,
 	       current->fs->pwdmnt->mnt_sb->s_flags & MS_RDONLY ? 
 	       " readonly" : "");
@@ -290,14 +303,19 @@ void __init mount_block_root(char *name, int flags)
 #else
 	const char *b = name;
 #endif
-
+printk(KERN_EMERG "name is [%s]\n", name);
 	get_fs_names(fs_names);
+printk(KERN_EMERG "fs_names is [%s]\n", fs_names);
 retry:
 	for (p = fs_names; *p; p += strlen(p)+1) {
+printk(KERN_EMERG "fs_names p is [%s], flags is 0x%X\n", p, flags);
 		int err = do_mount_root(name, p, flags, root_mount_data);
 		switch (err) {
 			case 0:
+{
+mount_fail = 0;
 				goto out;
+}
 			case -EACCES:
 				flags |= MS_RDONLY;
 				goto retry;
@@ -326,6 +344,9 @@ retry:
 	__bdevname(ROOT_DEV, b);
 #endif
 	panic("VFS: Unable to mount root fs on %s", b);
+
+	mount_fail = 1;
+
 out:
 	putname(fs_names);
 }
@@ -420,13 +441,17 @@ void __init prepare_namespace(void)
 		msleep(100);
 
 	md_run_setup();
-
+printk(KERN_EMERG "saved_root_name is [%s]\n", saved_root_name);
+//printk(KERN_EMERG "bootstate is [%s]\n", bootstate);
 	if (saved_root_name[0]) {
 		root_device_name = saved_root_name;
+printk(KERN_EMERG "root_device_name is [%s]\n", root_device_name);
+//		if (!strncmp(root_device_name, "/mtd/mtd", 8)) {
 		if (!strncmp(root_device_name, "mtd", 3)) {
 			mount_block_root(root_device_name, root_mountflags);
 			goto out;
 		}
+
 		ROOT_DEV = name_to_dev_t(root_device_name);
 		if (strncmp(root_device_name, "/dev/", 5) == 0)
 			root_device_name += 5;
@@ -440,7 +465,44 @@ void __init prepare_namespace(void)
 	if (is_floppy && rd_doload && rd_load_disk(0))
 		ROOT_DEV = Root_RAM0;
 
+char test1[20] = "/dev/mtdblock0";
+char test2[20] = "/dev/mtdblock1";
+char test3[20] = "/dev/mtdblock2";
+char test4[20] = "/dev/mtdblock3";
+
+if(strlen(saved_root_name) < 6)
+{
+	printk(KERN_EMERG "No root found, using default root=%s\n", test3);
+	ROOT_DEV = name_to_dev_t(test3);
+}
+else
+	ROOT_DEV = name_to_dev_t(saved_root_name);
+
+	mount_root();
+printk(KERN_EMERG "mount_fail 0 is %d\n", mount_fail);
+
+if(mount_fail ==1)
+{
+	printk(KERN_EMERG "Mounting root fail!!....Restart System in 10 seconds!!\n");
+	mdelay(10000);
+	emergency_restart();
+}
+#if 0
+if(mount_fail == 1)
+{
+	ROOT_DEV = name_to_dev_t(test2);
+
 	mount_root();
+}
+printk(KERN_EMERG "mount_fail 1 is %d\n", mount_fail);
+if(mount_fail == 1)
+{
+	ROOT_DEV = name_to_dev_t(test3);
+
+	mount_root();
+}
+printk(KERN_EMERG "mount_fail 2 is %d\n", mount_fail);
+#endif
 out:
 	sys_mount(".", "/", NULL, MS_MOVE, NULL);
 	sys_chroot(".");
diff --git a/init/do_mounts_rd.c b/init/do_mounts_rd.c
index ed652f4..ca66edd 100644
--- a/init/do_mounts_rd.c
+++ b/init/do_mounts_rd.c
@@ -5,6 +5,7 @@
 #include <linux/ext2_fs.h>
 #include <linux/romfs_fs.h>
 #include <linux/cramfs_fs.h>
+#include <linux/squashfs_fs.h>
 #include <linux/initrd.h>
 #include <linux/string.h>
 
@@ -39,6 +40,7 @@ static int __init crd_load(int in_fd, int out_fd);
  * numbers could not be found.
  *
  * We currently check for the following magic numbers:
+ * 	squashfs
  * 	minix
  * 	ext2
  *	romfs
@@ -53,6 +55,7 @@ identify_ramdisk_image(int fd, int start_block)
 	struct ext2_super_block *ext2sb;
 	struct romfs_super_block *romfsb;
 	struct cramfs_super *cramfsb;
+	struct squashfs_super_block *squashfsb;
 	int nblocks = -1;
 	unsigned char *buf;
 
@@ -64,6 +67,7 @@ identify_ramdisk_image(int fd, int start_block)
 	ext2sb = (struct ext2_super_block *) buf;
 	romfsb = (struct romfs_super_block *) buf;
 	cramfsb = (struct cramfs_super *) buf;
+	squashfsb = (struct squashfs_super_block *) buf;
 	memset(buf, 0xe5, size);
 
 	/*
@@ -101,6 +105,19 @@ identify_ramdisk_image(int fd, int start_block)
 		goto done;
 	}
 
+	/* squashfs is at block zero too */
+	if (squashfsb->s_magic == SQUASHFS_MAGIC) {
+		printk(KERN_NOTICE
+			"RAMDISK: squashfs filesystem found at block %d\n", 
+			start_block);
+		if (squashfsb->s_major < 3)
+			nblocks = (squashfsb->bytes_used_2+BLOCK_SIZE-1)>>BLOCK_SIZE_BITS;
+		else
+			nblocks = (squashfsb->bytes_used+BLOCK_SIZE-1)>>BLOCK_SIZE_BITS;
+		goto done;
+	}
+
+
 	/*
 	 * Read block 1 to test for minix and ext2 superblock
 	 */
diff --git a/init/main.c b/init/main.c
index a92989e..46ff2d5 100644
--- a/init/main.c
+++ b/init/main.c
@@ -770,6 +770,7 @@ static int noinline init_post(void)
 	run_init_process("/bin/sh");
 
 	panic("No init found.  Try passing init= option to kernel.");
+	return 0;
 }
 
 static int __init init(void * unused)
diff --git a/kernel/panic.c b/kernel/panic.c
index 623d182..e8c390b 100644
--- a/kernel/panic.c
+++ b/kernel/panic.c
@@ -39,15 +39,16 @@ static int __init panic_setup(char *str)
 }
 __setup("panic=", panic_setup);
 
+/* Returns how long it waited in ms */
+long (*panic_blink)(long time);
+EXPORT_SYMBOL(panic_blink);
+
+#ifdef CONFIG_PANIC
 static long no_blink(long time)
 {
 	return 0;
 }
 
-/* Returns how long it waited in ms */
-long (*panic_blink)(long time);
-EXPORT_SYMBOL(panic_blink);
-
 /**
  *	panic - halt the system
  *	@fmt: The text string to print
@@ -57,11 +58,16 @@ EXPORT_SYMBOL(panic_blink);
  *	This function never returns.
  */
  
+#ifdef CONFIG_FULL_PANIC
 NORET_TYPE void panic(const char * fmt, ...)
 {
-	long i;
 	static char buf[1024];
 	va_list args;
+#else
+NORET_TYPE void tiny_panic(int a, ...)
+{
+#endif
+	long i;
 #if defined(CONFIG_S390)
         unsigned long caller = (unsigned long) __builtin_return_address(0);
 #endif
@@ -74,10 +80,14 @@ NORET_TYPE void panic(const char * fmt, ...)
 	preempt_disable();
 
 	bust_spinlocks(1);
+#ifdef CONFIG_FULL_PANIC
 	va_start(args, fmt);
 	vsnprintf(buf, sizeof(buf), fmt, args);
 	va_end(args);
 	printk(KERN_EMERG "Kernel panic - not syncing: %s\n",buf);
+#else
+	printk(KERN_EMERG "Kernel panic - not syncing\n");
+#endif
 	bust_spinlocks(0);
 
 	/*
@@ -96,7 +106,11 @@ NORET_TYPE void panic(const char * fmt, ...)
 	smp_send_stop();
 #endif
 
+#ifdef CONFIG_FULL_PANIC
 	atomic_notifier_call_chain(&panic_notifier_list, 0, buf);
+#else
+	atomic_notifier_call_chain(&panic_notifier_list, 0, "");
+#endif
 
 	if (!panic_blink)
 		panic_blink = no_blink;
@@ -139,7 +153,12 @@ NORET_TYPE void panic(const char * fmt, ...)
 	}
 }
 
+#ifdef CONFIG_FULL_PANIC
 EXPORT_SYMBOL(panic);
+#else
+EXPORT_SYMBOL(tiny_panic);
+#endif
+#endif /* CONFIG_PANIC */
 
 /**
  *	print_tainted - return a string to represent the kernel taint state.
diff --git a/kernel/printk.c b/kernel/printk.c
index 4b47e59..d3c03ba 100644
--- a/kernel/printk.c
+++ b/kernel/printk.c
@@ -16,6 +16,11 @@
  *	01Mar01 Andrew Morton <andrewm@uow.edu.au>
  */
 
+/*
+ * have kernel.h produce real declarations, depending on configuration
+ */
+#define DO_PRINTK 1
+
 #include <linux/kernel.h>
 #include <linux/mm.h>
 #include <linux/tty.h>
@@ -115,7 +120,7 @@ static int preferred_console = -1;
 /* Flag: console code may call schedule() */
 static int console_may_schedule;
 
-#ifdef CONFIG_PRINTK
+#ifdef CONFIG_PRINTK_FUNC
 
 static char __log_buf[__LOG_BUF_LEN];
 static char *log_buf = __log_buf;
@@ -639,14 +644,9 @@ EXPORT_SYMBOL(vprintk);
 
 #else
 
-asmlinkage long sys_syslog(int type, char __user *buf, int len)
-{
-	return -ENOSYS;
-}
-
-static void call_console_drivers(unsigned long start, unsigned long end)
-{
-}
+asmlinkage long sys_syslog(int type, char __user *buf, int len) { return 0; }
+int do_syslog(int type, char __user *buf, int len) { return 0; }
+static void call_console_drivers(unsigned long start, unsigned long end) {}
 
 #endif
 
diff --git a/kernel/sys.c b/kernel/sys.c
index 123b165..e2f4e10 100644
--- a/kernel/sys.c
+++ b/kernel/sys.c
@@ -2198,7 +2198,7 @@ asmlinkage long sys_getcpu(unsigned __user *cpup, unsigned __user *nodep,
 		 * need for a compat_getcpu). 32bit has enough
 		 * padding
 		 */
-		unsigned long t0, t1;
+		unsigned long t0=0, t1=0;
 		get_user(t0, &cache->blob[0]);
 		get_user(t1, &cache->blob[1]);
 		t0++;
diff --git a/kernel/sys_ni.c b/kernel/sys_ni.c
index d7306d0..191986c 100644
--- a/kernel/sys_ni.c
+++ b/kernel/sys_ni.c
@@ -112,6 +112,24 @@ cond_syscall(sys_vm86old);
 cond_syscall(sys_vm86);
 cond_syscall(compat_sys_ipc);
 cond_syscall(compat_sys_sysctl);
+cond_syscall(sys_io_setup);
+cond_syscall(sys_io_destroy);
+cond_syscall(sys_io_submit);
+cond_syscall(sys_io_cancel);
+cond_syscall(sys_io_getevents);
+cond_syscall(sys_setxattr);
+cond_syscall(sys_lsetxattr);
+cond_syscall(sys_fsetxattr);
+cond_syscall(sys_getxattr);
+cond_syscall(sys_lgetxattr);
+cond_syscall(sys_fgetxattr);
+cond_syscall(sys_listxattr);
+cond_syscall(sys_llistxattr);
+cond_syscall(sys_flistxattr);
+cond_syscall(sys_removexattr);
+cond_syscall(sys_lremovexattr);
+cond_syscall(sys_fremovexattr);
+cond_syscall(sys_flock);
 
 /* arch-specific weak syscall entries */
 cond_syscall(sys_pciconfig_read);
diff --git a/kernel/sysctl.c b/kernel/sysctl.c
index c904748..87510bc 100644
--- a/kernel/sysctl.c
+++ b/kernel/sysctl.c
@@ -684,6 +684,7 @@ static ctl_table vm_table[] = {
 		.mode		= 0644,
 		.proc_handler	= &proc_dointvec_userhz_jiffies,
 	},
+#ifdef CONFIG_PDFLUSH
 	{
 		.ctl_name	= VM_NR_PDFLUSH_THREADS,
 		.procname	= "nr_pdflush_threads",
@@ -692,6 +693,7 @@ static ctl_table vm_table[] = {
 		.mode		= 0444 /* read-only*/,
 		.proc_handler	= &proc_dointvec,
 	},
+#endif
 	{
 		.ctl_name	= VM_SWAPPINESS,
 		.procname	= "swappiness",
@@ -931,6 +933,7 @@ static ctl_table fs_table[] = {
 		.extra1		= &minolduid,
 		.extra2		= &maxolduid,
 	},
+#ifdef CONFIG_FILE_LOCKING
 	{
 		.ctl_name	= FS_LEASES,
 		.procname	= "leases-enable",
@@ -939,6 +942,7 @@ static ctl_table fs_table[] = {
 		.mode		= 0644,
 		.proc_handler	= &proc_dointvec,
 	},
+#endif
 #ifdef CONFIG_DNOTIFY
 	{
 		.ctl_name	= FS_DIR_NOTIFY,
@@ -950,6 +954,7 @@ static ctl_table fs_table[] = {
 	},
 #endif
 #ifdef CONFIG_MMU
+#ifdef CONFIG_FILE_LOCKING
 	{
 		.ctl_name	= FS_LEASE_TIME,
 		.procname	= "lease-break-time",
@@ -958,6 +963,8 @@ static ctl_table fs_table[] = {
 		.mode		= 0644,
 		.proc_handler	= &proc_dointvec,
 	},
+#endif
+#ifdef CONFIG_AIO
 	{
 		.ctl_name	= FS_AIO_NR,
 		.procname	= "aio-nr",
@@ -974,6 +981,7 @@ static ctl_table fs_table[] = {
 		.mode		= 0644,
 		.proc_handler	= &proc_doulongvec_minmax,
 	},
+#endif
 #ifdef CONFIG_INOTIFY_USER
 	{
 		.ctl_name	= FS_INOTIFY,
diff --git a/mm/Makefile b/mm/Makefile
index f3c077e..d613770 100644
--- a/mm/Makefile
+++ b/mm/Makefile
@@ -8,7 +8,7 @@ mmu-$(CONFIG_MMU)	:= fremap.o highmem.o madvise.o memory.o mincore.o \
 			   vmalloc.o
 
 obj-y			:= bootmem.o filemap.o mempool.o oom_kill.o fadvise.o \
-			   page_alloc.o page-writeback.o pdflush.o \
+			   page_alloc.o page-writeback.o \
 			   readahead.o swap.o truncate.o vmscan.o \
 			   prio_tree.o util.o mmzone.o vmstat.o backing-dev.o \
 			   $(mmu-y)
@@ -16,6 +16,7 @@ obj-y			:= bootmem.o filemap.o mempool.o oom_kill.o fadvise.o \
 ifeq ($(CONFIG_MMU)$(CONFIG_BLOCK),yy)
 obj-y			+= bounce.o
 endif
+obj-$(CONFIG_PDFLUSH)	+= pdflush.o
 obj-$(CONFIG_SWAP)	+= page_io.o swap_state.o swapfile.o thrash.o
 obj-$(CONFIG_HUGETLBFS)	+= hugetlb.o
 obj-$(CONFIG_NUMA) 	+= mempolicy.o
diff --git a/mm/mempool.c b/mm/mempool.c
index cc1ca86..ec02336 100644
--- a/mm/mempool.c
+++ b/mm/mempool.c
@@ -15,6 +15,8 @@
 #include <linux/blkdev.h>
 #include <linux/writeback.h>
 
+#ifdef CONFIG_MEMPOOL
+
 static void add_element(mempool_t *pool, void *element)
 {
 	BUG_ON(pool->curr_nr >= pool->min_nr);
@@ -278,6 +280,54 @@ void mempool_free(void *element, mempool_t *pool)
 }
 EXPORT_SYMBOL(mempool_free);
 
+#else /* !CONFIG_MEMPOOL */
+
+mempool_t *mempool_create(int min_nr, mempool_alloc_t *alloc_fn,
+		mempool_free_t *free_fn, void *pool_data)
+{
+	mempool_t *m;
+
+	m = (mempool_t *)kmalloc(sizeof(mempool_t), GFP_KERNEL);
+
+	if (m) {
+		m->pool_data = pool_data;
+		m->alloc = alloc_fn;
+		m->free = free_fn;
+		m->cache = alloc_fn(GFP_KERNEL, pool_data);
+	}
+
+	return m;
+}
+EXPORT_SYMBOL(mempool_create);
+
+extern void mempool_destroy(mempool_t *pool)
+{
+	if (pool->cache)
+		pool->free(pool->cache, pool->pool_data);
+	kfree(pool);
+}
+EXPORT_SYMBOL(mempool_destroy);
+
+void * mempool_alloc(mempool_t *pool, int gfp_mask)
+{
+	void *p = pool->alloc(gfp_mask, pool->pool_data);
+	if (!p)
+		p = xchg(&pool->cache, p);
+
+	return p;
+}
+EXPORT_SYMBOL(mempool_alloc);
+
+void mempool_free(void *element, mempool_t *pool)
+{
+	element = xchg(&pool->cache, element);
+	if (element)
+		pool->free(element, pool->pool_data);
+}
+EXPORT_SYMBOL(mempool_free);
+
+#endif
+
 /*
  * A commonly used alloc and free fn.
  */
diff --git a/mm/page-writeback.c b/mm/page-writeback.c
index f469e3c..c474a58 100644
--- a/mm/page-writeback.c
+++ b/mm/page-writeback.c
@@ -100,7 +100,9 @@ EXPORT_SYMBOL(laptop_mode);
 /* End of sysctl-exported parameters */
 
 
+#ifdef CONFIG_PDFLUSH
 static void background_writeout(unsigned long _min_pages);
+#endif
 
 /*
  * Work out the current dirty-memory clamping and background writeout
@@ -239,9 +241,11 @@ static void balance_dirty_pages(struct address_space *mapping)
 	 * In normal mode, we start background writeout at the lower
 	 * background_thresh, to keep the amount of dirty memory low.
 	 */
+#ifdef CONFIG_PDFLUSH
 	if ((laptop_mode && pages_written) ||
 	     (!laptop_mode && (nr_reclaimable > background_thresh)))
 		pdflush_operation(background_writeout, 0);
+#endif
 }
 
 void set_page_dirty_balance(struct page *page)
@@ -331,6 +335,7 @@ void throttle_vm_writeout(gfp_t gfp_mask)
  * writeback at least _min_pages, and keep writing until the amount of dirty
  * memory is less than the background threshold, or until we're all clean.
  */
+#ifdef CONFIG_PDFLUSH
 static void background_writeout(unsigned long _min_pages)
 {
 	long min_pages = _min_pages;
@@ -365,6 +370,7 @@ static void background_writeout(unsigned long _min_pages)
 		}
 	}
 }
+#endif
 
 /*
  * Start writeback of `nr_pages' pages.  If `nr_pages' is zero, write back
@@ -376,7 +382,11 @@ int wakeup_pdflush(long nr_pages)
 	if (nr_pages == 0)
 		nr_pages = global_page_state(NR_FILE_DIRTY) +
 				global_page_state(NR_UNSTABLE_NFS);
+#ifdef CONFIG_PDFLUSH
 	return pdflush_operation(background_writeout, nr_pages);
+#else
+	return 0;
+#endif
 }
 
 static void wb_timer_fn(unsigned long unused);
@@ -400,6 +410,7 @@ static DEFINE_TIMER(laptop_mode_wb_timer, laptop_timer_fn, 0, 0);
  * older_than_this takes precedence over nr_to_write.  So we'll only write back
  * all dirty pages if they are all attached to "old" mappings.
  */
+#ifdef CONFIG_PDFLUSH
 static void wb_kupdate(unsigned long arg)
 {
 	unsigned long oldest_jif;
@@ -441,6 +452,7 @@ static void wb_kupdate(unsigned long arg)
 	if (dirty_writeback_interval)
 		mod_timer(&wb_timer, next_jif);
 }
+#endif
 
 /*
  * sysctl handler for /proc/sys/vm/dirty_writeback_centisecs
@@ -460,18 +472,24 @@ int dirty_writeback_centisecs_handler(ctl_table *table, int write,
 
 static void wb_timer_fn(unsigned long unused)
 {
+#ifdef CONFIG_PDFLUSH
 	if (pdflush_operation(wb_kupdate, 0) < 0)
 		mod_timer(&wb_timer, jiffies + HZ); /* delay 1 second */
+#endif
 }
 
+#ifdef CONFIG_PDFLUSH
 static void laptop_flush(unsigned long unused)
 {
 	sys_sync();
 }
+#endif
 
 static void laptop_timer_fn(unsigned long unused)
 {
+#ifdef CONFIG_PDFLUSH
 	pdflush_operation(laptop_flush, 0);
+#endif
 }
 
 /*
diff --git a/mm/page_alloc.c b/mm/page_alloc.c
index 353ce90..c297512 100644
--- a/mm/page_alloc.c
+++ b/mm/page_alloc.c
@@ -671,6 +671,7 @@ EXPORT_SYMBOL(nr_node_ids);
 /*
  * Figure out the number of possible node ids.
  */
+#ifdef CONFIG_ARCH_POPULATES_NODE_MAP
 static void __init setup_nr_node_ids(void)
 {
 	unsigned int node;
@@ -683,6 +684,7 @@ static void __init setup_nr_node_ids(void)
 #else
 static void __init setup_nr_node_ids(void) {}
 #endif
+#endif
 
 #ifdef CONFIG_NUMA
 /*
diff --git a/net/8021q/vlan_dev.c b/net/8021q/vlan_dev.c
index b6e0eea..38f599c 100644
--- a/net/8021q/vlan_dev.c
+++ b/net/8021q/vlan_dev.c
@@ -440,7 +440,9 @@ int vlan_dev_hard_header(struct sk_buff *skb, struct net_device *dev,
 int vlan_dev_hard_start_xmit(struct sk_buff *skb, struct net_device *dev)
 {
 	struct net_device_stats *stats = vlan_dev_get_stats(dev);
+#if !defined (CONFIG_ESW_DOUBLE_VLAN_TAG) || defined (VLAN_DEBUG)
 	struct vlan_ethhdr *veth = (struct vlan_ethhdr *)(skb->data);
+#endif
 
 	/* Handle non-VLAN frames if they are sent to us, for example by DHCP.
 	 *
@@ -448,7 +450,9 @@ int vlan_dev_hard_start_xmit(struct sk_buff *skb, struct net_device *dev)
 	 * OTHER THINGS LIKE FDDI/TokenRing/802.3 SNAPs...
 	 */
 
+#ifndef CONFIG_ESW_DOUBLE_VLAN_TAG
 	if (veth->h_vlan_proto != __constant_htons(ETH_P_8021Q)) {
+#endif
 		int orig_headroom = skb_headroom(skb);
 		unsigned short veth_TCI;
 
@@ -477,7 +481,9 @@ int vlan_dev_hard_start_xmit(struct sk_buff *skb, struct net_device *dev)
 		if (orig_headroom < VLAN_HLEN) {
 			VLAN_DEV_INFO(dev)->cnt_inc_headroom_on_tx++;
 		}
+#ifndef CONFIG_ESW_DOUBLE_VLAN_TAG
 	}
+#endif
 
 #ifdef VLAN_DEBUG
 	printk(VLAN_DBG "%s: about to send skb: %p to dev: %s\n",
@@ -818,7 +824,11 @@ int vlan_dev_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
 		break;
 
 	case SIOCETHTOOL:
+#ifdef CONFIG_ETHTOOL
 		err = dev_ethtool(&ifrr);
+#else
+#endif
+		break;
 	}
 
 	if (!err)
diff --git a/net/Makefile b/net/Makefile
index 4854ac5..28e20ff 100644
--- a/net/Makefile
+++ b/net/Makefile
@@ -52,3 +52,24 @@ obj-$(CONFIG_IUCV)		+= iucv/
 ifeq ($(CONFIG_NET),y)
 obj-$(CONFIG_SYSCTL)		+= sysctl_net.o
 endif
+
+ifneq ($(CONFIG_RA_NAT_NONE),y)
+obj-y                           += nat/foe_hook/
+endif
+
+obj-$(CONFIG_RA_HW_NAT)         += nat/hw_nat/
+
+#obj-$(CONFIG_RA_CLASSIFIER)     += ra_classifier/cls/
+ifneq ($(CONFIG_RA_CLASSIFIER),)
+#obj-y 							+= ra_classifier/cls_hook/
+obj-y 							+= ra_classifier/hook.obj 
+endif
+
+ifeq ($(CONFIG_RA_CLASSIFIER), y)
+obj-y += ra_classifier/
+endif
+ifeq ($(CONFIG_RA_CLASSIFIER), m)
+obj-m += ra_classifier/
+endif
+
+
diff --git a/net/bridge/Kconfig b/net/bridge/Kconfig
index 12265af..949ed13 100644
--- a/net/bridge/Kconfig
+++ b/net/bridge/Kconfig
@@ -30,3 +30,10 @@ config BRIDGE
 	  will be called bridge.
 
 	  If unsure, say N.
+
+config BRIDGE_2WAYS_FDB
+	bool "2-Ways Forwarding DataBase"
+	depends on BRIDGE
+	---help---
+	  prevent ARP flooding attack (memory protection code)
+
diff --git a/net/bridge/br_fdb.c b/net/bridge/br_fdb.c
index 8d566c1..dabc6e0 100644
--- a/net/bridge/br_fdb.c
+++ b/net/bridge/br_fdb.c
@@ -282,6 +282,20 @@ static struct net_bridge_fdb_entry *fdb_create(struct hlist_head *head,
 {
 	struct net_bridge_fdb_entry *fdb;
 
+#if defined(CONFIG_BRIDGE_2WAYS_FDB)
+#define MAX_FDB_ENTRY	2
+
+	struct hlist_node *h;
+	int mac_count=0;
+
+	//prevent ARP flooding attack (memory protection code)
+	hlist_for_each_entry_rcu(fdb, h, head, hlist) {
+	    if(++mac_count > MAX_FDB_ENTRY) {
+		return NULL;
+	    }
+	}
+#endif
+
 	fdb = kmem_cache_alloc(br_fdb_cache, GFP_ATOMIC);
 	if (fdb) {
 		memcpy(fdb->addr.addr, addr, ETH_ALEN);
diff --git a/net/bridge/br_if.c b/net/bridge/br_if.c
index f3a2e29..ff6166c 100644
--- a/net/bridge/br_if.c
+++ b/net/bridge/br_if.c
@@ -38,14 +38,18 @@ static int port_cost(struct net_device *dev)
 	struct ethtool_cmd ecmd = { ETHTOOL_GSET };
 	struct ifreq ifr;
 	mm_segment_t old_fs;
-	int err;
+	int err = 0;
 
 	strncpy(ifr.ifr_name, dev->name, IFNAMSIZ);
 	ifr.ifr_data = (void __user *) &ecmd;
 
 	old_fs = get_fs();
 	set_fs(KERNEL_DS);
+#ifdef CONFIG_ETHTOOL
 	err = dev_ethtool(&ifr);
+#else
+	ecmd.speed = SPEED_100; //winfred: default 100Mbps
+#endif
 	set_fs(old_fs);
 
 	if (!err) {
diff --git a/net/core/Makefile b/net/core/Makefile
index 73272d5..453e809 100644
--- a/net/core/Makefile
+++ b/net/core/Makefile
@@ -7,13 +7,16 @@ obj-y := sock.o request_sock.o skbuff.o iovec.o datagram.o stream.o scm.o \
 
 obj-$(CONFIG_SYSCTL) += sysctl_net_core.o
 
-obj-y		     += dev.o ethtool.o dev_mcast.o dst.o netevent.o \
-			neighbour.o rtnetlink.o utils.o link_watch.o filter.o
+obj-y		     += dev.o dst.o netevent.o \
+			neighbour.o rtnetlink.o utils.o link_watch.o
 
 obj-$(CONFIG_XFRM) += flow.o
+obj-$(CONFIG_ETHTOOL) += ethtool.o
 obj-$(CONFIG_SYSFS) += net-sysfs.o
 obj-$(CONFIG_NET_PKTGEN) += pktgen.o
 obj-$(CONFIG_WIRELESS_EXT) += wireless.o
 obj-$(CONFIG_NETPOLL) += netpoll.o
 obj-$(CONFIG_NET_DMA) += user_dma.o
 obj-$(CONFIG_FIB_RULES) += fib_rules.o
+obj-$(CONFIG_NET_DEV_MULTICAST) += dev_mcast.o
+obj-$(CONFIG_NET_SK_FILTER) += filter.o
diff --git a/net/core/dev.c b/net/core/dev.c
index 4dc93cc..b6e7d67 100644
--- a/net/core/dev.c
+++ b/net/core/dev.c
@@ -94,6 +94,9 @@
 #include <linux/skbuff.h>
 #include <net/sock.h>
 #include <linux/rtnetlink.h>
+#if defined(CONFIG_IMQ) || defined(CONFIG_IMQ_MODULE)
+#include <linux/imq.h>
+#endif
 #include <linux/proc_fs.h>
 #include <linux/seq_file.h>
 #include <linux/stat.h>
@@ -1340,7 +1343,11 @@ static int dev_gso_segment(struct sk_buff *skb)
 int dev_hard_start_xmit(struct sk_buff *skb, struct net_device *dev)
 {
 	if (likely(!skb->next)) {
-		if (netdev_nit)
+		if (netdev_nit
+#if defined(CONFIG_IMQ) || defined(CONFIG_IMQ_MODULE)
+		    && !(skb->imq_flags & IMQ_F_ENQUEUE)
+#endif
+		    )
 			dev_queue_xmit_nit(skb, dev);
 
 		if (netif_needs_gso(dev, skb)) {
@@ -2699,6 +2706,7 @@ int dev_ioctl(unsigned int cmd, void __user *arg)
 			return ret;
 
 		case SIOCETHTOOL:
+#ifdef CONFIG_ETHTOOL
 			dev_load(ifr.ifr_name);
 			rtnl_lock();
 			ret = dev_ethtool(&ifr);
@@ -2711,6 +2719,9 @@ int dev_ioctl(unsigned int cmd, void __user *arg)
 					ret = -EFAULT;
 			}
 			return ret;
+#else
+			return -EINVAL;
+#endif
 
 		/*
 		 *	These ioctl calls:
diff --git a/net/core/flow.c b/net/core/flow.c
index 5d25697..1e1e437 100644
--- a/net/core/flow.c
+++ b/net/core/flow.c
@@ -351,7 +351,11 @@ static int __init flow_cache_init(void)
 					sizeof(struct flow_cache_entry),
 					0, SLAB_HWCACHE_ALIGN|SLAB_PANIC,
 					NULL, NULL);
+#ifdef CONFIG_NET_SMALL
+	flow_hash_shift = 3;
+#else
 	flow_hash_shift = 10;
+#endif
 	flow_lwm = 2 * flow_hash_size;
 	flow_hwm = 4 * flow_hash_size;
 
diff --git a/net/core/skbuff.c b/net/core/skbuff.c
index 336958f..ad0adfe 100644
--- a/net/core/skbuff.c
+++ b/net/core/skbuff.c
@@ -430,6 +430,10 @@ struct sk_buff *skb_clone(struct sk_buff *skb, gfp_t gfp_mask)
 	C(nfct_reasm);
 	nf_conntrack_get_reasm(skb->nfct_reasm);
 #endif
+#if defined(CONFIG_IMQ) || defined(CONFIG_IMQ_MODULE)
+	C(imq_flags);
+	C(nf_info);
+#endif /*CONFIG_IMQ*/
 #ifdef CONFIG_BRIDGE_NETFILTER
 	C(nf_bridge);
 	nf_bridge_get(skb->nf_bridge);
@@ -494,6 +498,10 @@ static void copy_skb_header(struct sk_buff *new, const struct sk_buff *old)
 #if defined(CONFIG_IP_VS) || defined(CONFIG_IP_VS_MODULE)
 	new->ipvs_property = old->ipvs_property;
 #endif
+#if defined(CONFIG_IMQ) || defined(CONFIG_IMQ_MODULE)
+	new->imq_flags	= old->imq_flags;
+	new->nf_info	= old->nf_info;
+#endif /*CONFIG_IMQ*/
 #ifdef CONFIG_BRIDGE_NETFILTER
 	new->nf_bridge	= old->nf_bridge;
 	nf_bridge_get(old->nf_bridge);
diff --git a/net/core/sock.c b/net/core/sock.c
index 27c4f62..53f6d63 100644
--- a/net/core/sock.c
+++ b/net/core/sock.c
@@ -342,7 +342,9 @@ int sock_setsockopt(struct socket *sock, int level, int optname,
 		    char __user *optval, int optlen)
 {
 	struct sock *sk=sock->sk;
+#ifdef CONFIG_NET_SK_FILTER
 	struct sk_filter *filter;
+#endif
 	int val;
 	int valbool;
 	struct linger ling;
@@ -591,7 +593,7 @@ set_rcvbuf:
 		}
 #endif
 
-
+#ifdef CONFIG_NET_SK_FILTER
 		case SO_ATTACH_FILTER:
 			ret = -EINVAL;
 			if (optlen == sizeof(struct sock_fprog)) {
@@ -624,6 +626,7 @@ set_rcvbuf:
 			else
 				clear_bit(SOCK_PASSSEC, &sock->flags);
 			break;
+#endif
 
 		/* We implement the SO_SNDLOWAT etc to
 		   not be settable (1003.1g 5.3) */
diff --git a/net/ipv4/Kconfig b/net/ipv4/Kconfig
index 9e8ef50..5ec6a9d 100644
--- a/net/ipv4/Kconfig
+++ b/net/ipv4/Kconfig
@@ -436,6 +436,12 @@ config INET_XFRM_MODE_BEET
 
 	  If unsure, say Y.
 
+config IPSEC_NAT_TRAVERSAL
+       bool "IPSEC NAT-Traversal (KLIPS compatible)"
+       depends on INET
+       ---help---
+       Includes support for RFC3947/RFC3948 NAT-Traversal of ESP over UDP.
+
 config INET_DIAG
 	tristate "INET: socket monitoring interface"
 	default y
diff --git a/net/ipv4/Makefile b/net/ipv4/Makefile
index 7a06862..f603185 100644
--- a/net/ipv4/Makefile
+++ b/net/ipv4/Makefile
@@ -2,18 +2,20 @@
 # Makefile for the Linux TCP/IP (INET) layer.
 #
 
-obj-y     := route.o inetpeer.o protocol.o \
+obj-y     := route.o protocol.o \
 	     ip_input.o ip_fragment.o ip_forward.o ip_options.o \
 	     ip_output.o ip_sockglue.o inet_hashtables.o \
 	     inet_timewait_sock.o inet_connection_sock.o \
 	     tcp.o tcp_input.o tcp_output.o tcp_timer.o tcp_ipv4.o \
 	     tcp_minisocks.o tcp_cong.o \
 	     datagram.o raw.o udp.o udplite.o \
-	     arp.o icmp.o devinet.o af_inet.o  igmp.o \
+	     arp.o icmp.o devinet.o af_inet.o \
 	     sysctl_net_ipv4.o fib_frontend.o fib_semantics.o
 
 obj-$(CONFIG_IP_FIB_HASH) += fib_hash.o
 obj-$(CONFIG_IP_FIB_TRIE) += fib_trie.o
+obj-$(CONFIG_IGMP) += igmp.o
+obj-$(CONFIG_INETPEER) += inetpeer.o
 obj-$(CONFIG_PROC_FS) += proc.o
 obj-$(CONFIG_IP_MULTIPLE_TABLES) += fib_rules.o
 obj-$(CONFIG_IP_MROUTE) += ipmr.o
diff --git a/net/ipv4/ip_forward.c b/net/ipv4/ip_forward.c
index 369e721..dde499a 100644
--- a/net/ipv4/ip_forward.c
+++ b/net/ipv4/ip_forward.c
@@ -100,7 +100,16 @@ int ip_forward(struct sk_buff *skb)
 	if (rt->rt_flags&RTCF_DOREDIRECT && !opt->srr)
 		ip_rt_send_redirect(skb);
 
-	skb->priority = rt_tos2priority(iph->tos);
+	/*
+	 * 1.In general case, we use DSCP to stand for different priority not tos.
+	 * 2.To make sure vlan priority is the same in rx/tx packet
+	 * FIXME - Steven
+	 */
+#if !defined (CONFIG_RA_NAT_HW)
+	if(iph->tos != 0) {
+	    skb->priority = rt_tos2priority(iph->tos);
+	}
+#endif
 
 	return NF_HOOK(PF_INET, NF_IP_FORWARD, skb, skb->dev, rt->u.dst.dev,
 		       ip_forward_finish);
diff --git a/net/ipv4/ip_input.c b/net/ipv4/ip_input.c
index f38e976..50c36d7 100644
--- a/net/ipv4/ip_input.c
+++ b/net/ipv4/ip_input.c
@@ -146,7 +146,13 @@
 #include <linux/mroute.h>
 #include <linux/netlink.h>
 
-/*
+#if defined(CONFIG_RA_SW_NAT) || defined(CONFIG_RA_SW_NAT_MODULE)
+#include "../nat/sw_nat/ra_nat.h"
+#elif  defined(CONFIG_RA_HW_NAT) || defined(CONFIG_RA_HW_NAT_MODULE)
+#include "../nat/hw_nat/ra_nat.h"
+#endif
+
+ /*
  *	SNMP management statistics
  */
 
@@ -272,6 +278,20 @@ int ip_local_deliver(struct sk_buff *skb)
 			return 0;
 	}
 
+#if defined(CONFIG_RA_SW_NAT) || defined(CONFIG_RA_SW_NAT_MODULE)
+	if( (skb_headroom(skb) >=4)  && (FOE_MAGIC_TAG(skb) == FOE_MAGIC_NUM) ) {
+	    FOE_HASH_NUM(skb) |= FOE_ALG_FLAGS;
+	}
+
+#elif  defined(CONFIG_RA_HW_NAT) || defined(CONFIG_RA_HW_NAT_MODULE)
+	if( IS_SPACE_AVAILABLED(skb) &&
+		((FOE_MAGIC_TAG(skb) == FOE_MAGIC_PCI) ||
+		 (FOE_MAGIC_TAG(skb) == FOE_MAGIC_WLAN) ||
+		 (FOE_MAGIC_TAG(skb) == FOE_MAGIC_GE))){
+	    FOE_ALG(skb)=1;
+	}
+#endif
+
 	return NF_HOOK(PF_INET, NF_IP_LOCAL_IN, skb, skb->dev, NULL,
 		       ip_local_deliver_finish);
 }
diff --git a/net/ipv4/ip_output.c b/net/ipv4/ip_output.c
index d096332..ba33a38 100644
--- a/net/ipv4/ip_output.c
+++ b/net/ipv4/ip_output.c
@@ -247,8 +247,9 @@ int ip_mc_output(struct sk_buff *skb)
 		}
 
 		/* Multicasts with ttl 0 must not go beyond the host */
-
-		if (skb->nh.iph->ttl == 0) {
+  //Gemtek Modify
+	//	if (skb->nh.iph->ttl == 0) {
+	if (skb->nh.iph->ttl < 0) {
 			kfree_skb(skb);
 			return 0;
 		}
diff --git a/net/ipv4/ip_sockglue.c b/net/ipv4/ip_sockglue.c
index 23048d9..0de275d 100644
--- a/net/ipv4/ip_sockglue.c
+++ b/net/ipv4/ip_sockglue.c
@@ -637,6 +637,7 @@ static int do_ip_setsockopt(struct sock *sk, int level,
 				err = ip_mc_leave_group(sk, &mreq);
 			break;
 		}
+#ifdef CONFIG_IGMP
 		case IP_MSFILTER:
 		{
 			extern int sysctl_igmp_max_msf;
@@ -674,6 +675,7 @@ static int do_ip_setsockopt(struct sock *sk, int level,
 			kfree(msf);
 			break;
 		}
+#endif
 		case IP_BLOCK_SOURCE:
 		case IP_UNBLOCK_SOURCE:
 		case IP_ADD_SOURCE_MEMBERSHIP:
@@ -791,6 +793,7 @@ static int do_ip_setsockopt(struct sock *sk, int level,
 				greqs.gsr_interface);
 			break;
 		}
+#ifdef CONFIG_IGMP
 		case MCAST_MSFILTER:
 		{
 			extern int sysctl_igmp_max_msf;
@@ -857,6 +860,7 @@ mc_msf_out:
 			kfree(gsf);
 			break;
 		}
+#endif
 		case IP_ROUTER_ALERT:
 			err = ip_ra_control(sk, val ? 1 : 0, NULL);
 			break;
diff --git a/net/ipv4/ipmr.c b/net/ipv4/ipmr.c
index 601e3df..e309253 100644
--- a/net/ipv4/ipmr.c
+++ b/net/ipv4/ipmr.c
@@ -463,11 +463,15 @@ static int vif_add(struct vifctl *vifc, int mrtsock)
 
 static struct mfc_cache *ipmr_cache_find(__be32 origin, __be32 mcastgrp)
 {
-	int line=MFC_HASH(mcastgrp,origin);
+//Gemtek Modify
+//	int line=MFC_HASH(mcastgrp,origin);
+  int line = MFC_HASH(mcastgrp,0x00000000);
 	struct mfc_cache *c;
 
 	for (c=mfc_cache_array[line]; c; c = c->next) {
-		if (c->mfc_origin==origin && c->mfc_mcastgrp==mcastgrp)
+	  //Gemtek Modify
+		//if (c->mfc_origin==origin && c->mfc_mcastgrp==mcastgrp)
+		 if (c->mfc_mcastgrp==mcastgrp)
 			break;
 	}
 	return c;
@@ -1301,7 +1305,9 @@ static int ip_mr_forward(struct sk_buff *skb, struct mfc_cache *cache, int local
 	 *	Forward the frame
 	 */
 	for (ct = cache->mfc_un.res.maxvif-1; ct >= cache->mfc_un.res.minvif; ct--) {
-		if (skb->nh.iph->ttl > cache->mfc_un.res.ttls[ct]) {
+	//Gemtek Modify
+  //	if (skb->nh.iph->ttl > cache->mfc_un.res.ttls[ct]) {
+  if (skb->nh.iph->ttl >= cache->mfc_un.res.ttls[ct]) {
 			if (psend != -1) {
 				struct sk_buff *skb2 = skb_clone(skb, GFP_ATOMIC);
 				if (skb2)
diff --git a/net/ipv4/netfilter/Kconfig b/net/ipv4/netfilter/Kconfig
index 601808c..75f437e 100644
--- a/net/ipv4/netfilter/Kconfig
+++ b/net/ipv4/netfilter/Kconfig
@@ -254,6 +254,20 @@ config IP_NF_MATCH_TOS
 
 	  To compile it as a module, choose M here.  If unsure, say N.
 
+config IP_NF_MATCH_TIME
+        tristate  'TIME match support'
+        depends on IP_NF_IPTABLES
+        help
+          This option adds a `time' match, which allows you
+          to match based on the packet arrival time/date
+          (arrival time/date at the machine which netfilter is running on) or
+          departure time/date (for locally generated packets).
+
+          If you say Y here, try iptables -m time --help for more information.
+
+          If you want to compile it as a module, say M here and read
+          Documentation/modules.txt.  If unsure, say `N'.
+
 config IP_NF_MATCH_RECENT
 	tristate "recent match support"
 	depends on IP_NF_IPTABLES
@@ -565,6 +579,23 @@ config IP_NF_MANGLE
 
 	  To compile it as a module, choose M here.  If unsure, say N.
 
+config IP_NF_TARGET_IMQ
+	tristate "IMQ target support"
+	depends on IP_NF_MANGLE && IMQ
+	help
+	  This option adds a `IMQ' target which is used to specify if and
+	  to which IMQ device packets should get enqueued/dequeued.
+
+	  For more information visit: http://www.linuximq.net/
+
+	  To compile it as a module, choose M here.  If unsure, say N.
+
+config IP_NF_TARGET_ROUTE
+	tristate "ROUTE target support"
+	depends on IP_NF_MANGLE
+	help
+	  To compile it as a module, choose M here.  If unsure, say N.
+
 config IP_NF_TARGET_TOS
 	tristate "TOS target support"
 	depends on IP_NF_MANGLE
@@ -657,5 +688,39 @@ config IP_NF_ARP_MANGLE
 	  Allows altering the ARP packet payload: source and destination
 	  hardware and network addresses.
 
+config IP_NF_NAT_QUAKE3
+	tristate
+	depends on IP_NF_CONNTRACK!=n && IP_NF_NAT !=n
+	default IP_NF_NAT if IP_NF_QUAKE3=y
+	default m if IP_NF_QUAKE3=m
+
+config IP_NF_QUAKE3
+	tristate "Quake3 protocol support"
+	depends on IP_NF_CONNTRACK
+	help
+	  Quake III Arena  connection tracking helper. This module allows for a
+	  stricter firewall rulebase if one only allows traffic to a master
+	  server. Connections to Quake III server IP addresses and ports returned
+	  by the master server will be tracked automatically.
+
+	  If you want to compile it as a module, say M here and read
+	  <file:Documentation/modules.txt>.  If unsure, say `Y'.
+
+config IP_NF_NAT_RTSP
+	tristate
+	depends on IP_NF_CONNTRACK!=n && IP_NF_NAT!=n
+	default IP_NF_NAT if IP_NF_RTSP=y
+	default m if IP_NF_RTSP=m
+
+config IP_NF_RTSP
+	tristate  'RTSP protocol support'
+	depends on IP_NF_CONNTRACK
+	help
+	  Support the RTSP protocol.  This allows UDP transports to be setup
+	  properly, including RTP and RDT.
+
+	  If you want to compile it as a module, say 'M' here and read
+	  Documentation/modules.txt.  If unsure, say 'Y'.
+
 endmenu
 
diff --git a/net/ipv4/netfilter/Makefile b/net/ipv4/netfilter/Makefile
index 6625ec6..8b87c8d 100644
--- a/net/ipv4/netfilter/Makefile
+++ b/net/ipv4/netfilter/Makefile
@@ -41,6 +41,12 @@ obj-$(CONFIG_IP_NF_CONNTRACK_NETLINK) += ip_conntrack_netlink.o
 obj-$(CONFIG_IP_NF_CT_PROTO_SCTP) += ip_conntrack_proto_sctp.o
 
 # connection tracking helpers
+
+# rtsp protocol support
+obj-$(CONFIG_IP_NF_RTSP) += ip_conntrack_rtsp.o
+obj-$(CONFIG_IP_NF_NAT_RTSP) += ip_nat_rtsp.o
+
+obj-$(CONFIG_IP_NF_QUAKE3) += ip_conntrack_quake3.o
 obj-$(CONFIG_IP_NF_H323) += ip_conntrack_h323.o
 obj-$(CONFIG_IP_NF_PPTP) += ip_conntrack_pptp.o
 obj-$(CONFIG_IP_NF_AMANDA) += ip_conntrack_amanda.o
@@ -57,6 +63,7 @@ obj-$(CONFIG_IP_NF_NAT_AMANDA) += ip_nat_amanda.o
 obj-$(CONFIG_IP_NF_NAT_TFTP) += ip_nat_tftp.o
 obj-$(CONFIG_IP_NF_NAT_FTP) += ip_nat_ftp.o
 obj-$(CONFIG_IP_NF_NAT_IRC) += ip_nat_irc.o
+obj-$(CONFIG_IP_NF_NAT_QUAKE3) += ip_nat_quake3.o
 obj-$(CONFIG_IP_NF_NAT_SIP) += ip_nat_sip.o
 
 # NAT helpers (nf_conntrack)
@@ -86,6 +93,7 @@ obj-$(CONFIG_IP_NF_RAW) += iptable_raw.o
 obj-$(CONFIG_IP_NF_MATCH_IPRANGE) += ipt_iprange.o
 obj-$(CONFIG_IP_NF_MATCH_OWNER) += ipt_owner.o
 obj-$(CONFIG_IP_NF_MATCH_TOS) += ipt_tos.o
+obj-$(CONFIG_IP_NF_MATCH_TIME) += ipt_time.o
 obj-$(CONFIG_IP_NF_MATCH_RECENT) += ipt_recent.o
 obj-$(CONFIG_IP_NF_MATCH_ECN) += ipt_ecn.o
 obj-$(CONFIG_IP_NF_MATCH_AH) += ipt_ah.o
@@ -96,8 +104,10 @@ obj-$(CONFIG_IP_NF_MATCH_ADDRTYPE) += ipt_addrtype.o
 obj-$(CONFIG_IP_NF_TARGET_REJECT) += ipt_REJECT.o
 obj-$(CONFIG_IP_NF_TARGET_TOS) += ipt_TOS.o
 obj-$(CONFIG_IP_NF_TARGET_ECN) += ipt_ECN.o
+obj-$(CONFIG_IP_NF_TARGET_IMQ) += ipt_IMQ.o
 obj-$(CONFIG_IP_NF_TARGET_MASQUERADE) += ipt_MASQUERADE.o
 obj-$(CONFIG_IP_NF_TARGET_REDIRECT) += ipt_REDIRECT.o
+obj-$(CONFIG_IP_NF_TARGET_ROUTE) += ipt_ROUTE.o
 obj-$(CONFIG_IP_NF_TARGET_NETMAP) += ipt_NETMAP.o
 obj-$(CONFIG_IP_NF_TARGET_SAME) += ipt_SAME.o
 obj-$(CONFIG_IP_NF_NAT_SNMP_BASIC) += ip_nat_snmp_basic.o
diff --git a/net/ipv4/netfilter/ip_conntrack_core.c b/net/ipv4/netfilter/ip_conntrack_core.c
index 23b99ae..c17ccaf 100644
--- a/net/ipv4/netfilter/ip_conntrack_core.c
+++ b/net/ipv4/netfilter/ip_conntrack_core.c
@@ -74,6 +74,8 @@ static int ip_conntrack_vmalloc __read_mostly;
 
 static unsigned int ip_conntrack_next_id;
 static unsigned int ip_conntrack_expect_next_id;
+extern char wan_name[IFNAMSIZ];
+
 #ifdef CONFIG_IP_NF_CONNTRACK_EVENTS
 ATOMIC_NOTIFIER_HEAD(ip_conntrack_chain);
 ATOMIC_NOTIFIER_HEAD(ip_conntrack_expect_chain);
@@ -146,10 +148,22 @@ static unsigned int ip_conntrack_hash_rnd;
 static u_int32_t __hash_conntrack(const struct ip_conntrack_tuple *tuple,
 			    unsigned int size, unsigned int rnd)
 {
+#if defined (CONFIG_NAT_FCONE) /* Full Cone */
+        return (jhash_3words(tuple->dst.ip,
+                             (tuple->dst.protonum),
+                             (tuple->dst.u.all),
+                             ip_conntrack_hash_rnd) % ip_conntrack_htable_size);
+#elif defined (CONFIG_NAT_RCONE) /* Restricted Cone */
+        return (jhash_3words(tuple->src.ip,
+                             (tuple->dst.ip ^ tuple->dst.protonum),
+                             (tuple->dst.u.all),
+                             ip_conntrack_hash_rnd) % ip_conntrack_htable_size);
+#else /* CONFIG_NAT_LINUX */
 	return (jhash_3words((__force u32)tuple->src.ip,
 			     ((__force u32)tuple->dst.ip ^ tuple->dst.protonum),
 			     (tuple->src.u.all | (tuple->dst.u.all << 16)),
 			     rnd) % size);
+#endif
 }
 
 static u_int32_t
@@ -385,6 +399,57 @@ __ip_conntrack_find(const struct ip_conntrack_tuple *tuple,
 	return NULL;
 }
 
+/* Added by Steven Liu */
+#if defined (CONFIG_NAT_FCONE) || defined (CONFIG_NAT_RCONE)
+static inline int ip_ct_cone_tuple_equal(const struct ip_conntrack_tuple *t1,
+                                    const struct ip_conntrack_tuple *t2)
+{
+#if defined (CONFIG_NAT_FCONE)    /* Full Cone */
+        return ip_ct_tuple_dst_equal(t1, t2);
+#elif defined (CONFIG_NAT_RCONE)  /* Restricted Cone */
+        return ip_ct_tuple_dst_equal(t1, t2) && (t1->src.ip == t2->src.ip);
+#endif
+}
+
+
+static struct ip_conntrack_tuple_hash *
+__ip_cone_conntrack_find(const struct ip_conntrack_tuple *tuple,
+        const struct ip_conntrack *ignored_conntrack)
+{
+    struct ip_conntrack_tuple_hash *h;
+    unsigned int hash = hash_conntrack(tuple);
+
+    list_for_each_entry(h, &ip_conntrack_hash[hash], list) {
+	if (tuplehash_to_ctrack(h) != ignored_conntrack &&
+		ip_ct_cone_tuple_equal(tuple, &h->tuple)) {
+	    CONNTRACK_STAT_INC(found);
+	    return h;
+	}
+	CONNTRACK_STAT_INC(searched);
+    }
+
+    return NULL;
+}
+
+/* Find a connection corresponding to a tuple. */
+struct ip_conntrack_tuple_hash *
+ip_cone_conntrack_find_get(const struct ip_conntrack_tuple *tuple,
+        const struct ip_conntrack *ignored_conntrack)
+{
+    struct ip_conntrack_tuple_hash *h;
+
+    read_lock_bh(&ip_conntrack_lock);
+    h = __ip_cone_conntrack_find(tuple, ignored_conntrack);
+    if (h)
+	atomic_inc(&tuplehash_to_ctrack(h)->ct_general.use);
+    read_unlock_bh(&ip_conntrack_lock);
+
+    return h;
+}
+
+#endif
+
+
 /* Find a connection corresponding to a tuple. */
 struct ip_conntrack_tuple_hash *
 ip_conntrack_find_get(const struct ip_conntrack_tuple *tuple,
@@ -747,6 +812,7 @@ resolve_normal_ct(struct sk_buff *skb,
 	struct ip_conntrack_tuple tuple;
 	struct ip_conntrack_tuple_hash *h;
 	struct ip_conntrack *ct;
+	struct iphdr *iph=(struct iphdr *)skb->nh.raw;
 
 	IP_NF_ASSERT((skb->nh.iph->frag_off & htons(IP_OFFSET)) == 0);
 
@@ -755,7 +821,70 @@ resolve_normal_ct(struct sk_buff *skb,
 		return NULL;
 
 	/* look for tuple match */
+#if defined (CONFIG_NAT_FCONE) || defined (CONFIG_NAT_RCONE)
+
+        /*
+         * Based on NAT treatments of UDP in RFC3489:
+         *
+         * 1)Full Cone: A full cone NAT is one where all requests from the
+         * same internal IP address and port are mapped to the same external
+         * IP address and port.  Furthermore, any external host can send a
+         * packet to the internal host, by sending a packet to the mapped
+         * external address.
+         *
+         * 2)Restricted Cone: A restricted cone NAT is one where all requests
+         * from the same internal IP address and port are mapped to the same
+         * external IP address and port.  Unlike a full cone NAT, an external
+         * host (with IP address X) can send a packet to the internal host
+         * only if the internal host had previously sent a packet to IP
+         * address X.
+	 *
+         * 3)Port Restricted Cone: A port restricted cone NAT is like a
+         * restricted cone NAT, but the restriction includes port numbers.
+         * Specifically, an external host can send a packet, with source IP
+         * address X and source port P, to the internal host only if the
+         * internal host had previously sent a packet to IP address X and
+         * port P.
+         *
+         * 4)Symmetric: A symmetric NAT is one where all requests from the
+         * same internal IP address and port, to a specific destination IP
+         * address and port, are mapped to the same external IP address and
+         * port.  If the same host sends a packet with the same source
+         * address and port, but to a different destination, a different
+         * mapping is used.  Furthermore, only the external host that
+         * receives a packet can send a UDP packet back to the internal host.
+         *
+         *
+         * Original Linux NAT type is hybrid 'port restricted cone' and
+         * 'symmetric'. XBOX certificate recommands NAT type is 'fully cone'
+         * or 'restricted cone', so i patch the linux kernel to support
+         * this feature
+	 * Tradition scenario from LAN->WAN:
+         *
+         *        (LAN)     (WAN)
+         * Client------>AP---------> Server
+         * -------------> (I)
+         *              -------------->(II)
+         *              <--------------(III)
+         * <------------- (IV)
+         *
+         *
+         * (CASE I/II/IV) Compared Tuple=src_ip/port & dst_ip/port & proto
+         * (CASE III)  Compared Tuple:
+         *             Fully cone=dst_ip/port & proto
+         *             Restricted Cone=dst_ip/port & proto & src_ip
+         *
+         */
+	if( (skb->dev!=NULL) && /* CASE III */
+		(strcmp(skb->dev->name, wan_name)==0) &&
+		(iph->protocol==IPPROTO_UDP)) {
+	    h = ip_cone_conntrack_find_get(&tuple, NULL);
+	}else{ /* CASE I.II.IV */
+	    h = ip_conntrack_find_get(&tuple, NULL);
+	}
+#else //CONFIG_NAT_LINUX
 	h = ip_conntrack_find_get(&tuple, NULL);
+#endif
 	if (!h) {
 		h = init_conntrack(&tuple, proto, skb);
 		if (!h)
diff --git a/net/ipv4/netfilter/ip_conntrack_proto_tcp.c b/net/ipv4/netfilter/ip_conntrack_proto_tcp.c
index 0a72eab..c11c08b 100644
--- a/net/ipv4/netfilter/ip_conntrack_proto_tcp.c
+++ b/net/ipv4/netfilter/ip_conntrack_proto_tcp.c
@@ -690,6 +690,7 @@ static int tcp_in_window(struct ip_ct_tcp *state,
 		before(sack, receiver->td_end + 1),
 		after(ack, receiver->td_end - MAXACKWINDOW(sender)));
 
+#if defined (CONFIG_RA_NAT_NONE)
 	if (before(seq, sender->td_maxend + 1) &&
 	    after(end, sender->td_end - receiver->td_maxwin - 1) &&
 	    before(sack, receiver->td_end + 1) &&
@@ -756,6 +757,9 @@ static int tcp_in_window(struct ip_ct_tcp *state,
 			: "SEQ is under the lower bound (already ACKed data retransmitted)"
 			: "SEQ is over the upper bound (over the window of the receiver)");
 	}
+#else
+	res = 1;
+#endif
 
 	DEBUGP("tcp_in_window: res=%i sender end=%u maxend=%u maxwin=%u "
 	       "receiver end=%u maxend=%u maxwin=%u\n",
diff --git a/net/ipv4/netfilter/ip_conntrack_standalone.c b/net/ipv4/netfilter/ip_conntrack_standalone.c
index 56b2f75..477b3f6 100644
--- a/net/ipv4/netfilter/ip_conntrack_standalone.c
+++ b/net/ipv4/netfilter/ip_conntrack_standalone.c
@@ -33,6 +33,12 @@
 #include <linux/netfilter_ipv4/ip_conntrack_core.h>
 #include <linux/netfilter_ipv4/ip_conntrack_helper.h>
 
+#if defined(CONFIG_RA_SW_NAT) || defined(CONFIG_RA_SW_NAT_MODULE)
+#include "../../nat/sw_nat/ra_nat.h"
+#elif  defined(CONFIG_RA_HW_NAT) || defined(CONFIG_RA_HW_NAT_MODULE)
+#include "../../nat/hw_nat/ra_nat.h"
+#endif
+
 #if 0
 #define DEBUGP printk
 #else
@@ -418,6 +424,21 @@ static unsigned int ip_conntrack_help(unsigned int hooknum,
 	ct = ip_conntrack_get(*pskb, &ctinfo);
 	if (ct && ct->helper && ctinfo != IP_CT_RELATED + IP_CT_IS_REPLY) {
 		unsigned int ret;
+
+#if defined(CONFIG_RA_SW_NAT) || defined(CONFIG_RA_SW_NAT_MODULE)
+            if( (skb_headroom(*pskb) >=4)  && (FOE_MAGIC_TAG(*pskb) == FOE_MAGIC_NUM) ) {
+                FOE_HASH_NUM(*pskb) |= FOE_ALG_FLAGS;
+            }
+
+#elif  defined(CONFIG_RA_HW_NAT) || defined(CONFIG_RA_HW_NAT_MODULE)
+            if( IS_SPACE_AVAILABLED(*pskb)  &&
+                    ((FOE_MAGIC_TAG(*pskb) == FOE_MAGIC_PCI) ||
+                     (FOE_MAGIC_TAG(*pskb) == FOE_MAGIC_WLAN) ||
+                     (FOE_MAGIC_TAG(*pskb) == FOE_MAGIC_GE))){
+                    FOE_ALG(*pskb)=1;
+            }
+#endif
+
 		ret = ct->helper->help(pskb, ct, ctinfo);
 		if (ret != NF_ACCEPT)
 			return ret;
diff --git a/net/ipv4/netfilter/ip_tables.c b/net/ipv4/netfilter/ip_tables.c
index 50cc4b9..29ae8a2 100644
--- a/net/ipv4/netfilter/ip_tables.c
+++ b/net/ipv4/netfilter/ip_tables.c
@@ -41,6 +41,10 @@ MODULE_DESCRIPTION("IPv4 packet filter");
 /*#define DEBUG_ALLOW_ALL*/ /* Useful for remote debugging */
 /*#define DEBUG_IP_FIREWALL_USER*/
 
+#if defined (CONFIG_NAT_FCONE) || defined (CONFIG_NAT_RCONE)
+unsigned char wan_name[IFNAMSIZ];
+#endif
+
 #ifdef DEBUG_IP_FIREWALL
 #define dprintf(format, args...)  printk(format , ## args)
 #else
@@ -1277,6 +1281,15 @@ add_counter_to_entry(struct ipt_entry *e,
 		     const struct xt_counters addme[],
 		     unsigned int *i)
 {
+#if defined (CONFIG_NAT_FCONE) || defined (CONFIG_NAT_RCONE)
+        struct ipt_entry_target *f=ipt_get_target(e);
+
+        if(strcmp(f->u.kernel.target->name,"MASQUERADE")==0 && strlen(e->ip.outiface)!=0) {
+		memset(wan_name,0,sizeof(wan_name));
+                memcpy(wan_name,e->ip.outiface, strlen(e->ip.outiface));
+        }
+#endif
+
 #if 0
 	duprintf("add_counter: Entry %u %lu/%lu + %lu/%lu\n",
 		 *i,
@@ -2191,7 +2204,15 @@ static int __init ip_tables_init(void)
 	if (ret < 0)
 		goto err5;
 
-	printk("ip_tables: (C) 2000-2006 Netfilter Core Team\n");
+	printk("ip_tables: (C) 2000-2006 Netfilter Core Team, ");
+#if defined (CONFIG_NAT_FCONE)
+	printk("Type=Fully Cone\n");
+#elif defined (CONFIG_NAT_RCONE)
+	printk("Type=Restricted Cone\n");
+#else
+	printk("Type=Linux\n");
+#endif
+
 	return 0;
 
 err5:
diff --git a/net/ipv4/netfilter/nf_conntrack_l3proto_ipv4.c b/net/ipv4/netfilter/nf_conntrack_l3proto_ipv4.c
index 8f3e92d..fcb3ac8 100644
--- a/net/ipv4/netfilter/nf_conntrack_l3proto_ipv4.c
+++ b/net/ipv4/netfilter/nf_conntrack_l3proto_ipv4.c
@@ -32,12 +32,25 @@
 #include <net/netfilter/nf_conntrack_core.h>
 #include <net/netfilter/ipv4/nf_conntrack_ipv4.h>
 
+#if defined(CONFIG_RA_SW_NAT) || defined(CONFIG_RA_SW_NAT_MODULE)
+#include "../../nat/sw_nat/ra_nat.h"
+#elif  defined(CONFIG_RA_HW_NAT) || defined(CONFIG_RA_HW_NAT_MODULE)
+#include "../../nat/hw_nat/ra_nat.h"
+#endif
+
 #if 0
 #define DEBUGP printk
 #else
 #define DEBUGP(format, args...)
 #endif
 
+
+#define CONFIG_PRIVILEGE_CONNTRACK 1
+
+#ifdef CONFIG_PRIVILEGE_CONNTRACK
+extern int general_traffic_conntrack_max;
+#endif
+
 static int ipv4_pkt_to_tuple(const struct sk_buff *skb, unsigned int nhoff,
 			     struct nf_conntrack_tuple *tuple)
 {
@@ -151,6 +164,19 @@ static unsigned int ipv4_conntrack_help(unsigned int hooknum,
 	if (!help || !help->helper)
 		return NF_ACCEPT;
 
+#if defined(CONFIG_RA_SW_NAT) || defined(CONFIG_RA_SW_NAT_MODULE)
+            if( (skb_headroom(*pskb) >=4)  && (FOE_MAGIC_TAG(*pskb) == FOE_MAGIC_NUM) ) {
+                FOE_HASH_NUM(*pskb) |= FOE_ALG_FLAGS;
+            }
+#elif  defined(CONFIG_RA_HW_NAT) || defined(CONFIG_RA_HW_NAT_MODULE)
+            if( IS_SPACE_AVAILABLED(*pskb)  &&
+                    ((FOE_MAGIC_TAG(*pskb) == FOE_MAGIC_PCI) ||
+                     (FOE_MAGIC_TAG(*pskb) == FOE_MAGIC_WLAN) ||
+                     (FOE_MAGIC_TAG(*pskb) == FOE_MAGIC_GE))){
+                    FOE_ALG(*pskb)=1;
+            }
+#endif
+
 	return help->helper->help(pskb,
 			       (*pskb)->nh.raw - (*pskb)->data
 					       + (*pskb)->nh.iph->ihl*4,
@@ -281,6 +307,16 @@ static ctl_table ip_ct_sysctl_table[] = {
 		.mode		= 0644,
 		.proc_handler	= &proc_dointvec,
 	},
+	#ifdef CONFIG_PRIVILEGE_CONNTRACK
+	{
+		.ctl_name	= NET_IPV4_NF_CONNTRACK_MAX+1,
+		.procname	= "general_conntrack_max",
+		.data		= &general_traffic_conntrack_max,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= &proc_dointvec,
+	},
+#endif
 	{
 		.ctl_name	= NET_IPV4_NF_CONNTRACK_COUNT,
 		.procname	= "ip_conntrack_count",
diff --git a/net/ipv4/netfilter/nf_conntrack_l3proto_ipv4_compat.c b/net/ipv4/netfilter/nf_conntrack_l3proto_ipv4_compat.c
index 89f933e..9706a3f 100644
--- a/net/ipv4/netfilter/nf_conntrack_l3proto_ipv4_compat.c
+++ b/net/ipv4/netfilter/nf_conntrack_l3proto_ipv4_compat.c
@@ -163,6 +163,12 @@ static int ct_seq_show(struct seq_file *s, void *v)
 		return -ENOSPC;
 #endif
 
+#if defined(CONFIG_NETFILTER_XT_MATCH_LAYER7) || defined(CONFIG_NETFILTER_XT_MATCH_LAYER7_MODULE)
+	if(ct->layer7.app_proto)
+		if(seq_printf(s, "l7proto=%s ", ct->layer7.app_proto))
+			return -ENOSPC;
+#endif
+
 	if (seq_printf(s, "use=%u\n", atomic_read(&ct->ct_general.use)))
 		return -ENOSPC;
 
diff --git a/net/ipv4/netfilter/nf_nat_sip.c b/net/ipv4/netfilter/nf_nat_sip.c
index b12cd7c..3668704 100644
--- a/net/ipv4/netfilter/nf_nat_sip.c
+++ b/net/ipv4/netfilter/nf_nat_sip.c
@@ -25,11 +25,6 @@ MODULE_AUTHOR("Christian Hentschel <chentschel@arnet.com.ar>");
 MODULE_DESCRIPTION("SIP NAT helper");
 MODULE_ALIAS("ip_nat_sip");
 
-#if 0
-#define DEBUGP printk
-#else
-#define DEBUGP(format, args...)
-#endif
 
 struct addr_map {
 	struct {
@@ -109,7 +104,7 @@ static unsigned int ip_nat_sip(struct sk_buff **pskb,
 	dataoff = (*pskb)->nh.iph->ihl*4 + sizeof(struct udphdr);
 	datalen = (*pskb)->len - dataoff;
 	if (datalen < sizeof("SIP/2.0") - 1)
-		return NF_DROP;
+		return NF_ACCEPT;
 
 	addr_map_init(ct, &map);
 
@@ -221,6 +216,29 @@ static unsigned int mangle_sdp(struct sk_buff **pskb,
 	return mangle_content_len(pskb, ctinfo, ct, dptr);
 }
 
+static void ip_nat_sdp_expect(struct nf_conn *ct,
+			      struct nf_conntrack_expect *exp)
+{
+	struct nf_nat_range range;
+
+	/* This must be a fresh one. */
+	BUG_ON(ct->status & IPS_NAT_DONE_MASK);
+
+	/* Change src to where master sends to */
+	range.flags = IP_NAT_RANGE_MAP_IPS;
+	range.min_ip = range.max_ip
+		= ct->master->tuplehash[!exp->dir].tuple.dst.u3.ip;
+	/* hook doesn't matter, but it has to do source manip */
+	nf_nat_setup_info(ct, &range, NF_IP_POST_ROUTING);
+
+	/* For DST manip, map port here to where it's expected. */
+	range.flags = (IP_NAT_RANGE_MAP_IPS | IP_NAT_RANGE_PROTO_SPECIFIED);
+	range.min = range.max = exp->saved_proto;
+	range.min_ip = range.max_ip = exp->saved_ip;
+	/* hook doesn't matter, but it has to do destination manip */
+	nf_nat_setup_info(ct, &range, NF_IP_PRE_ROUTING);
+}
+
 /* So, this packet has hit the connection tracking matching code.
    Mangle it, and change the expectation to match the new version. */
 static unsigned int ip_nat_sdp(struct sk_buff **pskb,
@@ -233,18 +251,21 @@ static unsigned int ip_nat_sdp(struct sk_buff **pskb,
 	__be32 newip;
 	u_int16_t port;
 
-	DEBUGP("ip_nat_sdp():\n");
-
 	/* Connection will come from reply */
-	newip = ct->tuplehash[!dir].tuple.dst.u3.ip;
+	if (ct->tuplehash[dir].tuple.src.u3.ip ==
+	    ct->tuplehash[!dir].tuple.dst.u3.ip)
+		newip = exp->tuple.dst.u3.ip;
+	else
+		newip = ct->tuplehash[!dir].tuple.dst.u3.ip;
 
+	exp->saved_ip = exp->tuple.dst.u3.ip;
 	exp->tuple.dst.u3.ip = newip;
 	exp->saved_proto.udp.port = exp->tuple.dst.u.udp.port;
 	exp->dir = !dir;
 
 	/* When you see the packet, we need to NAT it the same as the
 	   this one. */
-	exp->expectfn = nf_nat_follow_master;
+	exp->expectfn = ip_nat_sdp_expect;
 
 	/* Try to get same port: if not, try to change it. */
 	for (port = ntohs(exp->saved_proto.udp.port); port != 0; port++) {
diff --git a/net/ipv4/netfilter/nf_nat_standalone.c b/net/ipv4/netfilter/nf_nat_standalone.c
index 15aa3db..9c0c43d 100644
--- a/net/ipv4/netfilter/nf_nat_standalone.c
+++ b/net/ipv4/netfilter/nf_nat_standalone.c
@@ -287,7 +287,14 @@ static struct nf_hook_ops nf_nat_ops[] = {
 		.owner		= THIS_MODULE,
 		.pf		= PF_INET,
 		.hooknum	= NF_IP_PRE_ROUTING,
-		.priority	= NF_IP_PRI_NAT_DST,
+#ifdef CONFIG_NETFILTER_RALINK_SWQOS_SUPPORT
+		.priority	= NF_IP_PRI_NAT_DST_RALINK_QOS,	// Ralink: 
+													// Raise priority to make nat table has higher
+													// priority than mangle table.
+													// In other words, now NAT happenes before QoS marking.
+#else
+		.priority	= NF_IP_PRI_NAT_DST, 
+#endif
 	},
 	/* After packet filtering, change source */
 	{
diff --git a/net/ipv4/sysctl_net_ipv4.c b/net/ipv4/sysctl_net_ipv4.c
index 0aa3047..75383c3 100644
--- a/net/ipv4/sysctl_net_ipv4.c
+++ b/net/ipv4/sysctl_net_ipv4.c
@@ -482,6 +482,8 @@ ctl_table ipv4_table[] = {
 	},
 
 #endif
+#ifdef CONFIG_INETPEER
+#ifdef CONFIG_IGMP
 	{
 		.ctl_name	= NET_IPV4_IGMP_MAX_MSF,
 		.procname	= "igmp_max_msf",
@@ -490,6 +492,7 @@ ctl_table ipv4_table[] = {
 		.mode		= 0644,
 		.proc_handler	= &proc_dointvec
 	},
+#endif
 	{
 		.ctl_name	= NET_IPV4_INET_PEER_THRESHOLD,
 		.procname	= "inet_peer_threshold",
@@ -534,6 +537,7 @@ ctl_table ipv4_table[] = {
 		.proc_handler	= &proc_dointvec_jiffies,
 		.strategy	= &sysctl_jiffies
 	},
+#endif
 	{
 		.ctl_name	= NET_TCP_ORPHAN_RETRIES,
 		.procname	= "tcp_orphan_retries",
diff --git a/net/ipv4/udp.c b/net/ipv4/udp.c
index fc620a7..eb6436d 100644
--- a/net/ipv4/udp.c
+++ b/net/ipv4/udp.c
@@ -101,6 +101,7 @@
 #include <net/route.h>
 #include <net/checksum.h>
 #include <net/xfrm.h>
+#include <net/xfrmudp.h>
 #include "udp_impl.h"
 
 /*
@@ -892,6 +893,44 @@ csum_copy_err:
 	goto try_again;
 }
 
+/* if XFRM isn't a module, then register it directly. */
+#if !defined(CONFIG_XFRM_MODULE)
+static xfrm4_rcv_encap_t xfrm4_rcv_encap_func = xfrm4_rcv_encap;
+#else
+static xfrm4_rcv_encap_t xfrm4_rcv_encap_func = NULL;
+#endif
+
+
+#if defined(CONFIG_XFRM) || defined(CONFIG_IPSEC_NAT_TRAVERSAL)
+
+static xfrm4_rcv_encap_t xfrm4_rcv_encap_func;
+
+int udp4_register_esp_rcvencap(xfrm4_rcv_encap_t func
+                              , xfrm4_rcv_encap_t *oldfunc)
+{
+  if(oldfunc != NULL) {
+    *oldfunc = xfrm4_rcv_encap_func;
+  }
+
+#if 0
+  if(xfrm4_rcv_encap_func != NULL)
+    return -1;
+#endif
+
+  xfrm4_rcv_encap_func = func;
+  return 0;
+}
+
+int udp4_unregister_esp_rcvencap(xfrm4_rcv_encap_t func)
+{
+  if(xfrm4_rcv_encap_func != func)
+    return -1;
+
+  xfrm4_rcv_encap_func = NULL;
+  return 0;
+}
+#endif /* CONFIG_XFRM || defined(CONFIG_IPSEC_NAT_TRAVERSAL)*/
+
 
 int udp_disconnect(struct sock *sk, int flags)
 {
@@ -922,9 +961,9 @@ int udp_disconnect(struct sock *sk, int flags)
  */
 static int udp_encap_rcv(struct sock * sk, struct sk_buff *skb)
 {
-#ifndef CONFIG_XFRM
+#if !defined(CONFIG_XFRM) && !defined(CONFIG_IPSEC_NAT_TRAVERSAL)
 	return 1;
-#else
+#else /* either CONFIG_XFRM or CONFIG_IPSEC_NAT_TRAVERSAL */
 	struct udp_sock *up = udp_sk(sk);
 	struct udphdr *uh;
 	struct iphdr *iph;
@@ -1052,9 +1091,15 @@ int udp_queue_rcv_skb(struct sock * sk, struct sk_buff *skb)
 		}
 		if (ret < 0) {
 			/* process the ESP packet */
-			ret = xfrm4_rcv_encap(skb, up->encap_type);
-			UDP_INC_STATS_BH(UDP_MIB_INDATAGRAMS, up->pcflag);
-			return -ret;
+			if(xfrm4_rcv_encap_func != NULL) {
+			    ret = (*xfrm4_rcv_encap_func)(skb, up->encap_type);
+			    UDP_INC_STATS_BH(UDP_MIB_INDATAGRAMS, up->pcflag);
+			} else {
+			    UDP_INC_STATS_BH(UDP_MIB_INERRORS, up->pcflag);
+			    ret = 1;
+			}
+			return ret;
+
 		}
 		/* FALLTHROUGH -- it's a UDP Packet */
 	}
@@ -1733,3 +1778,9 @@ EXPORT_SYMBOL(udp_poll);
 EXPORT_SYMBOL(udp_proc_register);
 EXPORT_SYMBOL(udp_proc_unregister);
 #endif
+
+#if defined(CONFIG_IPSEC_NAT_TRAVERSAL)
+EXPORT_SYMBOL(udp4_register_esp_rcvencap);
+EXPORT_SYMBOL(udp4_unregister_esp_rcvencap);
+#endif
+
diff --git a/net/ipv6/ip6_input.c b/net/ipv6/ip6_input.c
index 61e7a6c..33ba13a 100644
--- a/net/ipv6/ip6_input.c
+++ b/net/ipv6/ip6_input.c
@@ -45,6 +45,11 @@
 #include <net/addrconf.h>
 #include <net/xfrm.h>
 
+#if defined(CONFIG_RA_SW_NAT) || defined(CONFIG_RA_SW_NAT_MODULE)
+#include "../nat/sw_nat/ra_nat.h"
+#elif  defined(CONFIG_RA_HW_NAT) || defined(CONFIG_RA_HW_NAT_MODULE)
+#include "../nat/hw_nat/ra_nat.h"
+#endif
 
 
 inline int ip6_rcv_finish( struct sk_buff *skb)
@@ -224,6 +229,20 @@ discard:
 
 int ip6_input(struct sk_buff *skb)
 {
+
+#if defined(CONFIG_RA_SW_NAT) || defined(CONFIG_RA_SW_NAT_MODULE)
+        if( (skb_headroom(skb) >=4)  && (FOE_MAGIC_TAG(skb) == FOE_MAGIC_NUM) ) {
+            FOE_HASH_NUM(skb) |= FOE_ALG_FLAGS;
+                                                    }
+#elif  defined(CONFIG_RA_HW_NAT) || defined(CONFIG_RA_HW_NAT_MODULE)
+        if( IS_SPACE_AVAILABLED(skb)  &&
+                ((FOE_MAGIC_TAG(skb) == FOE_MAGIC_PCI) ||
+                 (FOE_MAGIC_TAG(skb) == FOE_MAGIC_WLAN) ||
+                 (FOE_MAGIC_TAG(skb) == FOE_MAGIC_GE))){
+            FOE_ALG(skb)=1;
+        }
+#endif
+
 	return NF_HOOK(PF_INET6,NF_IP6_LOCAL_IN, skb, skb->dev, NULL, ip6_input_finish);
 }
 
diff --git a/net/ipv6/netfilter/Kconfig b/net/ipv6/netfilter/Kconfig
index da07e9a..8e6ea11 100644
--- a/net/ipv6/netfilter/Kconfig
+++ b/net/ipv6/netfilter/Kconfig
@@ -173,6 +173,16 @@ config IP6_NF_MANGLE
 
 	  To compile it as a module, choose M here.  If unsure, say N.
 
+config IP6_NF_TARGET_IMQ
+	tristate "IMQ target support"
+	depends on IP6_NF_MANGLE && IMQ
+	help
+          This option adds a 	MQ' target which is used to specify if and
+          to which imq device packets should get enqueued/dequeued.
+
+          To compile it as a module, choose M here.  If unsure, say N.
+
+
 config IP6_NF_TARGET_HL
 	tristate  'HL (hoplimit) target support'
 	depends on IP6_NF_MANGLE
diff --git a/net/ipv6/netfilter/Makefile b/net/ipv6/netfilter/Makefile
index 4513eab..3bd94cc 100644
--- a/net/ipv6/netfilter/Makefile
+++ b/net/ipv6/netfilter/Makefile
@@ -13,6 +13,7 @@ obj-$(CONFIG_IP6_NF_MATCH_EUI64) += ip6t_eui64.o
 obj-$(CONFIG_IP6_NF_MATCH_OWNER) += ip6t_owner.o
 obj-$(CONFIG_IP6_NF_FILTER) += ip6table_filter.o
 obj-$(CONFIG_IP6_NF_MANGLE) += ip6table_mangle.o
+obj-$(CONFIG_IP6_NF_TARGET_IMQ) += ip6t_IMQ.o
 obj-$(CONFIG_IP6_NF_TARGET_HL) += ip6t_HL.o
 obj-$(CONFIG_IP6_NF_QUEUE) += ip6_queue.o
 obj-$(CONFIG_IP6_NF_TARGET_LOG) += ip6t_LOG.o
diff --git a/net/ipv6/netfilter/nf_conntrack_l3proto_ipv6.c b/net/ipv6/netfilter/nf_conntrack_l3proto_ipv6.c
index d110245..5e270e5 100644
--- a/net/ipv6/netfilter/nf_conntrack_l3proto_ipv6.c
+++ b/net/ipv6/netfilter/nf_conntrack_l3proto_ipv6.c
@@ -43,6 +43,12 @@
 #define DEBUGP(format, args...)
 #endif
 
+#if defined(CONFIG_RA_SW_NAT) || defined(CONFIG_RA_SW_NAT_MODULE)
+#include "../../nat/sw_nat/ra_nat.h"
+#elif  defined(CONFIG_RA_HW_NAT) || defined(CONFIG_RA_HW_NAT_MODULE)
+#include "../../nat/hw_nat/ra_nat.h"
+#endif
+
 static int ipv6_pkt_to_tuple(const struct sk_buff *skb, unsigned int nhoff,
 			     struct nf_conntrack_tuple *tuple)
 {
@@ -201,6 +207,19 @@ static unsigned int ipv6_confirm(unsigned int hooknum,
 		return NF_ACCEPT;
 	}
 
+#if defined(CONFIG_RA_SW_NAT) || defined(CONFIG_RA_SW_NAT_MODULE)
+	if( (skb_headroom(*pskb) >=4)  && (FOE_MAGIC_TAG(*pskb) == FOE_MAGIC_NUM) ) {
+	    FOE_HASH_NUM(*pskb) |= FOE_ALG_FLAGS;
+					            }
+#elif  defined(CONFIG_RA_HW_NAT) || defined(CONFIG_RA_HW_NAT_MODULE)
+	if( IS_SPACE_AVAILABLED(*pskb)  &&
+		((FOE_MAGIC_TAG(*pskb) == FOE_MAGIC_PCI) ||
+		 (FOE_MAGIC_TAG(*pskb) == FOE_MAGIC_WLAN) ||
+		 (FOE_MAGIC_TAG(*pskb) == FOE_MAGIC_GE))){
+	    FOE_ALG(*pskb)=1;
+	}
+#endif
+
 	ret = help->helper->help(pskb, protoff, ct, ctinfo);
 	if (ret != NF_ACCEPT)
 		return ret;
diff --git a/net/netfilter/Kconfig b/net/netfilter/Kconfig
index 54698af..3708ecd 100644
--- a/net/netfilter/Kconfig
+++ b/net/netfilter/Kconfig
@@ -1,6 +1,27 @@
 menu "Core Netfilter Configuration"
 	depends on NET && INET && NETFILTER
 
+choice
+        prompt "NAT Types"
+        default NAT_LINUX
+
+        config  NAT_FCONE
+        bool "Full_Cone (EXPERIMENTAL)"
+
+        config  NAT_RCONE
+        bool "Restricted_Cone (EXPERIMENTAL)"
+
+        config  NAT_LINUX
+        bool "Linux"
+
+endchoice
+
+config NETFILTER_RALINK_SWQOS_SUPPORT
+       bool "Netfilter Ralink SWQoS support"
+       help
+         To support Ralink SW QoS, please enable it.
+         If unsure, say N.
+
 config NETFILTER_NETLINK
        tristate "Netfilter netlink interface"
        help
@@ -217,7 +238,7 @@ config NF_CONNTRACK_NETBIOS_NS
 	  To compile it as a module, choose M here.  If unsure, say N.
 
 config NF_CONNTRACK_PPTP
-	tristate "PPtP protocol support"
+	tristate "PPTP protocol support"
 	depends on NF_CONNTRACK
 	select NF_CT_PROTO_GRE
 	help
@@ -640,6 +661,27 @@ config NETFILTER_XT_MATCH_STATE
 
 	  To compile it as a module, choose M here.  If unsure, say N.
 
+config NETFILTER_XT_MATCH_LAYER7
+	tristate '"layer7" match support'
+	depends on NETFILTER_XTABLES
+	depends on IP_NF_CONNTRACK || NF_CONNTRACK
+	depends on NF_CT_ACCT
+	help
+	  Say Y if you want to be able to classify connections (and their
+	  packets) based on regular expression matching of their application
+	  layer data.   This is one way to classify applications such as
+	  peer-to-peer filesharing systems that do not always use the same
+	  port.
+
+	  To compile it as a module, choose M here.  If unsure, say N.
+
+config NETFILTER_XT_MATCH_LAYER7_DEBUG
+	bool 'layer7 debugging output'
+	depends on NETFILTER_XT_MATCH_LAYER7
+	help
+	  Say Y to get lots of debugging output.
+
+
 config NETFILTER_XT_MATCH_STATISTIC
 	tristate '"statistic" match support'
 	depends on NETFILTER_XTABLES
@@ -662,6 +704,15 @@ config NETFILTER_XT_MATCH_STRING
 
 	  To compile it as a module, choose M here.  If unsure, say N.
 
+config NETFILTER_XT_MATCH_WEBSTR
+	tristate  '"webstr" match support'
+	depends on NETFILTER_XTABLES
+	help
+	  This option adds a `webstr' match, which allows you to look for
+	  pattern matchings in http stream.
+
+	  To compile it as a module, choose M here.  If unsure, say N.
+
 config NETFILTER_XT_MATCH_TCPMSS
 	tristate '"tcpmss" match support'
 	depends on NETFILTER_XTABLES
@@ -686,5 +737,10 @@ config NETFILTER_XT_MATCH_HASHLIMIT
 	  destination address' or `500pps from any given source address'
 	  with a single rule.
 
-endmenu
+config NETFILTER_XT_MATCH_ETHPORT
+	tristate '"Ethernet port for incoming packets" match support'
+	depends on NETFILTER_XTABLES && (IP6_NF_IPTABLES || IP6_NF_IPTABLES=n)
+	help
+	  This option adds a `ethport' match.
 
+endmenu
diff --git a/net/netfilter/Makefile b/net/netfilter/Makefile
index b2b5c75..c1b49f8 100644
--- a/net/netfilter/Makefile
+++ b/net/netfilter/Makefile
@@ -5,6 +5,7 @@ nf_conntrack-$(CONFIG_NF_CONNTRACK_EVENTS) += nf_conntrack_ecache.o
 
 obj-$(CONFIG_NETFILTER) = netfilter.o
 obj-$(CONFIG_SYSCTL) += nf_sysctl.o
+#obj-$(CONFIG_RA_NAT_HW) += nf_conntrack_hnat.o
 
 obj-$(CONFIG_NETFILTER_NETLINK) += nfnetlink.o
 obj-$(CONFIG_NETFILTER_NETLINK_QUEUE) += nfnetlink_queue.o
@@ -68,8 +69,11 @@ obj-$(CONFIG_NETFILTER_XT_MATCH_QUOTA) += xt_quota.o
 obj-$(CONFIG_NETFILTER_XT_MATCH_REALM) += xt_realm.o
 obj-$(CONFIG_NETFILTER_XT_MATCH_SCTP) += xt_sctp.o
 obj-$(CONFIG_NETFILTER_XT_MATCH_STATE) += xt_state.o
+obj-$(CONFIG_NETFILTER_XT_MATCH_LAYER7) += xt_layer7.o
 obj-$(CONFIG_NETFILTER_XT_MATCH_STATISTIC) += xt_statistic.o
 obj-$(CONFIG_NETFILTER_XT_MATCH_STRING) += xt_string.o
+obj-$(CONFIG_NETFILTER_XT_MATCH_WEBSTR) += xt_webstr.o
 obj-$(CONFIG_NETFILTER_XT_MATCH_TCPMSS) += xt_tcpmss.o
 obj-$(CONFIG_NETFILTER_XT_MATCH_PHYSDEV) += xt_physdev.o
 obj-$(CONFIG_NETFILTER_XT_MATCH_HASHLIMIT) += xt_hashlimit.o
+obj-$(CONFIG_NETFILTER_XT_MATCH_ETHPORT) += xt_ethport.o
diff --git a/net/netfilter/nf_conntrack_core.c b/net/netfilter/nf_conntrack_core.c
index b3a70eb..898ee6a 100644
--- a/net/netfilter/nf_conntrack_core.c
+++ b/net/netfilter/nf_conntrack_core.c
@@ -47,6 +47,8 @@
 #include <linux/netdevice.h>
 #include <linux/socket.h>
 #include <linux/mm.h>
+#include <linux/ip.h>
+#include <linux/in.h>
 
 #include <net/netfilter/nf_conntrack.h>
 #include <net/netfilter/nf_conntrack_l3proto.h>
@@ -55,8 +57,14 @@
 #include <net/netfilter/nf_conntrack_helper.h>
 #include <net/netfilter/nf_conntrack_core.h>
 
+#if defined(CONFIG_RA_SW_NAT) || defined(CONFIG_RA_SW_NAT_MODULE)
+#include "../nat/sw_nat/ra_nat.h"
+#elif  defined(CONFIG_RA_HW_NAT) || defined(CONFIG_RA_HW_NAT_MODULE)
+#include "../nat/hw_nat/ra_nat.h"
+#endif
+
 #define NF_CONNTRACK_VERSION	"0.5.0"
 
 #if 0
 #define DEBUGP printk
 #else
@@ -87,6 +104,10 @@ EXPORT_SYMBOL_GPL(nf_conntrack_untracked);
 
 unsigned int nf_ct_log_invalid __read_mostly;
 LIST_HEAD(unconfirmed);
+#if defined (CONFIG_NAT_FCONE) || defined (CONFIG_NAT_RCONE)
+extern char wan_name[IFNAMSIZ];
+#endif
+
 static int nf_conntrack_vmalloc __read_mostly;
 
 static unsigned int nf_conntrack_next_id;
@@ -128,10 +149,23 @@ static u_int32_t __hash_conntrack(const struct nf_conntrack_tuple *tuple,
 				  unsigned int size, unsigned int rnd)
 {
 	unsigned int a, b;
+
+#if defined (CONFIG_NAT_FCONE) /* Full Cone */
+	a = jhash((void *)tuple->dst.u3.all, sizeof(tuple->dst.u3.all),
+		   tuple->dst.u.all); // dst ip, dst port
+	b = jhash((void *)tuple->dst.u3.all, sizeof(tuple->dst.u3.all),
+		   tuple->dst.protonum); //dst ip, & dst ip protocol
+#elif defined (CONFIG_NAT_RCONE) /* Restricted Cone */
+	a = jhash((void *)tuple->src.u3.all, sizeof(tuple->src.u3.all), //src ip
+		   (tuple->src.l3num << 16) | tuple->dst.protonum);
+	b = jhash((void *)tuple->dst.u3.all, sizeof(tuple->dst.u3.all), //dst ip & dst port
+		  (tuple->dst.u.all << 16) | tuple->dst.protonum);
+#else /* CONFIG_NAT_LINUX */
 	a = jhash((void *)tuple->src.u3.all, sizeof(tuple->src.u3.all),
 		  ((tuple->src.l3num) << 16) | tuple->dst.protonum);
 	b = jhash((void *)tuple->dst.u3.all, sizeof(tuple->dst.u3.all),
 			(tuple->src.u.all << 16) | tuple->dst.u.all);
+#endif
 
 	return jhash_2words(a, b, rnd) % size;
 }
@@ -356,6 +390,14 @@ destroy_conntrack(struct nf_conntrack *nfct)
 	 * too. */
 	nf_ct_remove_expectations(ct);
 
+	#if defined(CONFIG_NETFILTER_XT_MATCH_LAYER7) || defined(CONFIG_NETFILTER_XT_MATCH_LAYER7_MODULE)
+	if(ct->layer7.app_proto)
+		kfree(ct->layer7.app_proto);
+	if(ct->layer7.app_data)
+	kfree(ct->layer7.app_data);
+	#endif
+
+
 	/* We overload first tuple to link into unconfirmed list. */
 	if (!nf_ct_is_confirmed(ct)) {
 		BUG_ON(list_empty(&ct->tuplehash[IP_CT_DIR_ORIGINAL].list));
@@ -405,6 +447,63 @@ __nf_conntrack_find(const struct nf_conntrack_tuple *tuple,
 }
 EXPORT_SYMBOL_GPL(__nf_conntrack_find);
 
+/* Added by Steven Liu */
+#if defined (CONFIG_NAT_FCONE) || defined (CONFIG_NAT_RCONE)
+static inline int nf_ct_cone_tuple_equal(const struct nf_conntrack_tuple *t1,
+                                    const struct nf_conntrack_tuple *t2)
+{
+#if defined (CONFIG_NAT_FCONE)    /* Full Cone */
+        return nf_ct_tuple_dst_equal(t1, t2);
+#elif defined (CONFIG_NAT_RCONE)  /* Restricted Cone */
+        return (nf_ct_tuple_dst_equal(t1, t2) &&
+	        t1->src.u3.all[0] == t2->src.u3.all[0] &&
+                t1->src.u3.all[1] == t2->src.u3.all[1] &&
+		t1->src.u3.all[2] == t2->src.u3.all[2] &&
+                t1->src.u3.all[3] == t2->src.u3.all[3] &&
+		t1->src.l3num == t2->src.l3num &&
+		t1->dst.protonum == t2->dst.protonum);
+#endif
+}
+
+
+static struct nf_conntrack_tuple_hash *
+__nf_cone_conntrack_find(const struct nf_conntrack_tuple *tuple,
+        const struct nf_conn *ignored_conntrack)
+{
+    struct nf_conntrack_tuple_hash *h;
+    unsigned int hash = hash_conntrack(tuple);
+
+    list_for_each_entry(h, &nf_conntrack_hash[hash], list) {
+        if (nf_ct_tuplehash_to_ctrack(h) != ignored_conntrack &&
+                nf_ct_cone_tuple_equal(tuple, &h->tuple)) {
+            NF_CT_STAT_INC(found);
+            return h;
+        }
+        NF_CT_STAT_INC(searched);
+    }
+    return NULL;
+}
+
+
+/* Find a connection corresponding to a tuple. */
+struct nf_conntrack_tuple_hash *
+nf_cone_conntrack_find_get(const struct nf_conntrack_tuple *tuple,
+        const struct nf_conn *ignored_conntrack)
+{
+    struct nf_conntrack_tuple_hash *h;
+
+    read_lock_bh(&nf_conntrack_lock);
+    h = __nf_cone_conntrack_find(tuple, ignored_conntrack);
+    if (h)
+        atomic_inc(&nf_ct_tuplehash_to_ctrack(h)->ct_general.use);
+    read_unlock_bh(&nf_conntrack_lock);
+
+    return h;
+}
+EXPORT_SYMBOL_GPL(nf_cone_conntrack_find_get);
+
+#endif
+
 /* Find a connection corresponding to a tuple. */
 struct nf_conntrack_tuple_hash *
 nf_conntrack_find_get(const struct nf_conntrack_tuple *tuple,
@@ -767,6 +915,9 @@ resolve_normal_ct(struct sk_buff *skb,
 	struct nf_conntrack_tuple tuple;
 	struct nf_conntrack_tuple_hash *h;
 	struct nf_conn *ct;
+#if defined (CONFIG_NAT_FCONE) || defined (CONFIG_NAT_RCONE)
+	struct iphdr *iph=(struct iphdr *)skb->nh.raw;
+#endif
 
 	if (!nf_ct_get_tuple(skb, (unsigned int)(skb->nh.raw - skb->data),
 			     dataoff, l3num, protonum, &tuple, l3proto,
@@ -776,7 +927,72 @@ resolve_normal_ct(struct sk_buff *skb,
 	}
 
 	/* look for tuple match */
-	h = nf_conntrack_find_get(&tuple, NULL);
+#if defined (CONFIG_NAT_FCONE) || defined (CONFIG_NAT_RCONE)
+        /*
+         * Based on NAT treatments of UDP in RFC3489:
+         *
+         * 1)Full Cone: A full cone NAT is one where all requests from the
+         * same internal IP address and port are mapped to the same external
+         * IP address and port.  Furthermore, any external host can send a
+         * packet to the internal host, by sending a packet to the mapped
+         * external address.
+         *
+         * 2)Restricted Cone: A restricted cone NAT is one where all requests
+         * from the same internal IP address and port are mapped to the same
+         * external IP address and port.  Unlike a full cone NAT, an external
+         * host (with IP address X) can send a packet to the internal host
+         * only if the internal host had previously sent a packet to IP
+         * address X.
+         *
+         * 3)Port Restricted Cone: A port restricted cone NAT is like a
+         * restricted cone NAT, but the restriction includes port numbers.
+         * Specifically, an external host can send a packet, with source IP
+         * address X and source port P, to the internal host only if the
+         * internal host had previously sent a packet to IP address X and
+         * port P.
+         *
+         * 4)Symmetric: A symmetric NAT is one where all requests from the
+         * same internal IP address and port, to a specific destination IP
+         * address and port, are mapped to the same external IP address and
+         * port.  If the same host sends a packet with the same source
+         * address and port, but to a different destination, a different
+         * mapping is used.  Furthermore, only the external host that
+         * receives a packet can send a UDP packet back to the internal host.
+         *
+         *
+	 *
+         *
+         * Original Linux NAT type is hybrid 'port restricted cone' and
+         * 'symmetric'. XBOX certificate recommands NAT type is 'fully cone'
+         * or 'restricted cone', so i patch the linux kernel to support
+         * this feature
+         * Tradition scenario from LAN->WAN:
+         *
+         *        (LAN)     (WAN)
+         * Client------>AP---------> Server
+         * -------------> (I)
+         *              -------------->(II)
+         *              <--------------(III)
+         * <------------- (IV)
+         *
+         *
+         * (CASE I/II/IV) Compared Tuple=src_ip/port & dst_ip/port & proto
+         * (CASE III)  Compared Tuple:
+         *             Fully cone=dst_ip/port & proto
+         *             Restricted Cone=dst_ip/port & proto & src_ip
+         *
+         */
+	if( (skb->dev!=NULL) && (iph!=NULL) && /* CASE III */
+		(strcmp(skb->dev->name, wan_name)==0) &&
+		(iph->protocol==IPPROTO_UDP)) {
+	    h = nf_cone_conntrack_find_get(&tuple, NULL);
+        }else{ /* CASE I.II.IV */
+            h = nf_conntrack_find_get(&tuple, NULL);
+        }
+#else //CONFIG_NAT_LINUX
+        h = nf_conntrack_find_get(&tuple, NULL);
+#endif
+
 	if (!h) {
 		h = init_conntrack(&tuple, l3proto, l4proto, skb, dataoff);
 		if (!h)
@@ -875,6 +1091,23 @@ nf_conntrack_in(int pf, unsigned int hooknum, struct sk_buff **pskb)
 		return -ret;
 	}
 
+#if defined(CONFIG_RA_SW_NAT) || defined(CONFIG_RA_SW_NAT_MODULE)
+	if (nfct_help(ct)->helper) {
+            if( (skb_headroom(*pskb) >=4)  && (FOE_MAGIC_TAG(*pskb) == FOE_MAGIC_NUM) ) {
+                FOE_HASH_NUM(*pskb) |= FOE_CONNTRACKING_FLAGS;
+            }
+	}
+#elif  defined(CONFIG_RA_HW_NAT) || defined(CONFIG_RA_HW_NAT_MODULE)
+	if (nfct_help(ct)->helper) {
+            if( IS_SPACE_AVAILABLED(*pskb) &&
+                    ((FOE_MAGIC_TAG(*pskb) == FOE_MAGIC_PCI) ||
+                     (FOE_MAGIC_TAG(*pskb) == FOE_MAGIC_WLAN) ||
+                     (FOE_MAGIC_TAG(*pskb) == FOE_MAGIC_GE))){
+                    FOE_ALG(*pskb)=1;
+	    }
+	}
+#endif
+
 	if (set_reply && !test_and_set_bit(IPS_SEEN_REPLY_BIT, &ct->status))
 		nf_conntrack_event_cache(IPCT_STATUS, *pskb);
 
diff --git a/net/netfilter/nf_conntrack_proto_tcp.c b/net/netfilter/nf_conntrack_proto_tcp.c
index 153d661..df30014 100644
--- a/net/netfilter/nf_conntrack_proto_tcp.c
+++ b/net/netfilter/nf_conntrack_proto_tcp.c
@@ -646,6 +646,7 @@ static int tcp_in_window(struct ip_ct_tcp *state,
 		before(sack, receiver->td_end + 1),
 		after(ack, receiver->td_end - MAXACKWINDOW(sender)));
 
+#if defined (CONFIG_RA_NAT_NONE)
 	if (before(seq, sender->td_maxend + 1) &&
 	    after(end, sender->td_end - receiver->td_maxwin - 1) &&
 	    before(sack, receiver->td_end + 1) &&
@@ -712,6 +713,9 @@ static int tcp_in_window(struct ip_ct_tcp *state,
 			: "SEQ is under the lower bound (already ACKed data retransmitted)"
 			: "SEQ is over the upper bound (over the window of the receiver)");
 	}
+#else
+	res = 1;
+#endif
 
 	DEBUGP("tcp_in_window: res=%i sender end=%u maxend=%u maxwin=%u "
 	       "receiver end=%u maxend=%u maxwin=%u\n",
diff --git a/net/netfilter/nf_conntrack_sip.c b/net/netfilter/nf_conntrack_sip.c
index 7aaa8c9..bfb2184 100644
--- a/net/netfilter/nf_conntrack_sip.c
+++ b/net/netfilter/nf_conntrack_sip.c
@@ -21,12 +21,6 @@
 #include <net/netfilter/nf_conntrack_helper.h>
 #include <linux/netfilter/nf_conntrack_sip.h>
 
-#if 0
-#define DEBUGP printk
-#else
-#define DEBUGP(format, args...)
-#endif
-
 MODULE_LICENSE("GPL");
 MODULE_AUTHOR("Christian Hentschel <chentschel@arnet.com.ar>");
 MODULE_DESCRIPTION("SIP connection tracking helper");
@@ -285,7 +279,7 @@ static int epaddr_len(struct nf_conn *ct, const char *dptr,
 	const char *aux = dptr;
 
 	if (!parse_addr(ct, dptr, &dptr, &addr, limit)) {
-		DEBUGP("ip: %s parse failed.!\n", dptr);
+		pr_debug("ip: %s parse failed.!\n", dptr);
 		return 0;
 	}
 
@@ -301,6 +295,7 @@ static int epaddr_len(struct nf_conn *ct, const char *dptr,
 static int skp_epaddr_len(struct nf_conn *ct, const char *dptr,
 			  const char *limit, int *shift)
 {
+	const char *start = dptr;
 	int s = *shift;
 
 	/* Search for @, but stop at the end of the line.
@@ -315,8 +310,10 @@ static int skp_epaddr_len(struct nf_conn *ct, const char *dptr,
 	if (dptr <= limit && *dptr == '@') {
 		dptr++;
 		(*shift)++;
-	} else
+	} else {
+		dptr = start;
 		*shift = s;
+	}
 
 	return epaddr_len(ct, dptr, limit, shift);
 }
@@ -336,7 +333,8 @@ int ct_sip_get_info(struct nf_conn *ct,
 
 	while (dptr <= limit) {
 		if ((strncmp(dptr, hnfo->lname, hnfo->lnlen) != 0) &&
-		    (strncmp(dptr, hnfo->sname, hnfo->snlen) != 0)) {
+		    (hnfo->sname == NULL ||
+		     strncmp(dptr, hnfo->sname, hnfo->snlen) != 0)) {
 			dptr++;
 			continue;
 		}
@@ -344,8 +342,8 @@ int ct_sip_get_info(struct nf_conn *ct,
 				    ct_sip_lnlen(dptr, limit),
 				    hnfo->case_sensitive);
 		if (!aux) {
-			DEBUGP("'%s' not found in '%s'.\n", hnfo->ln_str,
-			       hnfo->lname);
+			pr_debug("'%s' not found in '%s'.\n", hnfo->ln_str,
+				 hnfo->lname);
 			return -1;
 		}
 		aux += hnfo->ln_strlen;
@@ -356,11 +354,11 @@ int ct_sip_get_info(struct nf_conn *ct,
 
 		*matchoff = (aux - k) + shift;
 
-		DEBUGP("%s match succeeded! - len: %u\n", hnfo->lname,
-		       *matchlen);
+		pr_debug("%s match succeeded! - len: %u\n", hnfo->lname,
+			 *matchlen);
 		return 1;
 	}
-	DEBUGP("%s header not found.\n", hnfo->lname);
+	pr_debug("%s header not found.\n", hnfo->lname);
 	return 0;
 }
 EXPORT_SYMBOL_GPL(ct_sip_get_info);
@@ -382,8 +380,8 @@ static int set_expected_rtp(struct sk_buff **pskb,
 	if (exp == NULL)
 		return NF_DROP;
 	nf_conntrack_expect_init(exp, family,
-				 &ct->tuplehash[!dir].tuple.src.u3, addr,
-				 IPPROTO_UDP, NULL, &port);
+			  &ct->tuplehash[!dir].tuple.src.u3, addr,
+			  IPPROTO_UDP, NULL, &port);
 
 	nf_nat_sdp = rcu_dereference(nf_nat_sdp_hook);
 	if (nf_nat_sdp && ct->status & IPS_NAT_MASK)
@@ -424,7 +422,7 @@ static int sip_help(struct sk_buff **pskb,
 	if (!skb_is_nonlinear(*pskb))
 		dptr = (*pskb)->data + dataoff;
 	else {
-		DEBUGP("Copy of skbuff not supported yet.\n");
+		pr_debug("Copy of skbuff not supported yet.\n");
 		goto out;
 	}
 
@@ -442,6 +440,9 @@ static int sip_help(struct sk_buff **pskb,
 
 	/* RTP info only in some SDP pkts */
 	if (memcmp(dptr, "INVITE", sizeof("INVITE") - 1) != 0 &&
+	    memcmp(dptr, "UPDATE", sizeof("UPDATE") - 1) != 0 &&
+	    memcmp(dptr, "SIP/2.0 180", sizeof("SIP/2.0 180") - 1) != 0 &&
+	    memcmp(dptr, "SIP/2.0 183", sizeof("SIP/2.0 183") - 1) != 0 &&
 	    memcmp(dptr, "SIP/2.0 200", sizeof("SIP/2.0 200") - 1) != 0) {
 		goto out;
 	}
@@ -503,9 +504,6 @@ static int __init nf_conntrack_sip_init(void)
 		for (j = 0; j < 2; j++) {
 			sip[i][j].tuple.dst.protonum = IPPROTO_UDP;
 			sip[i][j].tuple.src.u.udp.port = htons(ports[i]);
-			sip[i][j].mask.src.l3num = 0xFFFF;
-			sip[i][j].mask.src.u.udp.port = htons(0xFFFF);
-			sip[i][j].mask.dst.protonum = 0xFF;
 			sip[i][j].max_expected = 2;
 			sip[i][j].timeout = 3 * 60; /* 3 minutes */
 			sip[i][j].me = THIS_MODULE;
@@ -518,7 +516,7 @@ static int __init nf_conntrack_sip_init(void)
 				sprintf(tmpname, "sip-%u", i);
 			sip[i][j].name = tmpname;
 
-			DEBUGP("port #%u: %u\n", i, ports[i]);
+			pr_debug("port #%u: %u\n", i, ports[i]);
 
 			ret = nf_conntrack_helper_register(&sip[i][j]);
 			if (ret) {
diff --git a/net/netfilter/nf_conntrack_standalone.c b/net/netfilter/nf_conntrack_standalone.c
index b858636..434cf73 100644
--- a/net/netfilter/nf_conntrack_standalone.c
+++ b/net/netfilter/nf_conntrack_standalone.c
@@ -195,6 +195,11 @@ static int ct_seq_show(struct seq_file *s, void *v)
 		return -ENOSPC;
 #endif
 
+#if defined(CONFIG_NETFILTER_XT_MATCH_LAYER7) || defined(CONFIG_NETFILTER_XT_MATCH_LAYER7_MODULE)
+	if(conntrack->layer7.app_proto)
+		if(seq_printf(s, "l7proto=%s ",conntrack->layer7.app_proto))
+			return -ENOSPC;
+#endif
 	if (seq_printf(s, "use=%u\n", atomic_read(&conntrack->ct_general.use)))
 		return -ENOSPC;
 	
diff --git a/net/sched/sch_generic.c b/net/sched/sch_generic.c
index 52eb343..771664a 100644
--- a/net/sched/sch_generic.c
+++ b/net/sched/sch_generic.c
@@ -181,6 +181,11 @@ requeue:
 	return q->q.qlen;
 }
 
+int qdisc_restart1(struct net_device *dev)
+{
+	return qdisc_restart(dev);
+}
+
 void __qdisc_run(struct net_device *dev)
 {
 	if (unlikely(dev->qdisc == &noop_qdisc))
@@ -617,3 +622,4 @@ EXPORT_SYMBOL(qdisc_destroy);
 EXPORT_SYMBOL(qdisc_reset);
 EXPORT_SYMBOL(qdisc_lock_tree);
 EXPORT_SYMBOL(qdisc_unlock_tree);
+EXPORT_SYMBOL(qdisc_restart1);
diff --git a/net/sched/sch_htb.c b/net/sched/sch_htb.c
index 3c3294d..ec69390 100644
--- a/net/sched/sch_htb.c
+++ b/net/sched/sch_htb.c
@@ -152,6 +152,15 @@ struct htb_class {
 				/* of un.leaf originals should be done. */
 };
 
+static inline long calc(int rate, int size)
+{
+	unsigned long long result = 1099511627776ULL;	/* 0x10000000000 */
+	do_div(result, rate);
+	result = result * size;
+	result = result >> 20;							/* div by 0x100000000000*/
+	return (long)result;
+}
+
 /* TODO: maybe compute rate when size is too large .. or drop ? */
 static inline long L2T(struct htb_class *cl, struct qdisc_rate_table *rate,
 			   int size)
@@ -160,6 +169,7 @@ static inline long L2T(struct htb_class *cl, struct qdisc_rate_table *rate,
 	if (slot > 255) {
 		cl->xstats.giants++;
 		slot = 255;
+		return calc(rate->rate.rate, size);
 	}
 	return rate->data[slot];
 }
diff --git a/net/sunrpc/cache.c b/net/sunrpc/cache.c
index f02f24a..9ea6d0a 100644
--- a/net/sunrpc/cache.c
+++ b/net/sunrpc/cache.c
@@ -516,7 +516,11 @@ void cache_purge(struct cache_detail *detail)
  * it to be revisited when cache info is available
  */
 
+#ifdef CONFIG_NET_SMALL
+#define	DFR_HASHSIZE	(512/sizeof(struct list_head))
+#else
 #define	DFR_HASHSIZE	(PAGE_SIZE/sizeof(struct list_head))
+#endif
 #define	DFR_HASH(item)	((((long)item)>>4 ^ (((long)item)>>13)) % DFR_HASHSIZE)
 
 #define	DFR_MAX	300	/* ??? */
diff --git a/scripts/gen_initramfs_list.sh b/scripts/gen_initramfs_list.sh
index 43f75d6..bc9bff4 100644
--- a/scripts/gen_initramfs_list.sh
+++ b/scripts/gen_initramfs_list.sh
@@ -223,6 +223,7 @@ cpio_file=
 cpio_list=
 output="/dev/stdout"
 output_file=""
+use_lzma="n"
 
 arg="$1"
 case "$arg" in
@@ -259,6 +260,9 @@ while [ $# -gt 0 ]; do
 			usage
 			exit 0
 			;;
+		"-l")
+			use_lzma="y"
+			;;
 		*)
 			case "$arg" in
 				"-"*)
@@ -282,7 +286,12 @@ if [ ! -z ${output_file} ]; then
 		cpio_tfile=${cpio_file}
 	fi
 	rm ${cpio_list}
-	cat ${cpio_tfile} | gzip -f -9 - > ${output_file}
+	if [ "$use_lzma" == "y" ]; then
+		cross_compile_path=`echo ${CONFIG_CROSS_COMPILER_PATH} | sed -e 's/\"//g'`
+		${cross_compile_path}/lzma_alone e ${cpio_tfile} ${output_file} -d20
+	else
+		cat ${cpio_tfile} | gzip -f -9 - > ${output_file}
+	fi
 	[ -z ${cpio_file} ] && rm ${cpio_tfile}
 fi
 exit 0
diff --git a/scripts/kconfig/lxdialog/check-lxdialog.sh b/scripts/kconfig/lxdialog/check-lxdialog.sh
index 120d624..3ad7fa8 100644
--- a/scripts/kconfig/lxdialog/check-lxdialog.sh
+++ b/scripts/kconfig/lxdialog/check-lxdialog.sh
@@ -4,11 +4,6 @@
 # What library to link
 ldflags()
 {
-	$cc -print-file-name=libncursesw.so | grep -q /
-	if [ $? -eq 0 ]; then
-		echo '-lncursesw'
-		exit
-	fi
 	$cc -print-file-name=libncurses.so | grep -q /
 	if [ $? -eq 0 ]; then
 		echo '-lncurses'
@@ -19,6 +14,11 @@ ldflags()
 		echo '-lcurses'
 		exit
 	fi
+	$cc -print-file-name=libncursesw.so | grep -q /
+	if [ $? -eq 0 ]; then
+		echo '-lncursesw'
+		exit
+	fi
 	exit 1
 }
 
diff --git a/scripts/mod/sumversion.c b/scripts/mod/sumversion.c
index 8a28756..2cb679c 100644
--- a/scripts/mod/sumversion.c
+++ b/scripts/mod/sumversion.c
@@ -8,6 +8,7 @@
 #include <errno.h>
 #include <string.h>
 #include "modpost.h"
+#include <linux/limits.h>
 
 /*
  * Stolen form Cryptographic API.
diff --git a/sound/oss/Kconfig b/sound/oss/Kconfig
index 4c41930..6c9cbd6 100644
--- a/sound/oss/Kconfig
+++ b/sound/oss/Kconfig
@@ -94,6 +94,13 @@ config SOUND_AU1550_AC97
 	select SND_AC97_CODEC
 	depends on SOUND_PRIME && (SOC_AU1550 || SOC_AU1200)
 
+config SOUND_AU1550_I2S
+	tristate "Au1550 I2S Sound"
+	depends on SOUND_PRIME && SOC_AU1550
+	# Weird I2S driver needs I2C driver to talk to the codec...
+	select I2C
+	select I2C_AU1550
+
 config SOUND_TRIDENT
 	tristate "Trident 4DWave DX/NX, SiS 7018 or ALi 5451 PCI Audio Core"
 	depends on SOUND_PRIME && PCI
diff --git a/sound/oss/Makefile b/sound/oss/Makefile
index 2489bd6..2124321 100644
--- a/sound/oss/Makefile
+++ b/sound/oss/Makefile
@@ -45,6 +45,7 @@ obj-$(CONFIG_SOUND_ICH)		+= i810_audio.o ac97_codec.o
 obj-$(CONFIG_SOUND_ES1371)	+= es1371.o ac97_codec.o
 obj-$(CONFIG_SOUND_VRC5477)	+= nec_vrc5477.o ac97_codec.o
 obj-$(CONFIG_SOUND_AU1550_AC97)	+= au1550_ac97.o ac97_codec.o
+obj-$(CONFIG_SOUND_AU1550_I2S)	+= au1550_i2s.o
 obj-$(CONFIG_SOUND_FUSION)	+= cs46xx.o ac97_codec.o
 obj-$(CONFIG_SOUND_TRIDENT)	+= trident.o ac97_codec.o
 obj-$(CONFIG_SOUND_EMU10K1)	+= ac97_codec.o
diff --git a/usr/Kconfig b/usr/Kconfig
index 07727f3..7b5b7ca 100644
--- a/usr/Kconfig
+++ b/usr/Kconfig
@@ -4,7 +4,7 @@
 
 config INITRAMFS_SOURCE
 	string "Initramfs source file(s)"
-	default ""
+	default "../romfs"
 	help
 	  This can be either a single cpio archive with a .cpio suffix or a
 	  space-separated list of directories and files for building the
diff --git a/usr/Makefile b/usr/Makefile
index 201f27f..6a26c3d 100644
--- a/usr/Makefile
+++ b/usr/Makefile
@@ -23,7 +23,8 @@ ramfs-input := $(if $(filter-out "",$(CONFIG_INITRAMFS_SOURCE)), \
 			$(shell echo $(CONFIG_INITRAMFS_SOURCE)),-d)
 ramfs-args  := \
         $(if $(CONFIG_INITRAMFS_ROOT_UID), -u $(CONFIG_INITRAMFS_ROOT_UID)) \
-        $(if $(CONFIG_INITRAMFS_ROOT_GID), -g $(CONFIG_INITRAMFS_ROOT_GID))
+        $(if $(CONFIG_INITRAMFS_ROOT_GID), -g $(CONFIG_INITRAMFS_ROOT_GID)) \
+	$(if $(CONFIG_LZMARAMFS), -l)
 
 # .initramfs_data.cpio.gz.d is used to identify all files included
 # in initramfs and to detect if any files are added/removed.
-- 
1.8.4.2

